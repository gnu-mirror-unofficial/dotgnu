<HTML>
<HEAD>
<TITLE>System.Net.Sockets.Socket Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Net.Sockets.Socket Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public class Socket : IDisposable</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;Socket<P>

This type implements <A HREF="../../../System/IDisposable.html" TARGET="contents">IDisposable</A>.
</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
System
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Creates a communication endpoint through which an application sends or receives data across a
      network.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This class enables a <A HREF="Socket.html" TARGET="contents">Socket</A> instance to communicate with another socket
   across a network. The communication can
   be through connection-oriented and connectionless protocols using either data streams or datagrams
   (discrete message packets).<P>

Message-oriented protocols preserve message boundaries
   and require that for each System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method call there is one
   corresponding System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method call. For stream-oriented protocols, data
   is transmitted without regards to message boundaries. In this case, for
   example, multiple System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method calls may be necessary to
   retrieve all the data from one System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method call. The protocol is set in
   the <CODE>Socket</CODE>

   
   class
   constructor. <P>

A <A HREF="Socket.html" TARGET="contents">Socket</A>
instance has a local and a remote endpoint associated with it. The local
endpoint contains the connection information for the current socket instance.
The remote endpoint contains the connection information for the socket that the current instance communicates with. The
endpoints are required to be an instance of a type derived from
the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> class. For the Transmission Control Protocol (TCP) and User Datagram Protocol (UDP) protocols, an endpoint
includes the address family, an Internet Protocol (IP) address, and a port number.
For connection-oriented protocols (for example, TCP), the remote endpoint
does not have to be specified when transferring data. For connectionless
protocols (for example, UDP), the remote endpoint is required to be specified.<P>

Methods are provided for both synchronous and asynchronous
   operations. A synchronous method can operate in blocking mode, in which it waits
   (blocks) until the operation is complete before returning, or in non-blocking
   mode, where it returns immediately, possibly before the operation has completed.
   The blocking mode is set through the System.Net.Sockets.Socket.Blocking property.<P>

 An asynchronous method returns immediately and, by convention, relies on a delegate to
   complete the operation. Asynchronous methods have names which correspond to their
   synchronous counterparts prefixed with either &apos;Begin&apos; or End&apos;. For example, the
   synchronous System.Net.Sockets.Socket.Accept method has asynchronous counterpart methods
   named System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) and System.Net.Sockets.Socket.EndAccept(System.IAsyncResult). The
   example for the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method shows the basic
   steps for using an asynchronous operation. A complete working example follows this
   discussion.<P>

Connection-oriented protocols commonly use the client/server model. In this model, one of
   the sockets is set up as a server, and one or more sockets are set
   up as clients. A general procedure demonstrating the synchronous communication process for this model is as
   follows.<P>

On the server-side:<P>

<OL>
<LI>
      Create a socket to listen for incoming connection
      requests.</LI>
<LI>
      Set the local endpoint using the System.Net.Sockets.Socket.Bind(System.Net.EndPoint) method.</LI>
<LI>
      Put the socket in the
      listening state using the System.Net.Sockets.Socket.Listen(System.Int32) method.</LI>
<LI>
      At this point incoming connection requests from a
      client are placed in a queue.</LI>
<LI>
      Use the System.Net.Sockets.Socket.Accept method to create a server socket
      for a connection request issued by a client-side socket. This sets the remote
      endpoint.</LI>
<LI>
      Use the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) methods to communicate with the
      client socket.</LI>
<LI>
      When communication is finished, terminate the connection
      using the System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown) method.</LI>
<LI>
      Release the resources allocated by the server socket using
      the System.Net.Sockets.Socket.Close method.</LI>
<LI>
      Release the resources allocated by the listener socket using the System.Net.Sockets.Socket.Close method.</LI>
</OL>
On the client-side:<P>

<OL>
<LI>
      Create the client socket.</LI>
<LI>
      Connect to the server socket using the System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method.
      This sets both the local and remote endpoints for the client socket.</LI>
<LI>
      Use the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) methods to communicate with the
      server socket.</LI>
<LI>&amp;gt;
      When communication is finished, terminate the connection
      using the System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown) method.</LI>
<LI>
      Release
      
      the resources allocated by the client socket using
      the System.Net.Sockets.Socket.Close
      
      method.</LI>
</OL>
 The shutdown step in the previous procedure is
   not necessary but ensures that any pending data is not lost. If the
System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown) method is not called, the 
System.Net.Sockets.Socket.Close 
method shuts
down the connection either gracefully or by force. A graceful closure attempts
to transfer all pending data before the connection is terminated. Use
the System.Net.Sockets.SocketOptionName.Linger socket option to specify a graceful closure for a
socket. <P>

[<I>Note</I>:  This implementation is based on the UNIX sockets implementation
      in the Berkeley Software Distribution (BSD, release 4.3)
      from the University of California at Berkeley. <P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following examples provide a client/server
      application that demonstrates the
      use of asynchronous communication between sockets. Run the client and server on
      different consoles.<P>

 The following code is for the
      server application. Start this application before the client application.<P>

<PRE>using System;
using System.Threading;
using System.Text;
using System.Net;
using System.Net.Sockets;

public class Server 
{
  // used to pass state information to delegate
  internal class StateObject 
  {
    internal byte[] sBuffer;
    internal Socket sSocket;
    internal StateObject(int size, Socket sock) {
      sBuffer = new byte[size];
      sSocket = sock;
    }
  }
  static void Main() 
  {
    IPAddress ipAddress =
      Dns.Resolve( Dns.GetHostName() ).AddressList[0];

    IPEndPoint ipEndpoint =
      new IPEndPoint(ipAddress, 1800);

    Socket listenSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    listenSocket.Bind(ipEndpoint);
    listenSocket.Listen(1);
    IAsyncResult asyncAccept = listenSocket.BeginAccept(
      new AsyncCallback(Server.acceptCallback),
      listenSocket );

    // could call listenSocket.EndAccept(asyncAccept) here
    // instead of in the callback method, but since 
    // EndAccept blocks, the behavior would be similar to 
    // calling the synchronous Accept method

    Console.Write(&quot;Connection in progress.&quot;);
    if( writeDot(asyncAccept) == true ) 
    {
      // allow time for callbacks to
      // finish before the program ends 
      Thread.Sleep(3000);
    }
  }

  public static void
    acceptCallback(IAsyncResult asyncAccept) {
      Socket listenSocket = (Socket)asyncAccept.AsyncState;
      Socket serverSocket =
        listenSocket.EndAccept(asyncAccept);

      // arriving here means the operation completed
      // (asyncAccept.IsCompleted = true) but not
      // necessarily successfully
      if( serverSocket.Connected == false )
      {
        Console.WriteLine( &quot;.server is not connected.&quot; );
        return;
      }
      else Console.WriteLine( &quot;.server is connected.&quot; );

      listenSocket.Close();

      StateObject stateObject =
        new StateObject(16, serverSocket);

      // this call passes the StateObject because it 
      // needs to pass the buffer as well as the socket
      IAsyncResult asyncReceive =
        serverSocket.BeginReceive(
          stateObject.sBuffer,
          0,
          stateObject.sBuffer.Length,
          SocketFlags.None,
          new AsyncCallback(receiveCallback),
          stateObject);

      Console.Write(&quot;Receiving data.&quot;);
      writeDot(asyncReceive);
  }

  public static void
    receiveCallback(IAsyncResult asyncReceive) {
      StateObject stateObject =
        (StateObject)asyncReceive.AsyncState;
      int bytesReceived =
        stateObject.sSocket.EndReceive(asyncReceive);

      Console.WriteLine(
        &quot;.{0} bytes received: {1}&quot;,
        bytesReceived.ToString(),
        Encoding.ASCII.GetString(stateObject.sBuffer) );

      byte[] sendBuffer =
        Encoding.ASCII.GetBytes(&quot;Goodbye&quot;);
      IAsyncResult asyncSend =
        stateObject.sSocket.BeginSend(
          sendBuffer,
          0,
          sendBuffer.Length,
          SocketFlags.None,
          new AsyncCallback(sendCallback),
          stateObject.sSocket);

      Console.Write(&quot;Sending response.&quot;);
      writeDot(asyncSend);
  }

  public static void sendCallback(IAsyncResult asyncSend) {
    Socket serverSocket = (Socket)asyncSend.AsyncState;
    int bytesSent = serverSocket.EndSend(asyncSend);
    Console.WriteLine(
      &quot;.{0} bytes sent.{1}{1}Shutting down.&quot;,
      bytesSent.ToString(),
      Environment.NewLine );

    serverSocket.Shutdown(SocketShutdown.Both);
    serverSocket.Close();
  }

  // times out after 20 seconds but operation continues
  internal static bool writeDot(IAsyncResult ar)
  {
    int i = 0;
    while( ar.IsCompleted == false ) 
    {
      if( i++ &gt; 40 ) 
      {
        Console.WriteLine(&quot;Timed out.&quot;);
        return false;
      }
      Console.Write(&quot;.&quot;);
      Thread.Sleep(500);
    }
    return true;
  }
}
   </PRE>
The following code is for the client application. When
      starting the application, supply the hostname of the console running the server
      application as an input parameter (for example, ProgramName <I>hostname</I>
      ). <P>

<PRE>using System;
using System.Threading;
using System.Text;
using System.Net;
using System.Net.Sockets;

public class Client {

  // used to pass state information to delegate
  class StateObject 
  {
    internal byte[] sBuffer;
    internal Socket sSocket;
    internal StateObject(int size, Socket sock) {
      sBuffer = new byte[size];
      sSocket = sock;
    }
  }

  static void Main(string[] argHostName) 
  {
    IPAddress ipAddress =
      Dns.Resolve( argHostName[0] ).AddressList[0];

    IPEndPoint ipEndpoint =
      new IPEndPoint(ipAddress, 1800);

    Socket clientSocket = new Socket(
      AddressFamily.InterNetwork,
      SocketType.Stream,
      ProtocolType.Tcp);

    IAsyncResult asyncConnect = clientSocket.BeginConnect(
      ipEndpoint,
      new AsyncCallback(connectCallback),
      clientSocket );

    Console.Write(&quot;Connection in progress.&quot;);
    if( writeDot(asyncConnect) == true ) 
    {
      // allow time for callbacks to
      // finish before the program ends
      Thread.Sleep(3000);
    }
  }

  public static void
    connectCallback(IAsyncResult asyncConnect) {
      Socket clientSocket =
        (Socket)asyncConnect.AsyncState;
      clientSocket.EndConnect(asyncConnect);
      // arriving here means the operation completed
      // (asyncConnect.IsCompleted = true) but not
      // necessarily successfully
      if( clientSocket.Connected == false )
      {
        Console.WriteLine( &quot;.client is not connected.&quot; );
        return;
      }
      else Console.WriteLine( &quot;.client is connected.&quot; );

      byte[] sendBuffer = Encoding.ASCII.GetBytes(&quot;Hello&quot;);
      IAsyncResult asyncSend = clientSocket.BeginSend(
        sendBuffer,
        0,
        sendBuffer.Length,
        SocketFlags.None,
        new AsyncCallback(sendCallback),
        clientSocket);

      Console.Write(&quot;Sending data.&quot;);
      writeDot(asyncSend);
  }

  public static void sendCallback(IAsyncResult asyncSend) 
  {
    Socket clientSocket = (Socket)asyncSend.AsyncState;
    int bytesSent = clientSocket.EndSend(asyncSend);
    Console.WriteLine(
      &quot;.{0} bytes sent.&quot;,
      bytesSent.ToString() );

    StateObject stateObject =
      new StateObject(16, clientSocket);

    // this call passes the StateObject because it
    // needs to pass the buffer as well as the socket
    IAsyncResult asyncReceive =
      clientSocket.BeginReceive(
        stateObject.sBuffer,
        0,
        stateObject.sBuffer.Length,
        SocketFlags.None,
        new AsyncCallback(receiveCallback),
        stateObject);

    Console.Write(&quot;Receiving response.&quot;);
    writeDot(asyncReceive);
  }

  public static void
    receiveCallback(IAsyncResult asyncReceive) {
      StateObject stateObject =
       (StateObject)asyncReceive.AsyncState;

      int bytesReceived =
        stateObject.sSocket.EndReceive(asyncReceive);

      Console.WriteLine(
        &quot;.{0} bytes received: {1}{2}{2}Shutting down.&quot;,
        bytesReceived.ToString(),
        Encoding.ASCII.GetString(stateObject.sBuffer),
        Environment.NewLine );

      stateObject.sSocket.Shutdown(SocketShutdown.Both);
      stateObject.sSocket.Close();
  }

  // times out after 2 seconds but operation continues
  internal static bool writeDot(IAsyncResult ar)
  {
    int i = 0;
    while( ar.IsCompleted == false ) 
    {
      if( i++ &gt; 20 ) 
      {
        Console.WriteLine(&quot;Timed out.&quot;);
        return false;
      }
      Console.Write(&quot;.&quot;);
      Thread.Sleep(100);
    }
    return true;
  }
}
   </PRE>
The output of the server application is<P>

<CODE>Connection in progress...........server is connected.<P>

Receiving data......5 bytes received: Hello<P>

Sending response....7 bytes sent.<P>

Shutting down.<P>

-----------------------------------------<P>

</CODE>The output of the client application is<P>

<CODE>Connection in progress......client is connected.<P>

Sending data......5 bytes sent.<P>

Receiving response......7 bytes received: Goodbye<P>

Shutting down.<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

Socket Constructors<P>

<A HREF="#Socket Constructor" TARGET="contents">Socket Constructor</A><BR>
<P>

Socket Methods<P>

<A HREF="#Socket.Accept Method" TARGET="contents">Socket.Accept Method</A><BR>
<A HREF="#Socket.BeginAccept Method" TARGET="contents">Socket.BeginAccept Method</A><BR>
<A HREF="#Socket.BeginConnect Method" TARGET="contents">Socket.BeginConnect Method</A><BR>
<A HREF="#Socket.BeginReceive Method" TARGET="contents">Socket.BeginReceive Method</A><BR>
<A HREF="#Socket.BeginReceiveFrom Method" TARGET="contents">Socket.BeginReceiveFrom Method</A><BR>
<A HREF="#Socket.BeginSend Method" TARGET="contents">Socket.BeginSend Method</A><BR>
<A HREF="#Socket.BeginSendTo Method" TARGET="contents">Socket.BeginSendTo Method</A><BR>
<A HREF="#Socket.Bind Method" TARGET="contents">Socket.Bind Method</A><BR>
<A HREF="#Socket.Close Method" TARGET="contents">Socket.Close Method</A><BR>
<A HREF="#Socket.Connect Method" TARGET="contents">Socket.Connect Method</A><BR>
<A HREF="#Socket.Dispose Method" TARGET="contents">Socket.Dispose Method</A><BR>
<A HREF="#Socket.EndAccept Method" TARGET="contents">Socket.EndAccept Method</A><BR>
<A HREF="#Socket.EndConnect Method" TARGET="contents">Socket.EndConnect Method</A><BR>
<A HREF="#Socket.EndReceive Method" TARGET="contents">Socket.EndReceive Method</A><BR>
<A HREF="#Socket.EndReceiveFrom Method" TARGET="contents">Socket.EndReceiveFrom Method</A><BR>
<A HREF="#Socket.EndSend Method" TARGET="contents">Socket.EndSend Method</A><BR>
<A HREF="#Socket.EndSendTo Method" TARGET="contents">Socket.EndSendTo Method</A><BR>
<A HREF="#Socket.Finalize Method" TARGET="contents">Socket.Finalize Method</A><BR>
<A HREF="#Socket.GetHashCode Method" TARGET="contents">Socket.GetHashCode Method</A><BR>
<A HREF="#Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName) Method" TARGET="contents">Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName) Method</A><BR>
<A HREF="#Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method" TARGET="contents">Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method</A><BR>
<A HREF="#Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method" TARGET="contents">Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method</A><BR>
<A HREF="#Socket.IOControl Method" TARGET="contents">Socket.IOControl Method</A><BR>
<A HREF="#Socket.Listen Method" TARGET="contents">Socket.Listen Method</A><BR>
<A HREF="#Socket.Poll Method" TARGET="contents">Socket.Poll Method</A><BR>
<A HREF="#Socket.Receive(byte[], int, System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Receive(byte[], int, System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.Receive(byte[], System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Receive(byte[], System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.Receive(byte[]) Method" TARGET="contents">Socket.Receive(byte[]) Method</A><BR>
<A HREF="#Socket.Receive(byte[], int, int, System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Receive(byte[], int, int, System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.ReceiveFrom(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&) Method" TARGET="contents">Socket.ReceiveFrom(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</A><BR>
<A HREF="#Socket.ReceiveFrom(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&) Method" TARGET="contents">Socket.ReceiveFrom(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</A><BR>
<A HREF="#Socket.ReceiveFrom(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint&) Method" TARGET="contents">Socket.ReceiveFrom(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</A><BR>
<A HREF="#Socket.ReceiveFrom(byte[], System.Net.EndPoint&) Method" TARGET="contents">Socket.ReceiveFrom(byte[], System.Net.EndPoint&amp;) Method</A><BR>
<A HREF="#Socket.Select Method" TARGET="contents">Socket.Select Method</A><BR>
<A HREF="#Socket.Send(byte[], int, System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Send(byte[], int, System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.Send(byte[], System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Send(byte[], System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.Send(byte[]) Method" TARGET="contents">Socket.Send(byte[]) Method</A><BR>
<A HREF="#Socket.Send(byte[], int, int, System.Net.Sockets.SocketFlags) Method" TARGET="contents">Socket.Send(byte[], int, int, System.Net.Sockets.SocketFlags) Method</A><BR>
<A HREF="#Socket.SendTo(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method" TARGET="contents">Socket.SendTo(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</A><BR>
<A HREF="#Socket.SendTo(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method" TARGET="contents">Socket.SendTo(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</A><BR>
<A HREF="#Socket.SendTo(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method" TARGET="contents">Socket.SendTo(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</A><BR>
<A HREF="#Socket.SendTo(byte[], System.Net.EndPoint) Method" TARGET="contents">Socket.SendTo(byte[], System.Net.EndPoint) Method</A><BR>
<A HREF="#Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method" TARGET="contents">Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method</A><BR>
<A HREF="#Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method" TARGET="contents">Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method</A><BR>
<A HREF="#Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object) Method" TARGET="contents">Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object) Method</A><BR>
<A HREF="#Socket.Shutdown Method" TARGET="contents">Socket.Shutdown Method</A><BR>
<A HREF="#Socket.System.IDisposable.Dispose Method" TARGET="contents">Socket.System.IDisposable.Dispose Method</A><BR>
<P>

Socket Properties<P>

<A HREF="#Socket.AddressFamily Property" TARGET="contents">Socket.AddressFamily Property</A><BR>
<A HREF="#Socket.Available Property" TARGET="contents">Socket.Available Property</A><BR>
<A HREF="#Socket.Blocking Property" TARGET="contents">Socket.Blocking Property</A><BR>
<A HREF="#Socket.Connected Property" TARGET="contents">Socket.Connected Property</A><BR>
<A HREF="#Socket.Handle Property" TARGET="contents">Socket.Handle Property</A><BR>
<A HREF="#Socket.LocalEndPoint Property" TARGET="contents">Socket.LocalEndPoint Property</A><BR>
<A HREF="#Socket.ProtocolType Property" TARGET="contents">Socket.ProtocolType Property</A><BR>
<A HREF="#Socket.RemoteEndPoint Property" TARGET="contents">Socket.RemoteEndPoint Property</A><BR>
<A HREF="#Socket.SocketType Property" TARGET="contents">Socket.SocketType Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="Socket Constructor"><H3>Socket Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Constructs and initializes a new instance of the <A HREF="Socket.html" TARGET="contents">Socket</A> class.
   <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>addressFamily</DT>
<DD>One of the values defined in the <A HREF="AddressFamily.html" TARGET="contents">AddressFamily</A> enumeration. </DD>
<DT>socketType</DT>
<DD>One of the values defined in the <A HREF="SocketType.html" TARGET="contents">SocketType</A> enumeration. </DD>
<DT>protocolType</DT>
<DD>One of the values defined in the <A HREF="ProtocolType.html" TARGET="contents">ProtocolType</A> enumeration. </DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>The combination of <I>addressFamily</I>, <I>socketType</I>, and <I>protocolType</I> is invalid.<P>

-or-<P>

An error occurred while creating the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 The <I>addressFamily </I>parameter
   specifies the addressing scheme used by the current instance, the <I>socketType    </I>parameter specifies the socket type of the current instance, and the
<I>protocolType</I> parameter 
   specifies the protocol
   used by the current instance. The three parameters are not independent. Some
   address families restrict which protocols are used, and often the socket type is
   determined by the protocol. When the specified
   values are not a valid combination, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception
   is thrown.<P>

Using the <CODE>Unknown</CODE>
 member of either the
<A HREF="AddressFamily.html" TARGET="contents">AddressFamily</A> or <A HREF="ProtocolType.html" TARGET="contents">ProtocolType</A> enumeration, results 
in a <A HREF="SocketException.html" TARGET="contents">SocketException</A>
exception being thrown.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Accept Method"><H3>Socket.Accept Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public Socket Accept();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Creates and initializes a new <A HREF="Socket.html" TARGET="contents">Socket</A> instance and connects it to an incoming connection
   request.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A new connected <A HREF="Socket.html" TARGET="contents">Socket</A>
instance.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>An error occurred while creating the new <A HREF="Socket.html" TARGET="contents">Socket</A>.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method is used only on the server-side of connection-oriented protocols. It extracts the first
      connection request from the queue of pending requests, creates a new <A HREF="Socket.html" TARGET="contents">Socket</A>
      instance, and connects this instance to the socket associated with the request.<P>

 The System.Net.Sockets.Socket.Blocking property
   of the socket determines the behavior of this method when there are no pending
   connection requests. When <CODE>false</CODE>
, this method returns
<CODE>null</CODE>
.
   When <CODE>true</CODE>
, this method blocks.<P>

 The following properties of the new <A HREF="Socket.html" TARGET="contents">Socket</A> instance returned by this method have values 
identical to the corresponding properties of the current instance:<P>

<UL>
<LI>System.Net.Sockets.Socket.AddressFamily</LI>
<LI>System.Net.Sockets.Socket.Blocking</LI>
<LI>System.Net.Sockets.Socket.LocalEndPoint</LI>
<LI>System.Net.Sockets.Socket.ProtocolType</LI>
<LI>System.Net.Sockets.Socket.SocketType</LI>
</UL>
 The System.Net.Sockets.Socket.RemoteEndPoint property of the new instance is set to the local endpoint of the first request in
the input queue. The System.Net.Sockets.Socket.Connected property is set to <CODE>true</CODE>
.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginAccept Method"><H3>Socket.BeginAccept Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginAccept(AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Begins an asynchronous operation to accept an incoming connection request.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while starting the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
To retrieve the results of the operation and release
      resources allocated by the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method, and specify the
   <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

To determine the connection status, check the System.Net.Sockets.Socket.Connected property, or use either the System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
or System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)
method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.Accept, the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 The following excerpt from the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview
   example outlines an asynchronous accept operation. <P>

<PRE>public class Server
{
  static void Main()
  {
    .
    .
    .
    listenSocket.BeginAccept(
      new AsyncCallback(Server.acceptCallback),
      listenSocket);
    .
    .
    .
    // EndAccept can be called here
    .
    .
    .
  }

  public static void
    acceptCallback(IAsyncResult asyncAccept)
  {
    Socket listenSocket =
      (Socket)asyncAccept.AsyncState;

    Socket serverSocket =
      listenSocket.EndAccept(asyncAccept);

    serverSocket.BeginReceive(...);
    .
    .
    .
  }
}
</PRE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginConnect Method"><H3>Socket.BeginConnect Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Begins an asynchronous operation to associate the current instance with a remote endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to connect to.<P>

</DD>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while starting the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller higher in the call stack does not have permission for the requested operation.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 To release
      resources allocated by the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndConnect(System.IAsyncResult) method, and specify the
      <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this
      
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndConnect(System.IAsyncResult) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

To determine the connection status, check the System.Net.Sockets.Socket.Connected property, or use either the System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)
or System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32) method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.Connect(System.Net.EndPoint), the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 For an outline of an asynchronous
      operation, see the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object) method, see the
      <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginReceive Method"><H3>Socket.BeginReceive Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginReceive(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Begins an asynchronous operation to receive data from a socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT> offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer </I>to begin storing the received data.</DD>
<DT> size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT> socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or-<P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
To retrieve the results of the operation and release
      resources allocated by the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) method, and specify the
   <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this
      
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags), the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginReceiveFrom Method"><H3>Socket.BeginReceiveFrom Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP, AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Begins an asynchronous operation to receive data from a socket and,
      for connectionless protocols, store the endpoint associated with the socket that
      sent the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT> offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer </I>to begin storing the received data.</DD>
<DT> size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT> socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek .</DD>
<DT> remoteEP</DT>
<DD>An instance of a class derived from the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> class, which contains the endpoint associated with the socket that sent the data.<P>

</DD>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.<P>

-or-<P>

<I>remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or-<P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
To retrieve the results of the operation and release
      resources allocated by the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@) method, and specify the
   <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this
      
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@), the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, see <A HREF="Socket.html" TARGET="contents">Socket</A>.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginSend Method"><H3>Socket.BeginSend Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginSend(byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Begins an asynchronous operation to send data to a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array storing data to send to the socket.</DD>
<DT> offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer</I> containing the starting location of the data to send.</DD>
<DT> size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT> socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand .</DD>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or- <P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
To retrieve the results of the operation and release
      resources allocated by the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndSend(System.IAsyncResult) method, and specify the
   <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by
      this
      
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndSend(System.IAsyncResult) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndSend(System.IAsyncResult)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags), the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.BeginSendTo Method"><H3>Socket.BeginSendTo Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IAsyncResult BeginSendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Begins an asynchronous operation to send data to the socket associated with the specified endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array storing data to send to the socket.</DD>
<DT>offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer</I> to begin sending data.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand .</DD>
<DT> remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to receive the data.<P>

</DD>
<DT>callback</DT>
<DD>A <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate, or <CODE>null</CODE>
.</DD>
<DT> state</DT>
<DD>An application-defined object, or <CODE>null</CODE>
.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> instance that contains information about the asynchronous operation.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.<P>

-or-<P>

<I>remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or-<P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
To retrieve the results of the operation and release
      resources allocated by the System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object) method, call
      the System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult) method, and specify the
   <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this
      
      method.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult) method should be
   called exactly once for each call to the System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)
   method.]<P>

<P>

If the <I>callback</I> parameter is not
<CODE>null</CODE>
, the method referenced by <I>callback</I> is invoked 
when the asynchronous operation completes. The <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object returned by this method is
passed as the argument to the method referenced by <I>callback</I>. The method
referenced by <I>callback</I> can retrieve the results of the operation by calling
the System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)
method.<P>

 The <I>state</I> parameter
can be any object that the caller wishes to have available for the duration of
the asynchronous operation. This object is available via the
System.IAsyncResult.AsyncState 
property of the object returned by this
method.<P>

[<I>Note</I>: For more information, see System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint), the
   synchronous version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For
      the complete example, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Bind Method"><H3>Socket.Bind Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void Bind(EndPoint localEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Associates the current instance with a local endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>localEP</DT>
<DD>The local <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> to be associated with the socket.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>localEP </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD> A caller in the call stack does not have the required permission.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method sets the System.Net.Sockets.Socket.LocalEndPoint property of the current instance to
<I>localEP</I>.<P>

[<I>Note</I>: For connection-oriented protocols, this method is
      generally used only on the server-side and is required to be called before the first
      call to the System.Net.Sockets.Socket.Listen(System.Int32) method.
      On the client-side, binding is usually performed implicitly by the System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method. <P>

For connectionless protocols, the System.Net.Sockets.Socket.Connect(System.Net.EndPoint)System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint), and System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object) methods bind the current instance to
the local endpoint if the current instance has not previously been bound. <P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Close Method"><H3>Socket.Close Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void Close();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Closes the current instance and releases all managed and unmanaged resources allocated by the current instance.
      <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method calls the
   System.Net.Sockets.Socket.Dispose(System.Boolean)(<A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>)
      method with the argument set to <CODE>true</CODE>
, which frees both managed
      and unmanaged resources used by the current instance. <P>

The socket attempts to perform a graceful closure when the System.Net.Sockets.SocketOptionName.Linger socket option is enabled
   and set to a non-zero linger time. In all other cases, closure is forced and any
   pending data is lost.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Connect Method"><H3>Socket.Connect Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void Connect(EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Associates the current instance with a remote endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to connect to.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>remoteEP </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD> A caller in the call stack does not have the required permission.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method sets the System.Net.Sockets.Socket.RemoteEndPoint property of the current instance to
<I>remoteEP</I>.<P>

[<I>Note</I>:  For connection-oriented protocols, this method
      establishes a connection between the current instance and the
      socket associated with <I>remoteEP</I>. This method is used only on
      the client-side. The System.Net.Sockets.Socket.Accept method establishes the connection on the
      server-side. Once the connection has been made, data can
      be sent using the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
      method, and received using the System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method. <P>

 For connectionless protocols, the System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
method can be used from both
client and server-sides, allowing the use of the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method instead of the System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
method. The System.Net.Sockets.Socket.RemoteEndPoint property is set to
<I>remoteEP</I> 
and
the System.Net.Sockets.Socket.LocalEndPoint property is set to a value determined
by the protocol; however, a connection is not established. Subsequent data is
required to be received on the endpoint set in
the System.Net.Sockets.Socket.LocalEndPoint property.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Dispose Method"><H3>Socket.Dispose Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>protected virtual void Dispose(bool disposing);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Closes the current instance, releases the unmanaged resources allocated by the current
      instance, and optionally releases the
      managed resources.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>disposing</DT>
<DD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>. Specify <CODE>true</CODE>
 to release both managed and unmanaged resources; <CODE>false</CODE>
 to release only unmanaged resources.</DD>
</DL>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: 
      
      This method
      closes the current <A HREF="Socket.html" TARGET="contents">Socket</A> instance
      and releases all unmanaged resources allocated by the
      current instance. When <I>disposing</I> is <CODE>true</CODE>
, this method also releases all resources held by any managed
      objects allocated by the current
      instance.
   ]<P>

<P>

[<I>Default</I>: 
      
      This method
      closes the current <A HREF="Socket.html" TARGET="contents">Socket</A> instance but does not release any managed
      resources.
   ]<P>

<P>

[<I>Overrides</I>: 
      
      The System.Net.Sockets.Socket.Dispose(System.Boolean) method can be called
      multiple times by other objects. When overriding this method, do not reference
      objects that have been previously disposed in an earlier call.
   ]<P>

<P>

[<I>Usage</I>: 
      
      Use this method to release
      resources allocated by
      the current
      instance.
   ]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndAccept Method"><H3>Socket.EndAccept Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public Socket EndAccept(IAsyncResult asyncResult);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Ends an asynchronous call to accept
      an incoming connection
      request.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A new connected <A HREF="Socket.html" TARGET="contents">Socket</A>
instance.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.EndAccept(System.IAsyncResult) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndConnect Method"><H3>Socket.EndConnect Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void EndConnect(IAsyncResult asyncResult);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Ends an asynchronous call
      to associate the current instance with a remote endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndConnect(System.IAsyncResult) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.EndConnect(System.IAsyncResult) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndReceive Method"><H3>Socket.EndReceive Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int EndReceive(IAsyncResult asyncResult);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Ends an asynchronous call to receive
      data from a
      socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.EndReceive(System.IAsyncResult) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndReceiveFrom Method"><H3>Socket.EndReceiveFrom Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int EndReceiveFrom(IAsyncResult asyncResult, ref EndPoint endPoint);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Ends an asynchronous call to receive
      data from a socket and store the endpoint associated with the socket that
      sent the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.<P>

</DD>
<DT> endPoint</DT>
<DD>A reference to the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket that sent the data. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For
      the complete example, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndSend Method"><H3>Socket.EndSend Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int EndSend(IAsyncResult asyncResult);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Ends an asynchronous call to send data
      to a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes sent. <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndSend(System.IAsyncResult) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndSend(System.IAsyncResult)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndSend(System.IAsyncResult)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For the complete example, which uses the System.Net.Sockets.Socket.EndSend(System.IAsyncResult) method, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.EndSendTo Method"><H3>Socket.EndSendTo Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int EndSendTo(IAsyncResult asyncResult);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Ends an asynchronous call to send data to a socket associated
      with a specified endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>asyncResult</DT>
<DD>A <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> object that holds the state information for the asynchronous operation.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes sent. <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>asyncResult </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>asyncResult </I> was not returned by the current instance from a call to the System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint) method.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult) was previously called for this operation.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred during the operation. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method blocks if the asynchronous operation has not completed.<P>

The System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)
method completes an asynchronous request that was started with a call to the
System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object) method. The object specified for the 
<I>asyncResult</I> parameter is required to be the same object as was returned 
by the System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)
method call that began the
request.<P>

If the System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)
method is invoked via the <A HREF="../../../System/AsyncCallback.html" TARGET="contents">AsyncCallback</A> delegate specified to the System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object) method, the
<I>asyncResult</I> parameter is the <A HREF="../../../System/IAsyncResult.html" TARGET="contents">IAsyncResult</A> 
argument passed to the
delegate&apos;s method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an outline of an asynchronous operation, see
      the System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object) method.
      For
      the complete example, see the <A HREF="Socket.html" TARGET="contents">Socket</A> class overview.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Finalize Method"><H3>Socket.Finalize Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>~Socket();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Closes the current instance and releases unmanaged resources allocated by the current
      instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>:  Application code does not call this method; it
         is automatically invoked during garbage collection unless finalization by the
         garbage collector has been disabled. For more information, see System.GC.SuppressFinalize(System.Object),
         and System.Object.Finalize.<P>

 This method calls System.Net.Sockets.NetworkStream.Dispose(System.Boolean)(<CODE>false</CODE>
) to free unmanaged
      resources used by the current instance.<P>

This method overrides System.Object.Finalize.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.GetHashCode Method"><H3>Socket.GetHashCode Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public override int GetHashCode();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Generates a hash code for the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the hash code for the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>

      The algorithm used to generate the hash code is unspecified.
   <P>

[<I>Note</I>: 
      
      This method overrides System.Object.GetHashCode.
   ]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName) Method"><H3>Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Retrieves an object containing the value of the specified socket option.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>One of the values defined in the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration. </DD>
<DT>optionName</DT>
<DD>One of the values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 The following table describes the values returned 
      by this method.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Return value</TH><TH>optionNameReturn value</TH></TR>
<TR><TD> An instance of the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A>
   class.</TD><TD><CODE>Linger</CODE>
 An instance of the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A>
   class.</TD></TR>
<TR><TD> An instance of
   the <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A>
   class.</TD><TD><CODE>AddMembership</CODE>
<P>

 -or-<P>

<CODE>DropMembership</CODE>
<P>

 An instance of
   the <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A>
   class.</TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the value
of the option.</TD><TD> All other values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the value
of the option.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Socket options determine the behavior of the
      current instance. <P>

<I>optionLevel</I> and <I>optionName</I> are not
   independent. See the System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)(<CODE>SocketOptionLevel</CODE>
,
<CODE>SocketOptionName</CODE>
, <CODE>Int32</CODE>
) method for a listing of the values of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration grouped
   by <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>. <P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example gets the state of the linger option and the size of the receive buffer, changes the values of both, then gets the new values.<P>

<PRE>using System;
using System.Net.Sockets;

class OptionTest{

  public static void Main() {

    // Get the current option values.
    Socket someSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    LingerOption lingerOp =
      (LingerOption)someSocket.GetSocketOption(
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger);

    int receiveBuffer =
      (int)someSocket.GetSocketOption(
           SocketOptionLevel.Socket,
           SocketOptionName.ReceiveBuffer);

    Console.WriteLine(
      &quot;Linger option is {0} and set to {1} seconds.&quot;,
      lingerOp.Enabled.ToString(),
      lingerOp.LingerTime.ToString() );

    Console.WriteLine(
      &quot;Size of the receive buffer is {0} bytes.&quot;,
      receiveBuffer.ToString() );

    // Change the options.
    lingerOp = new LingerOption(true, 10);
    someSocket.SetSocketOption(
      SocketOptionLevel.Socket,
      SocketOptionName.Linger,
      lingerOp);

    someSocket.SetSocketOption(
      SocketOptionLevel.Socket,
      SocketOptionName.ReceiveBuffer,
      2048);

    Console.WriteLine(
      &quot;The SetSocketOption method has been called.&quot;);
 
    // Get the new option values.
    lingerOp =
      (LingerOption)someSocket.GetSocketOption(
                    SocketOptionLevel.Socket,
                    SocketOptionName.Linger);

    receiveBuffer =
      (int)someSocket.GetSocketOption(
           SocketOptionLevel.Socket,
           SocketOptionName.ReceiveBuffer);

    Console.WriteLine(
      &quot;Linger option is now {0} and set to {1} seconds.&quot;,
      lingerOp.Enabled.ToString(),
      lingerOp.LingerTime.ToString());

    Console.WriteLine(
      &quot;Size of the receive buffer is now {0} bytes.&quot;,
      receiveBuffer.ToString());
  }
}
   </PRE>
The output is<P>

<CODE> Linger option is False and set to 0 seconds.<P>

 Size of the receive buffer is 8192 bytes.<P>

The SetSocketOption method has been called.<P>

 Linger option is now True and set to 10 seconds.<P>

 Size of the receive buffer is now 2048 bytes.<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method"><H3>Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Retrieves the value of the specified socket option.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>One of the values defined in the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration. </DD>
<DT>optionName</DT>
<DD>One of the values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
<DT> optionValue</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array that receives the value of the specified socket option.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>optionValue</I> is too small to store the value of the specified socket option.<P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Socket
      options determine the behavior of the current instance.<P>

Upon successful completion, the array specified by the <I>optionValue</I> parameter contains the value of the
   specified socket option.<P>

When the length of the <I>optionValue</I> array is smaller than the number of bytes required
to store the value of the specified socket option, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method"><H3>Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Retrieves the value of the
      specified socket option.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>One of the values defined in the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration. </DD>
<DT>optionName</DT>
<DD>One of the values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
<DT> optionLength</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the maximum length, in bytes, of the value of the specified socket option.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing the value of the specified socket option.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>optionLength</I> is smaller than the number of bytes required to store the value of the specified socket option.<P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 Socket options
      determine the behavior of the current instance.<P>

The <I>optionLength</I> parameter
   is used to allocate an array to store the value of the specified option. When this value is smaller than the number of bytes required to store
   the value of the specified option, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown. When this value is
   greater than or equal to the number of bytes required to store the value of the
   specified option, the array returned by this
   method is allocated to be exactly the required length.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.IOControl Method"><H3>Socket.IOControl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int IOControl(int ioControlCode, byte[] optionInValue, byte[] optionOutValue);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Provides low-level access to the socket, the
      transport protocol, or the communications subsystem.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>ioControlCode</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the control code of the operation to perform.</DD>
<DT> optionInValue</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing the input data required by the operation.</DD>
<DT> optionOutValue</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing the output data supplied by the operation.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the length of the
<I>optionOutValue</I> array after the method returns.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An attempt was made to change the blocking mode.<P>

[<I>Note</I>: Use the System.Net.Sockets.Socket.Blocking property to change the blocking mode.<P>

]<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If an attempt is made to change the blocking mode of the current instance, an
      exception is thrown. Use the System.Net.Sockets.Socket.Blocking property to change the
      blocking mode.<P>


      The control codes and their requirements
      are implementation defined. Do not use
      this method if platform
      independence is a requirement.
      
      <P>

[<I>Note</I>: 
      
      Input data is not required for all control codes. Output data is not supplied
      by all control codes and, if not supplied, the return value is 0.
      
      ]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example gets the number of bytes of available
      data to be read and writes the result to the console on a Windows system.
      The remote endpoint (remoteEndpoint) to connect to may need to be changed to a value that is valid on the current system.<P>

<PRE>using System;
using System.Net;
using System.Net.Sockets;

class App {

  static void Main() {

    IPAddress remoteAddress =
    Dns.Resolve(Dns.GetHostName()).AddressList[0];

    IPEndPoint remoteEndpoint =
      new IPEndPoint(remoteAddress, 80);

    Socket someSocket =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    someSocket.Connect(remoteEndpoint);

    int fionRead = 0x4004667F;
    byte[]inValue = {0x00, 0x00, 0x00, 0x00};
    byte[]outValue = {0x00, 0x00, 0x00, 0x00};

    someSocket.IOControl(fionRead, inValue, outValue);

    uint bytesAvail = BitConverter.ToUInt32(outValue, 0);
      
    Console.WriteLine(
      &quot;There are {0} bytes available to be read.&quot;,
      bytesAvail.ToString() );
  }
}
      </PRE>
The output is<P>

<CODE>There are 0 bytes available to be read.<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Listen Method"><H3>Socket.Listen Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void Listen(int backlog);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Places the current instance into the listening
      state where it waits for incoming connection requests.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>backlog</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the maximum length of the queue of pending connections.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>The System.Net.Sockets.Socket.Connected property of the current instance is true, or an error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 Once this method is called, incoming connection requests
      are placed in a queue. The maximum size of the queue is specified by the
      <I>backlog</I> parameter. The size of the queue is limited to legal
      values by the underlying protocol. Illegal values of the <I>backlog</I>
      parameter are replaced with a legal value, which is implementation defined.<P>

If a connection request arrives and the queue is full, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> is thrown on the client.<P>

 A socket in the listening state has no
   remote endpoint associated with it. Attempting to access the System.Net.Sockets.Socket.RemoteEndPoint property throws a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception.<P>

 This method is ignored if called more than once on the
   current instance.<P>

[<I>Note</I>: This method is used
      only on the server-side of connection-oriented protocols. Call the System.Net.Sockets.Socket.Bind(System.Net.EndPoint) method before
      this method is called the first time. Call the System.Net.Sockets.Socket.Listen(System.Int32) method before the first call to the System.Net.Sockets.Socket.Accept
      method.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Poll Method"><H3>Socket.Poll Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public bool Poll(int microSeconds, SelectMode mode);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines the read, write, or error status of the current instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>microSeconds</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the time to wait for a response, in microseconds. Set the <I>microSeconds</I> parameter to a negative value to wait indefinitely for a response.</DD>
<DT> mode</DT>
<DD>One of the values defined in the <A HREF="SelectMode.html" TARGET="contents">SelectMode</A> enumeration.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates the current instance
   satisfies at least one of the conditions in the following table
   corresponding to the specified <A HREF="SelectMode.html" TARGET="contents">SelectMode</A>
   value; otherwise, <CODE>false</CODE>
. <CODE>false</CODE>
 is returned if the status of the current instance cannot be determined within the time specified by <I>microSeconds</I> . <P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH> Condition</TH><TH>SelectMode value Condition</TH></TR>
<TR><TD> Data is available for reading (includes
            out-of-band data if the System.Net.Sockets.SocketOptionName.OutOfBandInline value defined in
            the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>
            enumeration
            is set).<P>

-or-<P>

The socket is in the listening state with a
            pending connection, and
            the System.Net.Sockets.Socket.Accept method has been called and is guaranteed to succeed without
            blocking.<P>

-or-<P>

 The connection has been closed, reset,
            or terminated.<P>

</TD><TD> SelectRead Data is available for reading (includes
            out-of-band data if the System.Net.Sockets.SocketOptionName.OutOfBandInline value defined in
            the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>
            enumeration
            is set).<P>

-or-<P>

The socket is in the listening state with a
            pending connection, and
            the System.Net.Sockets.Socket.Accept method has been called and is guaranteed to succeed without
            blocking.<P>

-or-<P>

 The connection has been closed, reset,
            or terminated.<P>

</TD></TR>
<TR><TD>Data can be sent.<P>

-or-<P>

 A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the connection has
            succeeded.<P>

</TD><TD> SelectWriteData can be sent.<P>

-or-<P>

 A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the connection has
            succeeded.<P>

</TD></TR>
<TR><TD>The System.Net.Sockets.SocketOptionName.OutOfBandInline value defined in
            the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is not set
            and out-of-band data is available.<P>

-or-<P>

 A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
      method is being processed and the connection has
      failed.<P>

</TD><TD> SelectErrorThe System.Net.Sockets.SocketOptionName.OutOfBandInline value defined in
            the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is not set
            and out-of-band data is available.<P>

-or-<P>

 A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint)
      method is being processed and the connection has
      failed.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/NotSupportedException.html" TARGET="contents">NotSupportedException</A></TD><TD><I>mode </I>is not one of the values defined in the <A HREF="SelectMode.html" TARGET="contents">SelectMode</A> enumeration.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Receive(byte[], int, System.Net.Sockets.SocketFlags) Method"><H3>Socket.Receive(byte[], int, System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Receive(byte[] buffer, int size, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>size</I> &lt; 0.<P>

 -or-<P>

<I>size</I> &gt; <I>buffer</I>.Length.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

 -or- <P>

 An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This method is equivalent to System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0, <I>size</I>,
<I>socketFlags</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Receive(byte[], System.Net.Sockets.SocketFlags) Method"><H3>Socket.Receive(byte[], System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Receive(byte[] buffer, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a
      socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD> A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0, <I>buffer</I>.Length,
<I>socketFlags</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Receive(byte[]) Method"><H3>Socket.Receive(byte[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Receive(byte[] buffer);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD> A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0, <I>buffer</I>.Length,
System.Net.Sockets.SocketFlags.None).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Receive(byte[], int, int, System.Net.Sockets.SocketFlags) Method"><H3>Socket.Receive(byte[], int, int, System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Receive(byte[] buffer, int offset, int size, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer </I>to begin storing the received data.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0.<P>

-or-<P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

-or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

The System.Net.Sockets.Socket.LocalEndPoint property was not set.<P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The System.Net.Sockets.Socket.LocalEndPoint property is required to be set before 
   this method
   is called.<P>

The System.Net.Sockets.Socket.Blocking property of the socket determines
the behavior of this method when no incoming data is available. When
<CODE>false</CODE>
, the <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown. When 
<CODE>true</CODE>
, this method blocks and 
waits for data
to arrive.<P>

 For System.Net.Sockets.SocketType.Stream socket types, if the remote socket
was shut down gracefully, and all data was received, this method immediately returns zero,
regardless of the blocking state.<P>

For message-oriented sockets, if the message is larger than the size of
<I>buffer</I>, the buffer is filled with the first part of the message, and the 
<A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown. For unreliable 
   protocols, the excess data is lost; for reliable protocols, the data is retained
   by the service provider.<P>

When the System.Net.Sockets.SocketFlags.OutOfBand flag is
specified as part of the <I>socketFlags</I> parameter and the socket is configured for in-line reception of
out-of-band (OOB) data (using the System.Net.Sockets.SocketOptionName.OutOfBandInline socket option) and OOB data is available,
only OOB data is returned.<P>

When the System.Net.Sockets.SocketFlags.Peek flag is specified as part of the
<I>socketFlags</I> parameter, available data is copied into 
<I>buffer</I> but is not removed from the system
buffer.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.ReceiveFrom(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method"><H3>Socket.ReceiveFrom(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int ReceiveFrom(byte[] buffer, int offset, int size, SocketFlags socketFlags, ref EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket and,
      for connectionless protocols, stores the endpoint associated with the socket that sent
      the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the zero-based position in <I>buffer </I>to begin storing the received data.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
<DT>remoteEP</DT>
<DD>A reference to the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket that sent the data.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer</I> or <I>remoteEP</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0.<P>

-or-<P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

-or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

The System.Net.Sockets.Socket.LocalEndPoint property was not set.<P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
For connectionless protocols, when this method successfully completes, <I>remoteEP</I> contains the
   endpoint associated with the socket that sent the data.<P>

For connection-oriented protocols, <I>remoteEP</I> is left unchanged.<P>

The System.Net.Sockets.Socket.LocalEndPoint property is required to be set before
this method is called or a <A HREF="SocketException.html" TARGET="contents">SocketException</A>
is thrown.<P>

The System.Net.Sockets.Socket.Blocking property of the socket determines
the behavior of this method when no incoming data is available. When
<CODE>false</CODE>
, the <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown. When 
<CODE>true</CODE>
, this method blocks and 
waits for data to arrive.<P>

For System.Net.Sockets.SocketType.Stream socket types, if the
remote socket was shut down gracefully, and all data was received, this method
immediately returns zero, regardless of the blocking state.<P>

For message-oriented sockets, if the message is larger than the size of
<I>buffer</I>, the buffer is filled with the first part of the message, and the 
<A HREF="SocketException.html" TARGET="contents">SocketException</A> 
exception is thrown. For unreliable protocols, the excess data is lost; for
reliable protocols, the data is retained by the service provider.<P>

When the System.Net.Sockets.SocketFlags.OutOfBand flag is specified as part of the<I>socketFlags </I>parameter and the socket is configured for
in-line reception of out-of-band (OOB) data (using the System.Net.Sockets.SocketOptionName.OutOfBandInline socket option) and OOB
data is available, only OOB data is returned.<P>

When the System.Net.Sockets.SocketFlags.Peek flag is specified as part of the
<I>socketFlags</I> parameter, available data is copied into 
<I>buffer</I> 
but is not removed from the system
buffer.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.ReceiveFrom(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method"><H3>Socket.ReceiveFrom(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int ReceiveFrom(byte[] buffer, int size, SocketFlags socketFlags, ref EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to receive.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
<DT>remoteEP</DT>
<DD>A reference to the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket that sent the data.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer</I> or <I>remoteEP</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>size</I> &lt; 0.<P>

 -or-<P>

<I>size</I> &gt; <I>buffer</I>.Length.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)(<I>buffer</I>, 0, <I>size</I> , <I>socketFlags</I>, <I>remoteEP</I> ).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.ReceiveFrom(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method"><H3>Socket.ReceiveFrom(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint&amp;) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int ReceiveFrom(byte[] buffer, SocketFlags socketFlags, ref EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.OutOfBand, or System.Net.Sockets.SocketFlags.Peek.</DD>
<DT>remoteEP</DT>
<DD>A reference to the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket that sent the data.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer</I> or <I>remoteEP</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> specified an invalid value.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)(<I>buffer</I>, 0, <I>buffer</I>.Length, <I>socketFlags</I>, <I>remoteEP</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.ReceiveFrom(byte[], System.Net.EndPoint&amp;) Method"><H3>Socket.ReceiveFrom(byte[], System.Net.EndPoint&amp;) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int ReceiveFrom(byte[] buffer, ref EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Receives data from a socket and, for connectionless protocols, stores the
      endpoint associated with the socket that sent the data.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array to store data received from the socket.</DD>
<DT>remoteEP</DT>
<DD>A reference to the <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket that sent the data.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes received.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer</I> or <I>remoteEP</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)(<I>buffer</I>, 0, <I>buffer</I>.Length,
System.Net.Sockets.SocketFlags.None, <I>remoteEP</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Select Method"><H3>Socket.Select Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines the read, write, or error status of a set
      of <A HREF="Socket.html" TARGET="contents">Socket</A> instances.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>checkRead</DT>
<DD>A <A HREF="../../../System/Collections/IList.html" TARGET="contents">IList</A> object containing the <A HREF="Socket.html" TARGET="contents">Socket</A> instances to check for read status.</DD>
<DT>checkWrite</DT>
<DD>A <A HREF="../../../System/Collections/IList.html" TARGET="contents">IList</A> object containing the <A HREF="Socket.html" TARGET="contents">Socket</A> instances to check for write status.</DD>
<DT>checkError</DT>
<DD>A <A HREF="../../../System/Collections/IList.html" TARGET="contents">IList</A> object containing the <A HREF="Socket.html" TARGET="contents">Socket</A> instances to check for error status.</DD>
<DT>microSeconds</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the time to wait for a response, in microseconds. Specify a negative value to wait indefinitely for the status to be determined.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD>All of the following parameters are <CODE>null</CODE>
 or empty: <I>checkRead</I>, <I>checkWrite</I>, and <I>checkError</I>.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing one of the sockets. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Upon successful completion, this method removes all
   <A HREF="Socket.html" TARGET="contents">Socket</A> instances from
      the specified list that do not
      satisfy one of the conditions associated
      with that list. The following table describes the conditions for each list.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Condition to remain in list</TH><TH>ListCondition to remain in list</TH></TR>
<TR><TD>Data is available for reading (includes
            out-of-band data if the System.Net.Sockets.SocketOptionName.OutOfBandInline
            value defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is set).<P>

-or-<P>

The socket is in the listening state with a pending connection, and the System.Net.Sockets.Socket.Accept method has been called
         and is guaranteed to succeed without blocking.<P>

-or-<P>

The connection has been closed, reset, or terminated.<P>

</TD><TD><I>checkRead</I>Data is available for reading (includes
            out-of-band data if the System.Net.Sockets.SocketOptionName.OutOfBandInline
            value defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is set).<P>

-or-<P>

The socket is in the listening state with a pending connection, and the System.Net.Sockets.Socket.Accept method has been called
         and is guaranteed to succeed without blocking.<P>

-or-<P>

The connection has been closed, reset, or terminated.<P>

</TD></TR>
<TR><TD>Data can be sent.<P>

-or-<P>

A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the
      connection has succeeded.<P>

</TD><TD><I>checkWrite</I>Data can be sent.<P>

-or-<P>

A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the
      connection has succeeded.<P>

</TD></TR>
<TR><TD>The System.Net.Sockets.SocketOptionName.OutOfBandInline
value defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is not set and
out-of-band data is available.<P>

-or-<P>

A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the
connection has failed.<P>

</TD><TD><I>checkError</I>The System.Net.Sockets.SocketOptionName.OutOfBandInline
value defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration is not set and
out-of-band data is available.<P>

-or-<P>

A non-blocking System.Net.Sockets.Socket.Connect(System.Net.EndPoint) method is being processed and the
connection has failed.<P>

</TD></TR>
</TABLE>
[<I>Note</I>: To determine the status of a specific
<A HREF="Socket.html" TARGET="contents">Socket</A> instance, check whether the instance 
   remains in the list after the method returns.]<P>

<P>

 When the method cannot determine the status of all the
<A HREF="Socket.html" TARGET="contents">Socket</A> instances within the time specified in the 
<I>microseconds</I> parameter, the 
   method removes all the <A HREF="Socket.html" TARGET="contents">Socket</A>
   instances from all the lists and returns.<P>

 At least one of <I>checkRead</I>, <I>checkWrite</I>, or
<I>checkError</I>, is required to contain at least one <A HREF="Socket.html" TARGET="contents">Socket</A> instance. The 
other parameters can be empty or <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example determines the status of the socket instance named
      socket3 and writes the result to the console.<P>

<PRE>using System;
using System.Collections;
using System.Net.Sockets;

class SelectTest {

  public static void Main() {

    Socket socket1 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);
    Socket socket2 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);
    Socket socket3 =
      new Socket(AddressFamily.InterNetwork,
                 SocketType.Stream,
                 ProtocolType.Tcp);

    ArrayList readList = new ArrayList();
    ArrayList writeList = new ArrayList();
    ArrayList errorList = new ArrayList();

    readList.Add(socket1);
    readList.Add(socket2);
    readList.Add(socket3);
    errorList.Add(socket1);
    errorList.Add(socket3);

    // readList.Contains(Socket3) returns true
    // if Socket3 is in ReadList.
    Console.WriteLine(
      &quot;socket3 is placed in readList and errorList.&quot;);
    Console.WriteLine(
      &quot;socket3 is {0}in readList.&quot;,
      readList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );
    Console.WriteLine(
      &quot;socket3 is {0}in writeList.&quot;,
      writeList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );
    Console.WriteLine(
      &quot;socket3 is {0}in errorList.&quot;,
      errorList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );

    Socket.Select(readList, writeList, errorList, 10);
    Console.WriteLine(&quot;The Select method has been called.&quot;);
    Console.WriteLine(
      &quot;socket3 is {0}in readList.&quot;,
      readList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );
    Console.WriteLine(
      &quot;socket3 is {0}in writeList.&quot;,
      writeList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );
    Console.WriteLine(
      &quot;socket3 is {0}in errorList.&quot;,
      errorList.Contains(socket3) ? &quot;&quot; : &quot;not &quot; );
  }
}
   </PRE>
The output is<P>

<CODE>socket3 is placed in readList and errorList.<P>

socket3 is in readList.<P>

socket3 is not in writeList.<P>

socket3 is in errorList.<P>

The Select method has been called.<P>

socket3 is not in readList.<P>

socket3 is not in writeList.<P>

socket3 is not in errorList.<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Send(byte[], int, System.Net.Sockets.SocketFlags) Method"><H3>Socket.Send(byte[], int, System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Send(byte[] buffer, int size, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Sends data to a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>size</I> &lt; 0.<P>

 -or-<P>

<I>size</I> &gt; <I>buffer</I>.Length.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values. <P>

-or-<P>

An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0, <I>size</I>,
<I>socketFlags</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Send(byte[], System.Net.Sockets.SocketFlags) Method"><H3>Socket.Send(byte[], System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Send(byte[] buffer, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Sends data to a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0, <I>buffer</I>.Length,
<I>socketFlags</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Send(byte[]) Method"><H3>Socket.Send(byte[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Send(byte[] buffer);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sends data to a
      connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket.<P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)(<I>buffer</I>, 0,
<I>buffer</I>.Length, System.Net.Sockets.SocketFlags.None).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Send(byte[], int, int, System.Net.Sockets.SocketFlags) Method"><H3>Socket.Send(byte[], int, int, System.Net.Sockets.SocketFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Send(byte[] buffer, int offset, int size, SocketFlags socketFlags);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Sends data to a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the zero-based position in buffer that is the starting location of the data to send.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer </I>is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or- <P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
For connection-oriented protocols, the System.Net.Sockets.Socket.LocalEndPoint property of the current instance is
   required to be set before calling this
   method.<P>

For connectionless protocols, calling the System.Net.Sockets.Socket.Connect(System.Net.EndPoint) methods sets the System.Net.Sockets.Socket.RemoteEndPoint property and allows the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)
method to be used instead of the System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)
method.<P>

When the System.Net.Sockets.SocketFlags.DontRoute flag
is specified as part of the <I>socketFlags</I> parameter,
the sent data is not routed.<P>

When the System.Net.Sockets.SocketFlags.OutOfBand flag is specified as part of the
<I>socketFlags</I> parameter, only out-of-band (OOB) data is sent.<P>

When the System.Net.Sockets.Socket.Blocking property of the current instance is
set to <CODE>true</CODE>
 and
buffer space is not available within the underlying protocol, this method
blocks. <P>

For message-oriented sockets, when the size of
<I>buffer</I> is greater than the maximum message size of the underlying
   protocol, no data is sent and the <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SendTo(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method"><H3>Socket.SendTo(byte[], int, int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int SendTo(byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sends data to the socket associated with the specified
      endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>offset</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the zero-based position in buffer that is the starting location of the data to send.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to receive the data.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer or remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>offset</I> &lt; 0. <P>

-or- <P>

<I>offset</I> &gt; <I>buffer</I>.Length. <P>

 -or-<P>

<I>size</I> &lt; 0.<P>

-or-<P>

<I>size</I> &gt; <I>buffer</I>.Length - <I>offset</I>.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD> A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
For connection-oriented protocols and connected sockets using connectionless
      protocols, <I>remoteEP</I> overrides the endpoint specified in the System.Net.Sockets.Socket.RemoteEndPoint property.<P>

For unconnected sockets using connectionless protocols, this method sets
      the System.Net.Sockets.Socket.LocalEndPoint
      property of the current instance to a value determined by the protocol.
      Subsequent data is required to be received on <CODE>LocalEndPoint</CODE>
.<P>

When the System.Net.Sockets.SocketFlags.DontRoute flag
   is specified as part of the <I>socketFlags</I> parameter,
   the sent data is not routed.<P>

When the System.Net.Sockets.SocketFlags.OutOfBand flag is specified as part of the
<I>socketFlags</I> parameter, only out-of-band (OOB) data is sent.<P>

When the System.Net.Sockets.Socket.Blocking property of the current instance is
set to <CODE>true</CODE>
 and
buffer space is not available within the underlying protocol, this method
blocks. <P>

For message-oriented sockets, when the size of <I>buffer</I> is greater than
the maximum message size of the underlying protocol, no data is sent and the
<A HREF="SocketException.html" TARGET="contents">SocketException</A> exception is thrown.<P>

For connection-oriented sockets, the <I>remoteEP</I> property is
ignored.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SendTo(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method"><H3>Socket.SendTo(byte[], int, System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int SendTo(byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sends data to the socket associated with the specified
      endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>size</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes to send.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to receive the data.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer or remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentOutOfRangeException.html" TARGET="contents">ArgumentOutOfRangeException</A></TD><TD><I>size</I> &lt; 0.<P>

 -or-<P>

<I>size</I> &gt; <I>buffer</I>.Length.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)(<I>buffer</I>, 0, <I>size</I>,
<I>socketFlags</I>, <I>remoteEP</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SendTo(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method"><H3>Socket.SendTo(byte[], System.Net.Sockets.SocketFlags, System.Net.EndPoint) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int SendTo(byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sends data to the socket associated with the specified
      endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>socketFlags</DT>
<DD>A bitwise combination of any of the following values defined in the <A HREF="SocketFlags.html" TARGET="contents">SocketFlags</A> enumeration: System.Net.Sockets.SocketFlags.None, System.Net.Sockets.SocketFlags.DontRoute, or System.Net.Sockets.SocketFlags.OutOfBand.</DD>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to receive the data.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer or remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD><I>socketFlags</I> is not a valid combination of values.<P>

-or-<P>

An error occurred while accessing the socket. <P>

[<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)(<I>buffer</I>, 0, <I>buffer</I>.Length,
<I>socketFlags</I>, <I>remoteEP</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SendTo(byte[], System.Net.EndPoint) Method"><H3>Socket.SendTo(byte[], System.Net.EndPoint) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int SendTo(byte[] buffer, EndPoint remoteEP);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sends data to the socket associated with the specified
      endpoint.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>buffer</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing data to send to the socket.</DD>
<DT>remoteEP</DT>
<DD>The <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A> associated with the socket to receive the data.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>
containing the number of bytes sent.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>buffer or remoteEP </I>is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="../../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>An asynchronous call is pending and a blocking method has been called.<P>

</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)(<I>buffer</I>,
   0, <I>buffer</I>.Length, System.Net.Sockets.SocketFlags.None,<I> remoteEP</I>).<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method"><H3>Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, int) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sets socket options with values of type <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> and <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>One of the values defined in the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration. </DD>
<DT>optionName</DT>
<DD>One of the values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
<DT>optionValue</DT>
<DD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the value of the option.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Socket options determine the behavior of the current
      instance. Multiple options can be set on the current instance by calling
      this method multiple times.<P>

 For a socket option with a <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
data type, specify a non-zero
<I>optionValue</I> to enable the option, and an <I>optionValue</I> equal to zero
to disable the option.<P>

Socket options are grouped by level of protocol support.
   The following tables list the members of
   the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration
   supported by each member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration.
   Only members that have associated values of the <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> and <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
   data types are listed.<P>


The following table lists the
members of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration supported by
the <CODE>Socket</CODE>
 member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration.
Options that do not require permission to access unmanaged code are noted.
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Description</TH><TH>SocketOptionNameDescription</TH></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates broadcast messages are allowed to be sent to the socket. </TD><TD> BroadcastA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates broadcast messages are allowed to be sent to the socket. </TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
   where <CODE>true</CODE>
 indicates to record debugging information.</TD><TD> DebugA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
   where <CODE>true</CODE>
 indicates to record debugging information.</TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates to close the socket without
lingering. This option does not require permission to access unmanaged code.</TD><TD> DontLingerA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates to close the socket without
lingering. This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates not to route data.</TD><TD> DontRouteA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates not to route data.</TD></TR>
<TR><TD>A
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      contains the error code associated with the last socket error. The error
      code is cleared by this option. This option is read-only.</TD><TD> ErrorA
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      contains the error code associated with the last socket error. The error
      code is cleared by this option. This option is read-only.</TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 (the default) indicates to enable
keep-alives, which allows a connection to remain open after a request has completed. This option does not require permission to access unmanaged code.</TD><TD> KeepAliveA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 (the default) indicates to enable
keep-alives, which allows a connection to remain open after a request has completed. This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates to receive out-of-band data in the normal data stream.</TD><TD> OutOfBandInlineA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 indicates to receive out-of-band data in the normal data stream.</TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   total per-socket buffer space reserved for receives.
   This option does not require permission to access unmanaged code.</TD><TD> ReceiveBufferA <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   total per-socket buffer space reserved for receives.
   This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>A
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      specifies the maximum time, in milliseconds, the System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@) methods will block when attempting to
      receive data. If data is not received within this
      time, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception
      is thrown. This option does not require permission to access unmanaged code.</TD><TD> ReceiveTimeoutA
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      specifies the maximum time, in milliseconds, the System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@) methods will block when attempting to
      receive data. If data is not received within this
      time, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception
      is thrown. This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>A <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 allows the socket to be bound to an address that is already in use.</TD><TD> ReuseAddressA <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>
where <CODE>true</CODE>
 allows the socket to be bound to an address that is already in use.</TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   total per-socket buffer space reserved for sends. This option does not require permission to access unmanaged code.</TD><TD> SendBufferA <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   total per-socket buffer space reserved for sends. This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>A
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      specifies the maximum time, in milliseconds, the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint) methods will block when attempting to
      send data. If data is not sent within this time, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception
      is thrown. This option does not require permission to access unmanaged code.</TD><TD> SendTimeoutA
   <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that
      specifies the maximum time, in milliseconds, the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) and System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint) methods will block when attempting to
      send data. If data is not sent within this time, a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception
      is thrown. This option does not require permission to access unmanaged code.</TD></TR>
<TR><TD>One of the values defined in the <A HREF="SocketType.html" TARGET="contents">SocketType</A> enumeration. This option is
      read-only.<P>

</TD><TD> TypeOne of the values defined in the <A HREF="SocketType.html" TARGET="contents">SocketType</A> enumeration. This option is
      read-only.<P>

</TD></TR>
</TABLE>
The following table lists the members of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>
enumeration supported by the <CODE>IP</CODE>
 member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>
enumeration. These options require permission to access unmanaged
code.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Description</TH><TH>SocketOptionNameDescription</TH></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates
         the application is providing the IP header for outgoing
         datagrams. </TD><TD> HeaderIncludedA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates
         the application is providing the IP header for outgoing
         datagrams. </TD></TR>
<TR><TD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array
      that specifies IP options to be inserted into outgoing
      datagrams.</TD><TD> IPOptionsA <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array
      that specifies IP options to be inserted into outgoing
      datagrams.</TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   time-to-live for datagrams. The time-to-live designates the number of
   networks on which the datagram is allowed to travel
   before being discarded by a
   router.</TD><TD> IpTimeToLiveA <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   time-to-live for datagrams. The time-to-live designates the number of
   networks on which the datagram is allowed to travel
   before being discarded by a
   router.</TD></TR>
<TR><TD>A
   <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A>
   array that specifies the interface for outgoing multicast
   packets.</TD><TD> MulticastInterfaceA
   <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A>
   array that specifies the interface for outgoing multicast
   packets.</TD></TR>
<TR><TD>A
   <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 enables multicast
      loopback. </TD><TD> MulticastLoopbackA
   <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 enables multicast
      loopback. </TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   time-to-live for multicast datagrams. </TD><TD> MulticastTimeToLiveA <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   time-to-live for multicast datagrams. </TD></TR>
<TR><TD>A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   type of service field in the IP header. </TD><TD> TypeOfServiceA <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> that specifies the
   type of service field in the IP header. </TD></TR>
<TR><TD>A
   <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to send a copy of the
      data back to the
      sender. </TD><TD> UseLoopbackA
   <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to send a copy of the
      data back to the
      sender. </TD></TR>
</TABLE>
<P>

The following table lists the members of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>
enumeration supported by the <CODE>Tcp</CODE>
 member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration.
These options do not require permission to access unmanaged code.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Description</TH><TH>SocketOptionNameDescription</TH></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to use urgent data
         as defined by IETF RFC 1222. Once enabled, this option cannot be disabled.</TD><TD> BsdUrgentA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to use urgent data
         as defined by IETF RFC 1222. Once enabled, this option cannot be disabled.</TD></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to use expedited data as defined by IETF RFC
         1222. Once enabled, this option cannot be disabled.</TD><TD> ExpeditedA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to use expedited data as defined by IETF RFC
         1222. Once enabled, this option cannot be disabled.</TD></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to disable the Nagle algorithm for send
         coalescing.</TD><TD> NoDelayA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to disable the Nagle algorithm for send
         coalescing.</TD></TR>
</TABLE>
<P>

The following table lists the members of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>
enumeration supported by the <CODE>Udp</CODE>
 member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration.
These options do not require permission to access unmanaged code.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Description</TH><TH>SocketOptionNameDescription</TH></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> that specifies UDP checksum coverage.</TD><TD> ChecksumCoverageA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> that specifies UDP checksum coverage.</TD></TR>
<TR><TD>A
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to send UDP datagrams with the checksum set to zero.</TD><TD> NoChecksumA
      <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> where <CODE>true</CODE>
 indicates to send UDP datagrams with the checksum set to zero.</TD></TR>
</TABLE>
<P>

[<I>Note</I>: For the
   <CODE>AddMembership</CODE>
, <CODE>DropMembership</CODE>
, and
   <CODE>Linger</CODE>
 members of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration, see
      the System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)(<A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>, <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>, <A HREF="../../../System/Object.html" TARGET="contents">Object</A>) version of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method"><H3>Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, byte[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, byte[] optionValue);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Sets socket options with values of type <CODE>Byte[]</CODE>
.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>One of the values defined in the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration. </DD>
<DT>optionName</DT>
<DD>One of the values defined in the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
<DT>optionValue</DT>
<DD>A <A HREF="../../../System/Byte.html" TARGET="contents">Byte</A> array containing the value of the option.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Socket options determine the behavior of the current
      instance. Multiple options can be set on the current instance by calling this method
      multiple times.<P>

[<I>Note</I>: For socket options
      with values of type <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> or <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>,
      see the System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)(<A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>, <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> , <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>) version of this method.]<P>

<P>

[<I>Note</I>: For the System.Net.Sockets.SocketOptionName.AddMembership, System.Net.Sockets.SocketOptionName.DropMembership, or System.Net.Sockets.SocketOptionName.Linger socket options, see the
System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)(<A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>, <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>, <A HREF="../../../System/Object.html" TARGET="contents">Object</A>) version of this 
   method.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object) Method"><H3>Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel, System.Net.Sockets.SocketOptionName, System.Object) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Sets the System.Net.Sockets.SocketOptionName.AddMembership, System.Net.Sockets.SocketOptionName.DropMembership, or
System.Net.Sockets.SocketOptionName.Linger socket options.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>optionLevel</DT>
<DD>Either the <CODE>Socket</CODE>
 or <CODE>IP</CODE>
 member of the <A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A> enumeration.</DD>
<DT>optionName</DT>
<DD>Either the <CODE>Linger</CODE>
, <CODE>AddMembership</CODE>
, or <CODE>DropMembership</CODE>
 member of the <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A> enumeration.</DD>
<DT>optionValue</DT>
<DD>An instance of the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A> or <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A> class.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>optionLevel</I>, <I>optionName</I>, or <I>optionValue</I> specified an invalid value.</TD></TR>
<TR><TD><A HREF="../../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>optionValue</I> is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>A caller in the call stack does not have the required permissions.</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Socket options determine the behavior of the current
      instance. Multiple options can be set on the current instance by calling this method multiple times.<P>

The following table summarizes the valid combinations of input parameters.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>optionValue</TH><TH>optionLevel/optionNameoptionValue</TH></TR>
<TR><TD>An instance of the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A> class.</TD><TD><CODE>Socket</CODE>
/<CODE>Linger</CODE>
An instance of the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A> class.</TD></TR>
<TR><TD>An instance of the <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A> class.</TD><TD><CODE>IP</CODE>
/<CODE>AddMembership</CODE>
<P>

- or -<P>

<CODE>IP</CODE>
/<CODE>DropMembership</CODE>
<P>

An instance of the <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A> class.</TD></TR>
</TABLE>
 When setting the System.Net.Sockets.SocketOptionName.Linger option, a <A HREF="../../../System/ArgumentException.html" TARGET="contents">ArgumentException</A>
exception is thrown if the System.Net.Sockets.LingerOption.LingerTime property of
the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A> instance is less than zero or greater
than System.UInt16.MaxValue
. <P>

[<I>Note</I>:  For more information on the System.Net.Sockets.SocketOptionName.Linger option,
   see the <A HREF="LingerOption.html" TARGET="contents">LingerOption</A> class and the System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
   method. <P>

 For more information on the System.Net.Sockets.SocketOptionName.AddMembership and System.Net.Sockets.SocketOptionName.DropMembership options, see the <A HREF="MulticastOption.html" TARGET="contents">MulticastOption</A> class. <P>

For socket options
   with values of type <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> or <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A>, see the System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)(<A HREF="SocketOptionLevel.html" TARGET="contents">SocketOptionLevel</A>, <A HREF="SocketOptionName.html" TARGET="contents">SocketOptionName</A>, <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A>) version
   of this method.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Shutdown Method"><H3>Socket.Shutdown Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public void Shutdown(SocketShutdown how);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Terminates the ability to send or receive data on a connected socket.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>how</DT>
<DD>One of the values defined in the <A HREF="SocketShutdown.html" TARGET="contents">SocketShutdown</A> enumeration.</DD>
</DL>
</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
When <I>how</I> is set to System.Net.Sockets.SocketShutdown.Send , the socket on the
   other end of the connection is notified that the current instance will not
   send any
   more data. If the System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method is
   subsequently called, a <A HREF="SocketException.html" TARGET="contents">SocketException</A>
   
   exception is thrown.<P>

When <I>how</I> is set to System.Net.Sockets.SocketShutdown.Receive,
the
socket on the other end of the
connection is notified that the current instance will not receive any more
data. After all the data currently queued on the current instance is
received, any subsequent calls to the System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) method cause a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception to be thrown.<P>

Setting <I>how</I> to System.Net.Sockets.SocketShutdown.Both terminates both sends and
receives as described above. Once this occurs, the socket cannot
be used.<P>

[<I>Note</I>: To free resources allocated by the current instance, call the System.Net.Sockets.Socket.Close
method.<P>

Expected common usage is for the System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)
method to be called before the System.Net.Sockets.Socket.Close method to
ensure that all pending data is sent or received.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.System.IDisposable.Dispose Method"><H3>Socket.System.IDisposable.Dispose Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>void IDisposable.Dispose();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Implemented to support the <A HREF="../../../System/IDisposable.html" TARGET="contents">IDisposable</A> interface. [Note: For more information, see System.IDisposable.Dispose.]
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.AddressFamily Property"><H3>Socket.AddressFamily Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public AddressFamily AddressFamily { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the address family of the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
One of the values defined in
      the <A HREF="AddressFamily.html" TARGET="contents">AddressFamily</A> enumeration.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property is set by the constructor for the current instance. The value of this property specifies the addressing scheme used by the current instance to resolve an address.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Available Property"><H3>Socket.Available Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public int Available { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the amount
      of data available to be read in a single System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags) or System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)
      call.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../../System/Int32.html" TARGET="contents">Int32</A> containing the number of bytes of data that are
   available to be read.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

When the current instance is stream-oriented (for example, the System.Net.Sockets.SocketType.Stream socket type), the available data
   is generally the total amount of data queued on the current instance.<P>

When the current instance is message-oriented (for example, the System.Net.Sockets.SocketType.Dgram socket type), the available data
is the first message in the input queue.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Blocking Property"><H3>Socket.Blocking Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public bool Blocking { get; set; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets or sets a <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the socket is in blocking mode.
   <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 indicates that
   the current instance is in blocking mode;
<CODE>false</CODE>
 indicates that the current instance is in 
   non-blocking mode. <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 Blocking is when a method waits to complete an operation before returning. Sockets are created in blocking mode
      by default. <P>

 Except for when the current instance has been disposed, no notification is given when an attempt to change
      the value of this property fails.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Connected Property"><H3>Socket.Connected Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public bool Connected { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="../../../System/Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current instance is connected.
   <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 indicates that 
   the current instance was connected at
   the time of the
   last I/O operation;
<CODE>false</CODE>
 indicates that the 
   current instance is not connected.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.
      <P>

When this property returns <CODE>true</CODE>
, the current instance was
   connected at the time of the last I/O operation; it might not still be connected.
   When this property returns <CODE>false</CODE>
, the current instance was
   never connected or is not currently connected.<P>

The current instance is considered connected when
   the System.Net.Sockets.Socket.RemoteEndPoint
   property contains a valid endpoint.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.Accept and System.Net.Sockets.Socket.Connect(System.Net.EndPoint) methods,
and their asynchronous counterparts set this
property.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.Handle Property"><H3>Socket.Handle Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public IntPtr Handle { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the operating system handle for the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../../../System/IntPtr.html" TARGET="contents">IntPtr</A> containing the operating system handle for the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.LocalEndPoint Property"><H3>Socket.LocalEndPoint Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public EndPoint LocalEndPoint { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the local endpoint associated with the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
 The local <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A>
associated with the current
instance.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only. <P>

This property contains the network connection information for the
      current instance. <P>

[<I>Note</I>: The System.Net.Sockets.Socket.Bind(System.Net.EndPoint) and
System.Net.Sockets.Socket.Accept methods, 
   and their
   asynchronous counterparts set this property. If not previously set,
   the System.Net.Sockets.Socket.Connect(System.Net.EndPoint) and System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint) methods, and their asynchronous counterparts set this property.
]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.ProtocolType Property"><H3>Socket.ProtocolType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public ProtocolType ProtocolType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the protocol type of the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
One of the values defined in
      the <A HREF="ProtocolType.html" TARGET="contents">ProtocolType</A> enumeration. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property is set by the constructor for the current instance. The value of
      this property specifies the protocol used by the current instance.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.RemoteEndPoint Property"><H3>Socket.RemoteEndPoint Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public EndPoint RemoteEndPoint { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the remote endpoint associated with the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
 The remote <A HREF="../../../System/Net/EndPoint.html" TARGET="contents">EndPoint</A>
associated with the current instance.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="SocketException.html" TARGET="contents">SocketException</A></TD><TD>An error occurred while accessing the socket. [<I>Note</I>: For additional information on causes of the <CODE> SocketException</CODE>
, see the <A HREF="SocketException.html" TARGET="contents">SocketException</A> class.]<P>

<P>

</TD></TR>
<TR><TD><A HREF="../../../System/ObjectDisposedException.html" TARGET="contents">ObjectDisposedException</A></TD><TD>The current instance has been disposed.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property
      is read-only.<P>

 This property contains the network
      connection information associated with the socket communicating with the current
      instance.<P>

 There is no remote endpoint
      associated with a socket in the listening state. An attempt to access the
   System.Net.Sockets.Socket.RemoteEndPoint 
   property causes a <A HREF="SocketException.html" TARGET="contents">SocketException</A> exception to be
   thrown.<P>

[<I>Note</I>: The System.Net.Sockets.Socket.Accept and System.Net.Sockets.Socket.Connect(System.Net.EndPoint) methods, and their asynchronous 
counterparts set this property. ]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="Socket.SocketType Property"><H3>Socket.SocketType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public SocketType SocketType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the socket type of the current instance.
      <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
One of the values defined in
      the <A HREF="SocketType.html" TARGET="contents">SocketType</A> enumeration.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property is set by the constructor for the current instance.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Socket.html" TARGET="contents">System.Net.Sockets.Socket Class</A>, <A HREF="Sockets.html" TARGET="members">System.Net.Sockets Namespace</A>
</BLOCKQUOTE>

</A></BODY>
</HTML>
