<HTML>
<HEAD>
<TITLE>System.Type Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Type Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract class Type : Object</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> (excluded)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Type<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
BCL
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Provides information about a type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 The <A HREF="Type.html" TARGET="contents">Type</A> class is abstract, as is the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A>
class and its subclasses <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A>, <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A>, <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>,
and <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A>. <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> and <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A>
are subclasses of <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>. The runtime
provides non-public implementations of these classes. [<I>Note</I>:  For example, System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is typed
as returning a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object. The
returned object is actually an instance of the non-public runtime type that
implements <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> .]<P>

<P>

A conforming CLI program which is written to run on only the Kernel profile 
   cannot subclass <A HREF="Type.html" TARGET="contents">Type</A>. [<I>Note</I>:  This only applies
   to conforming programs not conforming implementations.]<P>

<P>

 A <A HREF="Type.html" TARGET="contents">Type</A> object that represents a type is unique; that is, two
<A HREF="Type.html" TARGET="contents">Type</A> object 
references refer to the same object if and only if they represent the same type.
This allows for comparison of <A HREF="Type.html" TARGET="contents">Type</A>
objects using reference
equality.<P>

[<I>Note</I>:  An instance of <A HREF="Type.html" TARGET="contents">Type</A>
can represent any one of the following
types:<P>

<UL>
<LI>
      
      Classes</LI>
<LI>
      
      Value types</LI>
<LI>
      
      Arrays</LI>
<LI>
      
      Interfaces</LI>
<LI>
      
      Pointers</LI>
<LI>
      
      Enumerations</LI>
</UL>
The following table shows what members of a base class are returned by the
   methods that return members of types, such as System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) and
System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]).<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Member Type</TH><TH>Static</TH></TR>
<TR><TD> Constructor</TD><TD>No</TD></TR>
<TR><TD> Field</TD><TD>No</TD></TR>
<TR><TD> Event</TD><TD>Not applicable</TD></TR>
<TR><TD> Method</TD><TD>No</TD></TR>
<TR><TD> Nested Type</TD><TD>No</TD></TR>
<TR><TD> Property</TD><TD>Not applicable</TD></TR>
</TABLE>
<P>

For reflection, properties and events are hide-by-name-and-signature. If a
   property has both a get and a set accessor in the base class, but the derived
   class has only a get accessor, the derived class property hides the base class
   property, and the setter on the base class will not be accessible. <P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

Type Constructors<P>

<A HREF="#Type%20Constructor" TARGET="contents">Type Constructor</A><BR>
<P>

Type Methods<P>

<A HREF="#Type.Equals%20Method" TARGET="contents">Type.Equals Method</A><BR>
<A HREF="#Type.GetArrayRank%20Method" TARGET="contents">Type.GetArrayRank Method</A><BR>
<A HREF="#Type.GetAttributeFlagsImpl%20Method" TARGET="contents">Type.GetAttributeFlagsImpl Method</A><BR>
<A HREF="#Type.GetConstructor%28System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetConstructor%28System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetConstructor(System.Type[]) Method</A><BR>
<A HREF="#Type.GetConstructors%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetConstructors(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetConstructors%28%29%20Method" TARGET="contents">Type.GetConstructors() Method</A><BR>
<A HREF="#Type.GetDefaultMembers%20Method" TARGET="contents">Type.GetDefaultMembers Method</A><BR>
<A HREF="#Type.GetElementType%20Method" TARGET="contents">Type.GetElementType Method</A><BR>
<A HREF="#Type.GetEvent%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetEvent(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetEvent%28System.String%29%20Method" TARGET="contents">Type.GetEvent(System.String) Method</A><BR>
<A HREF="#Type.GetEvents%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetEvents(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetEvents%28%29%20Method" TARGET="contents">Type.GetEvents() Method</A><BR>
<A HREF="#Type.GetField%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetField(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetField%28System.String%29%20Method" TARGET="contents">Type.GetField(System.String) Method</A><BR>
<A HREF="#Type.GetFields%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetFields(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetFields%28%29%20Method" TARGET="contents">Type.GetFields() Method</A><BR>
<A HREF="#Type.GetHashCode%20Method" TARGET="contents">Type.GetHashCode Method</A><BR>
<A HREF="#Type.GetInterface%28System.String%2C%20bool%29%20Method" TARGET="contents">Type.GetInterface(System.String, bool) Method</A><BR>
<A HREF="#Type.GetInterface%28System.String%29%20Method" TARGET="contents">Type.GetInterface(System.String) Method</A><BR>
<A HREF="#Type.GetInterfaces%20Method" TARGET="contents">Type.GetInterfaces Method</A><BR>
<A HREF="#Type.GetMember%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMember(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMember%28System.String%29%20Method" TARGET="contents">Type.GetMember(System.String) Method</A><BR>
<A HREF="#Type.GetMembers%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMembers(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMembers%28%29%20Method" TARGET="contents">Type.GetMembers() Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Type[]) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%29%20Method" TARGET="contents">Type.GetMethod(System.String) Method</A><BR>
<A HREF="#Type.GetMethods%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMethods(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMethods%28%29%20Method" TARGET="contents">Type.GetMethods() Method</A><BR>
<A HREF="#Type.GetNestedType%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetNestedType(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetNestedType%28System.String%29%20Method" TARGET="contents">Type.GetNestedType(System.String) Method</A><BR>
<A HREF="#Type.GetNestedTypes%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetNestedTypes(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetNestedTypes%28%29%20Method" TARGET="contents">Type.GetNestedTypes() Method</A><BR>
<A HREF="#Type.GetProperties%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetProperties(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetProperties%28%29%20Method" TARGET="contents">Type.GetProperties() Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type, System.Type[]) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type[]) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%29%20Method" TARGET="contents">Type.GetProperty(System.String) Method</A><BR>
<A HREF="#Type.GetPropertyImpl%20Method" TARGET="contents">Type.GetPropertyImpl Method</A><BR>
<A HREF="#Type.GetType%28System.String%2C%20bool%2C%20bool%29%20Method" TARGET="contents">Type.GetType(System.String, bool, bool) Method</A><BR>
<A HREF="#Type.GetType%28System.String%2C%20bool%29%20Method" TARGET="contents">Type.GetType(System.String, bool) Method</A><BR>
<A HREF="#Type.GetType%28System.String%29%20Method" TARGET="contents">Type.GetType(System.String) Method</A><BR>
<A HREF="#Type.GetTypeArray%20Method" TARGET="contents">Type.GetTypeArray Method</A><BR>
<A HREF="#Type.GetTypeFromHandle%20Method" TARGET="contents">Type.GetTypeFromHandle Method</A><BR>
<A HREF="#Type.GetTypeHandle%20Method" TARGET="contents">Type.GetTypeHandle Method</A><BR>
<A HREF="#Type.HasElementTypeImpl%20Method" TARGET="contents">Type.HasElementTypeImpl Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%2C%20System.Globalization.CultureInfo%2C%20System.String%5B%5D%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[]) Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) Method</A><BR>
<A HREF="#Type.IsArrayImpl%20Method" TARGET="contents">Type.IsArrayImpl Method</A><BR>
<A HREF="#Type.IsAssignableFrom%20Method" TARGET="contents">Type.IsAssignableFrom Method</A><BR>
<A HREF="#Type.IsByRefImpl%20Method" TARGET="contents">Type.IsByRefImpl Method</A><BR>
<A HREF="#Type.IsCOMObjectImpl%20Method" TARGET="contents">Type.IsCOMObjectImpl Method</A><BR>
<A HREF="#Type.IsInstanceOfType%20Method" TARGET="contents">Type.IsInstanceOfType Method</A><BR>
<A HREF="#Type.IsPointerImpl%20Method" TARGET="contents">Type.IsPointerImpl Method</A><BR>
<A HREF="#Type.IsPrimitiveImpl%20Method" TARGET="contents">Type.IsPrimitiveImpl Method</A><BR>
<A HREF="#Type.IsSubclassOf%20Method" TARGET="contents">Type.IsSubclassOf Method</A><BR>
<A HREF="#Type.ToString%20Method" TARGET="contents">Type.ToString Method</A><BR>
<P>

Type Fields<P>

<A HREF="#Type.Delimiter%20Field" TARGET="contents">Type.Delimiter Field</A><BR>
<A HREF="#Type.EmptyTypes%20Field" TARGET="contents">Type.EmptyTypes Field</A><BR>
<A HREF="#Type.Missing%20Field" TARGET="contents">Type.Missing Field</A><BR>
<P>

Type Properties<P>

<A HREF="#Type.Assembly%20Property" TARGET="contents">Type.Assembly Property</A><BR>
<A HREF="#Type.AssemblyQualifiedName%20Property" TARGET="contents">Type.AssemblyQualifiedName Property</A><BR>
<A HREF="#Type.Attributes%20Property" TARGET="contents">Type.Attributes Property</A><BR>
<A HREF="#Type.BaseType%20Property" TARGET="contents">Type.BaseType Property</A><BR>
<A HREF="#Type.DeclaringType%20Property" TARGET="contents">Type.DeclaringType Property</A><BR>
<A HREF="#Type.DefaultBinder%20Property" TARGET="contents">Type.DefaultBinder Property</A><BR>
<A HREF="#Type.FullName%20Property" TARGET="contents">Type.FullName Property</A><BR>
<A HREF="#Type.HasElementType%20Property" TARGET="contents">Type.HasElementType Property</A><BR>
<A HREF="#Type.IsAbstract%20Property" TARGET="contents">Type.IsAbstract Property</A><BR>
<A HREF="#Type.IsArray%20Property" TARGET="contents">Type.IsArray Property</A><BR>
<A HREF="#Type.IsAutoLayout%20Property" TARGET="contents">Type.IsAutoLayout Property</A><BR>
<A HREF="#Type.IsByRef%20Property" TARGET="contents">Type.IsByRef Property</A><BR>
<A HREF="#Type.IsClass%20Property" TARGET="contents">Type.IsClass Property</A><BR>
<A HREF="#Type.IsEnum%20Property" TARGET="contents">Type.IsEnum Property</A><BR>
<A HREF="#Type.IsExplicitLayout%20Property" TARGET="contents">Type.IsExplicitLayout Property</A><BR>
<A HREF="#Type.IsImport%20Property" TARGET="contents">Type.IsImport Property</A><BR>
<A HREF="#Type.IsInterface%20Property" TARGET="contents">Type.IsInterface Property</A><BR>
<A HREF="#Type.IsLayoutSequential%20Property" TARGET="contents">Type.IsLayoutSequential Property</A><BR>
<A HREF="#Type.IsMarshalByRef%20Property" TARGET="contents">Type.IsMarshalByRef Property</A><BR>
<A HREF="#Type.IsNestedAssembly%20Property" TARGET="contents">Type.IsNestedAssembly Property</A><BR>
<A HREF="#Type.IsNestedFamANDAssem%20Property" TARGET="contents">Type.IsNestedFamANDAssem Property</A><BR>
<A HREF="#Type.IsNestedFamORAssem%20Property" TARGET="contents">Type.IsNestedFamORAssem Property</A><BR>
<A HREF="#Type.IsNestedFamily%20Property" TARGET="contents">Type.IsNestedFamily Property</A><BR>
<A HREF="#Type.IsNestedPrivate%20Property" TARGET="contents">Type.IsNestedPrivate Property</A><BR>
<A HREF="#Type.IsNestedPublic%20Property" TARGET="contents">Type.IsNestedPublic Property</A><BR>
<A HREF="#Type.IsNotPublic%20Property" TARGET="contents">Type.IsNotPublic Property</A><BR>
<A HREF="#Type.IsPointer%20Property" TARGET="contents">Type.IsPointer Property</A><BR>
<A HREF="#Type.IsPrimitive%20Property" TARGET="contents">Type.IsPrimitive Property</A><BR>
<A HREF="#Type.IsPublic%20Property" TARGET="contents">Type.IsPublic Property</A><BR>
<A HREF="#Type.IsSealed%20Property" TARGET="contents">Type.IsSealed Property</A><BR>
<A HREF="#Type.IsSpecialName%20Property" TARGET="contents">Type.IsSpecialName Property</A><BR>
<A HREF="#Type.IsValueType%20Property" TARGET="contents">Type.IsValueType Property</A><BR>
<A HREF="#Type.Module%20Property" TARGET="contents">Type.Module Property</A><BR>
<A HREF="#Type.Namespace%20Property" TARGET="contents">Type.Namespace Property</A><BR>
<A HREF="#Type.ReflectedType%20Property" TARGET="contents">Type.ReflectedType Property</A><BR>
<A HREF="#Type.TypeHandle%20Property" TARGET="contents">Type.TypeHandle Property</A><BR>
<A HREF="#Type.TypeInitializer%20Property" TARGET="contents">Type.TypeInitializer Property</A><BR>
<A HREF="#Type.UnderlyingSystemType%20Property" TARGET="contents">Type.UnderlyingSystemType Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="Type%20Constructor"><H3>Type Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected Type();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Constructs a new instance of the <A HREF="Type.html" TARGET="contents">Type</A> class.
   <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Equals%20Method"><H3>Type.Equals Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool Equals(Type o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines if the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A> is the same as the
   underlying system type of the specified <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> whose underlying system type is to be compared with the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the underlying system type of <I>o</I> is the same
   as the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetArrayRank%20Method"><H3>Type.GetArrayRank Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual int GetArrayRank();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the number of dimensions in the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Int32.html" TARGET="contents">Int32</A> containing the number of dimensions in the  current
<A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The current <A HREF="Type.html" TARGET="contents">Type</A> is  not an array.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetAttributeFlagsImpl%20Method"><H3>Type.GetAttributeFlagsImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract TypeAttributes GetAttributeFlagsImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived type implements the System.Type.Attributes
property and returns the attributes specified for the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> value that signifies the attributes of the
   type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is read-only.<P>

This method returns a <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> value that indicates the attributes set in
      the metadata of the type represented by the current
      instance.<P>

]<P>

[<I>Usage</I>: Use this property to determine the
   visibility, semantics, and layout format of the type represented by the
   current. Also use this property to determine if the type represented by
   the current instance has a special name.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructor%28System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a constructor defined in the type represented by the current
      instance. The parameters of the constructor match the specified argument types
      and modifiers, under the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> object that reflects the constructor
   that matches the specified criteria. If an exact match does not exist,
<I>binder</I> will attempt to coerce the parameter types specified in 
<I>types</I> to select a match. If <I>binder</I> is unable to select a 
   match, returns <CODE>null</CODE>
 . If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   constructors to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public constructors
      in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      constructors (that is, private and protected constructors) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructor%28System.Type%5B%5D%29%20Method"><H3>Type.GetConstructor(System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo GetConstructor(Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a public instance constructor defined in the type represented by the
      current instance. The parameters of the constructor match the specified argument
      types.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned. Specify System.Type.EmptyTypes to obtain a constructor that takes no parameters.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> object representing the public instance
   constructor whose parameters match exactly the types in <I>types</I> , if found;
   otherwise, <CODE>null</CODE>
. If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <CODE>null</CODE>
. <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<I>types</I>, <CODE>null</CODE>
).<P>

<CODE></CODE>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructors%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetConstructors(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of constructors defined in the type represented by the
      current instance, under the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects that reflect the constructors that
   are defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I>. If System.Reflection.BindingFlags.NonPublic and System.Reflection.BindingFlags.Static are specified, this array
   includes the type initializer if it is defined. If no constructors meeting the
   constraints of <I>bindingAttr</I> are defined in the type represented by the
   current instance, returns an empty array. If the type represented by the current
   instance is contained in a loaded assembly, the constructors that match the
   specified criteria are not public, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   constructors to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public constructors
      in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      constructors (that is, private and protected constructors) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructors%28%29%20Method"><H3>Type.GetConstructors() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo[] GetConstructors();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of the public constructors defined in the type represented
      by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects that reflect the public constructors
   defined in the type represented by the current instance. If no public
   constructors are defined in the type represented by the current instance,
   returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetConstructors is equivalent to System.Type.GetConstructors(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetDefaultMembers%20Method"><H3>Type.GetDefaultMembers Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual MemberInfo[] GetDefaultMembers();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the default members
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects reflecting the default members of the
   type represented by the current instance. If the type represented by the current
   instance does not have any default members, returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: The members returned
      by this method have the <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A>
      attribute.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetElementType%20Method"><H3>Type.GetElementType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetElementType();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the element type of the current <A HREF="Type.html" TARGET="contents">Type</A>
.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> that represents 
   the type used to create the current instance if the current
   instance represents an array, pointer, or an argument
   passed by reference. Otherwise, returns <CODE>null</CODE>

   .<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.GetElementType
method.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 int[] array = {1,2,3};
 Type t = array.GetType();
 Type t2 = t.GetElementType();
 Console.WriteLine(&quot;{0} element type is {1}&quot;,array, t2.ToString());

 TestType newMe = new TestType();
 t = newMe.GetType();
 t2 = t.GetElementType();
 Console.WriteLine(&quot;{0} element type is {1}&quot;, newMe, t2==null? &quot;null&quot; : t2.ToString());
 }
}
</PRE>
The output is<P>

<CODE>System.Int32[] element type is System.Int32<P>

TestType element type is null<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvent%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetEvent(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the event that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the event to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the event that is named
<I>name</I>, is defined in the type represented by the current instance, and 
   matches the constraints of <I>bindingAttr</I>. If an event
   matching these criteria is not found, returns <CODE>null</CODE>
. If the event is not
   public, the current instance represents
   a type from a loaded assembly, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   events to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public events in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      events(that is, private and protected events) in the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the events
      declared on the type, not events that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvent%28System.String%29%20Method"><H3>Type.GetEvent(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public EventInfo GetEvent(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the public event that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public event to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object 
   reflecting the public event that is named
<I>name</I> and is defined in the type represented by the current instance, if 
   found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetEvent(System.String) is equivalent to System.Type.GetEvent(System.String)( <I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).<P>

The search for <I>name</I> is case-sensitive.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvents%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetEvents(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the events that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the events that are
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no events match
   these constraints, returns an empty array. If the type reflected by the current
   instance is from a loaded assembly and the caller does not have permission to
   reflect on non-public objects in loaded assemblies, returns only public
   events.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   events to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public events in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      events (that is, private and protected events) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvents%28%29%20Method"><H3>Type.GetEvents() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual EventInfo[] GetEvents();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the public events
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the public events
   defined in the type represented by the current instance. If no public events
   are defined in the type represented by the current instance, returns an empty
   array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

[<I>Default</I>: This version of System.Type.GetEvents is
   equivalent to System.Type.GetEvents(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetField%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetField(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the field to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that is named
<I>name</I>, is defined in the type represented by the current instance, and 
   matches the constraints of <I>bindingAttr</I>. If a field matching these criteria
   cannot be found, returns <CODE>null</CODE>
. If the field is not public, the current type is
   from a loaded assembly, and the caller does not have sufficient permission,
   returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   fields to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public fields in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public fields
      (that is, private and protected fields) in the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.FlattenHierarchy to
      include static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the fields
   declared in the type, not fields that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetField%28System.String%29%20Method"><H3>Type.GetField(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public FieldInfo GetField(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the field to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that is named
<I>name</I> and is defined in the type represented by the current instance, if 
   found; otherwise, <CODE>null</CODE>
. If the selected field is non-public, the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetField(System.String,System.Reflection.BindingFlags) is equivalent to System.Type.GetField(System.String,System.Reflection.BindingFlags)(
<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance ).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetFields%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetFields(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the fields that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the fields that are
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no fields match
   these constraints, returns an empty array. If the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns only public fields.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   fields to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static in
      order to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public fields in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public fields
      (that is, private and protected fields) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the fields
      declared in the type, not fields that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetFields%28%29%20Method"><H3>Type.GetFields() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public FieldInfo[] GetFields();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the public fields
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the public fields
   defined in the type represented by the current instance. If no public fields
   are defined in the type represented by the current instance, returns an empty
   array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetFields is equivalent to System.Type.GetFields( System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetHashCode%20Method"><H3>Type.GetHashCode Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override int GetHashCode();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Generates a hash code for the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Int32.html" TARGET="contents">Int32</A>
containing the hash code for this instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The algorithm used to
      generate the hash code is unspecified.<P>

[<I>Note</I>: This method
      overrides System.Object.GetHashCode
      .]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterface%28System.String%2C%20bool%29%20Method"><H3>Type.GetInterface(System.String, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetInterface(string name, bool ignoreCase);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the specified interface,
      specifying whether to do a case-sensitive search.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the interface to return.</DD>
<DT>ignoreCase</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A> where<CODE> true</CODE>
 indicates that the name search is to be done case-insensitively, and <CODE>false</CODE>
 performs a case-sensitive search.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing
   the interface with the specified name, implemented or inherited by the type
   represented by the instance, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterface%28System.String%29%20Method"><H3>Type.GetInterface(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type GetInterface(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Searches for the interface with the specified name.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the interface to get. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="Type.html" TARGET="contents">Type</A> object
   representing the interface with the specified name, implemented or inherited by
   the current <A HREF="Type.html" TARGET="contents">Type</A>, if found; otherwise, <CODE>null</CODE>
.
   <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 The search for <I>name</I> is case-sensitive.
   <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterfaces%20Method"><H3>Type.GetInterfaces Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type[] GetInterfaces();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns all interfaces implemented or inherited by the
      type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing the interfaces implemented or
   inherited by the type represented by the current instance. If no interfaces are
   found, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMember%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMember(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members defined in
   the type represented by the current instance that have the specified name
   and match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the member to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members
   named <I>name</I>, are defined in the type represented by the current instance
   and match the constraints of <I>bindingAttr</I> .
   If no members match these constraints, returns an empty array.
   If the selected member is non-public, the type reflected by the current instance is from a
   loaded assembly and the caller does not have sufficient permission to reflect on
   non-public objects in loaded assemblies, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
   declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMember%28System.String%29%20Method"><H3>Type.GetMember(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MemberInfo[] GetMember(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members that
   have the specified name and are defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the members to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members that
   are named <I>name</I> and are defined in the type represented by the current instance. If no public
   members with the specified name are defined in the type represented by the
   current instance, returns an empty array.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMember(System.String) is equivalent to System.Type.GetMember(System.String)( <I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).<P>

The search for <I>name</I> is case-sensitive.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMembers%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMembers(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members
   defined in the type represented by the current instance that match the
   constraints of <I>bindingAttr</I> . If no members match these constraints,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have sufficient permission to reflect
   on non-public objects in loaded assemblies, returns only public members.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMembers%28%29%20Method"><H3>Type.GetMembers() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MemberInfo[] GetMembers();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members
   defined in the type represented by the current instance. If no public members
   are defined in the type represented by the current instance, returns an empty
   array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMembers is equivalent to System.Type.GetMembers(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMethod(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the method that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the method to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object
   that reflects the method that is defined
   in the type represented by the current instance and matches the specified
   criteria, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I> ,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the method that matches the
   specified criteria and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the method to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects
   the method defined in the type represented by the current instance that
   matches the specified criteria. If no method matching the specified criteria is found, returns
<CODE>null</CODE>
 . If the 
   selected method is non-public, the type reflected by
   the current instance is from a loaded assembly, and the caller
   does not have permission to reflect on non-public objects in loaded assemblies,
   returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting the public method that is
   defined in the type represented by the current instance and matches the
   specified criteria, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default binder does not process
      <I>modifier</I> . <P>

The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) ( <I>name</I>, System.Reflection.BindingFlags.Public |System.Reflection.BindingFlags.Static |System.Reflection.BindingFlags.Instance , <CODE>null</CODE>
,<I> types</I> , <I>modifiers</I>).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method defined in
   the type represented by the current instance that has the specified name and parameter
   information.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting
   the public method defined in the type represented by the current instance
   that matches the specified criteria. If no public method matching the specified criteria
   is found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<I>types</I>, <CODE>null</CODE>
).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%29%20Method"><H3>Type.GetMethod(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting the public method that is
   defined in the type represented by the current instance and has the specified
   name, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<CODE>null</CODE>
, <CODE>null</CODE>
).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethods%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMethods(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects that reflect the methods defined in the type
   represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects reflecting the methods defined in the type
   represented by the current instance that match the constraints of
<I>bindingAttr</I> . If no such methods found, returns an 
   empty array. If the type represented by the current instance is from a loaded
   assembly and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns only public methods.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethods%28%29%20Method"><H3>Type.GetMethods() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo[] GetMethods();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the public methods defined in the type represented by the current
      instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects reflecting the public methods defined in the
   type represented by the current instance under the constraints of
<I>bindingAttr</I>. If no methods matching the constraints are found, returns an 
   empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMethods is equivalent to System.Type.GetMethods( System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedType%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetNestedType(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetNestedType(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns a nested types defined in the type represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the nested type to return. Specify the unqualified name of the nested type. [<I>Note</I>: For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType(&quot;B&quot;).]<P>

</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing the nested type that
   matches the specified criteria, if found; otherwise, <CODE>null</CODE>
. If the selected nested
   type is non-public, the current instance represents a type contained in a loaded
   assembly and the caller does not have sufficient permissions, returns
<CODE>null</CODE>
 
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedType%28System.String%29%20Method"><H3>Type.GetNestedType(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type GetNestedType(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the public nested type defined in the type represented by the current instance<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public nested type to return. Specify the unqualified name of the nested type. [<I>Note</I>: For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType(&quot;B&quot;). ]<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object
   representing the public nested type with the specified
   name, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetNestedTypes is equivalent to System.Type.GetNestedTypes(<I>name</I>, System.Reflection.BindingFlags.Public).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedTypes%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetNestedTypes(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns an array containing the nested types defined in
      the type represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing all types nested within the type
   represented by the current instance that match the specified binding constraints,
   if any. Otherwise, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array. If the type reflected by the current instance is
   contained in a loaded assembly, the type that matches the specified criteria is
   not public, and the caller does not have sufficient permission, returns only
   public types.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedTypes%28%29%20Method"><H3>Type.GetNestedTypes() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type[] GetNestedTypes();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns all the public types nested within the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing all public types nested within the type
   represented by the current instance, if any. Otherwise, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetNestedTypes is equivalent to System.Type.GetNestedTypes(System.Reflection.BindingFlags.Public).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperties%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetProperties(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the properties
   defined for the type represented by the current instance that match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the properties
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no matching properties are found,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have permission to reflect on
   non-public objects in loaded assemblies, returns only public properties.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: A property is considered by
   reflection to be <CODE>public</CODE>
 if it has at least one accessor that is
<CODE>public</CODE>
 . Otherwise, the property is not
<CODE>public</CODE>
.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperties%28%29%20Method"><H3>Type.GetProperties() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo[] GetProperties();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the public properties
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> 
objects that reflect the public properties defined in the type
represented by the current instance. If no public properties are found, returns
an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperties(System.Reflection.BindingFlags) is equivalent to System.Type.GetProperties(System.Reflection.BindingFlags)(
System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

A property is considered by reflection
   to be <CODE>public</CODE>
 if it has at least one accessor that is
<CODE>public</CODE>
. Otherwise, the property is considered to be not 
<CODE>public</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property
   defined in the type represented by the current instance that matches the specified search
   criteria .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object
   reflecting the property that is defined in the type represented by the
   current instance and matches the specified criteria. If no matching property is
   found, returns <CODE>null</CODE>
 . If the type reflected by the current
   instance is contained in a loaded assembly, the property that matches the
   specified criteria is not public, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I>, <I>binder</I>,
<I>returnType</I>, <I>types</I>, <I>modifiers</I>).<P>

The search for <I>name</I> is case-sensitive.<P>

 Different programming languages use different syntax to
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to specify this internal
   name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetProperty(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A>
object reflecting the property defined in the type represented by
the current instance that matches the specified criteria. If no matching property is
found, returns <CODE>null</CODE>
 . If the type reflected by the current
instance is contained in a loaded assembly, the property that matches the
specified criteria is not public, and the caller does not have sufficient
permission, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I>,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Type, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type returnType, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public property
   defined in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public property to be returned.</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the public property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes for a property that is not indexed.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object
   reflecting the public property defined in the type represented by
   the current instance that matches the specified criteria. If no matching property is
   found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <I>returnTypes</I>, <I>types</I>, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed
   property using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <CODE>null</CODE>
, <I>types</I>, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%29%20Method"><H3>Type.GetProperty(System.String, System.Type) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type returnType);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> 
object that reflects the public property defined in the type represented by the current
instance that matches the specified search criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined 
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <I>returnType</I>, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%29%20Method"><H3>Type.GetProperty(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public
   property defined in the type represented by the current instance that has the specified
   name.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined 
   on the type represented by the current instance that has the specified name. If
   no matching property is found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetPropertyImpl%20Method"><H3>Type.GetPropertyImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class implements the 
   System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) 
   method and returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object representing the property that matches the
   specified search criteria, if found; otherwise, <CODE>null</CODE>
. If the type reflected by the current
   instance is from a loaded assembly, the matching property is not
   public, and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>:  Different
   programming languages use different syntax to specify indexed properties.
   Internally, this property is referred to by the name &quot;Item&quot; in the metadata.
   Therefore, any attempt to retrieve an indexed property using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.
]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%2C%20bool%2C%20bool%29%20Method"><H3>Type.GetType(System.String, bool, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A>
with the specified name, optionally performing a case-sensitive search
and throwing an exception if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
<DT>throwOnError</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify <CODE>true</CODE>
 to throw a <A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A> if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>. Specify <CODE>false</CODE>
 to ignore errors while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</DD>
<DT>ignoreCase</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify<CODE> true</CODE>
 to perform a case-insensitive search for <I>typeName.</I> Specify <CODE>false</CODE>
 to perform a case-sensitive search for <I>typeName</I> .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
. If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
<TR><TD><A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A></TD><TD><I>throwOnError</I> is <CODE>true</CODE>
 and an error was encountered while loading the selected <A HREF="Type.html" TARGET="contents">Type</A>.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
<I>typeName</I> can be a simple
   type name, a fully qualified name, or a complex name that includes an assembly
   name. [<I>Note</I>: System.Type.AssemblyQualifiedName
   returns a fully qualified type name including nested types
   and the assembly name. ]<P>

<P>

If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method searches in the
calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.<P>

[<I>Note</I>: <CODE></CODE>
<P>

 The following table shows calls to
<CODE>GetType</CODE>
 for various types.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>To Get</TH><TH>Use</TH></TR>
<TR><TD> An
         unmanaged pointer to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType*&quot;)</CODE></TD></TR>
<TR><TD> An
         unmanaged pointer to a pointer to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType**&quot;)</CODE></TD></TR>
<TR><TD> A
         managed pointer
         or
         reference to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType&amp;&quot;)</CODE>. Note that unlike pointers, references are
      limited to one level.</TD></TR>
<TR><TD> A parent class and a nested class</TD><TD><CODE>Type.GetType(&quot;MyParentClass+MyNestedClass&quot;)</CODE></TD></TR>
<TR><TD> A one-dimensional array with a lower bound of 0</TD><TD><CODE>Type.GetType(&quot;MyArray[]&quot;)</CODE></TD></TR>
<TR><TD> A one-dimensional array with an unknown lower bound</TD><TD><CODE>Type.GetType(&quot;MyArray[*]&quot;)</CODE></TD></TR>
<TR><TD> An n-dimensional array</TD><TD>A comma (,) inside the brackets a total of n-1
      times. For example, <CODE>System.Object[,,]</CODE> represents a three-dimensional
<CODE>Object</CODE>
 
array.</TD></TR>
<TR><TD> A
      two-dimensional array&apos;s array</TD><TD><CODE>Type.GetType(&quot;MyArray[][]&quot;)</CODE></TD></TR>
<TR><TD> A rectangular two-dimensional array with unknown lower bounds</TD><TD><CODE>Type.GetType(&quot;MyArray[*,*]&quot;)</CODE>or <CODE>Type.GetType(&quot;MyArray[,]&quot;)</CODE></TD></TR>
</TABLE>
]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%2C%20bool%29%20Method"><H3>Type.GetType(System.String, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName, bool throwOnError);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, optionally throwing an
   exception if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the case-sensitive name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
<DT>throwOnError</DT>
<DD>A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify <CODE>true</CODE>
 to throw a <A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A> if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>. Specify <CODE>false</CODE>
 to ignore errors while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
 . If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
<TR><TD><A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A></TD><TD><I>throwOnError</I> is <CODE>true</CODE>
 and an error was encountered while loading the <A HREF="Type.html" TARGET="contents">Type</A>.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Type.GetType(System.String,System.Boolean,System.Boolean)(<I>name</I>, <I>throwOnError</I>, 
<CODE>false</CODE>
).<P>

<I>typeName</I> can be a simple
type name, a fully qualified name, or a complex name that includes an assembly
name specification. If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method searches in the
calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.<P>

[<I>Note</I>: System.Type.AssemblyQualifiedName can return a fully
qualified type name including nested types and the assembly name. For complete
details, see System.Type.GetType(System.String,System.Boolean,System.Boolean)(<A HREF="String.html" TARGET="contents">String</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>). ]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%29%20Method"><H3>Type.GetType(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A> with the specified name.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the case-sensitive name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
. If the
   requested type is non-public and the caller does not have permission to reflect
   non-public objects outside the current assembly, this method returns
<CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Type.GetType(System.String,System.Boolean,System.Boolean)(<I>name</I>, <CODE>false</CODE>
,
<CODE>false</CODE>
).<P>

<I>typeName</I> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification. If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method
searches in the calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.<P>

[<I>Note</I>: System.Type.AssemblyQualifiedName can return a fully qualified type name including
   nested types and the assembly name. For complete details, see System.Type.GetType(System.String,System.Boolean,System.Boolean)(<A HREF="String.html" TARGET="contents">String</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeArray%20Method"><H3>Type.GetTypeArray Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type[] GetTypeArray(object[] args);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the types of the objects in the specified array.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>args</DT>
<DD>An array of objects whose types are to be returned. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing the types of the corresponding
   elements in <I>args</I>. If a requested type is not public
   and the caller does not have permission to
   reflect non-public objects outside the current assembly, the corresponding element in the
   array returned by this method will be <CODE>null</CODE>
.
   <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>args</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The type initializers were invoked and at least one threw an exception. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeFromHandle%20Method"><H3>Type.GetTypeFromHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetTypeFromHandle(RuntimeTypeHandle handle);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the <A HREF="Type.html" TARGET="contents">Type</A> referenced by the specified type handle.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>handle</DT>
<DD>The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> object that refers to the desired <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> referenced by the specified <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A>.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>handle</I> is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>The requested type is non-public and outside the current assembly, and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handles are valid only in the application domain in which they were obtained. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeHandle%20Method"><H3>Type.GetTypeHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static RuntimeTypeHandle GetTypeHandle(object o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the handle for the <A HREF="Type.html" TARGET="contents">Type</A> of the specified object.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The object for which to get the type handle.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> for the <A HREF="Type.html" TARGET="contents">Type</A> of the specified <A HREF="Object.html" TARGET="contents">Object</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handle is valid only in the application domain in which it was obtained. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.HasElementTypeImpl%20Method"><H3>Type.HasElementTypeImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool HasElementTypeImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.HasElementType property and
   determines whether the current <A HREF="Type.html" TARGET="contents">Type</A> encompasses or
   refers to another type; that is,
   whether the current <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by
   reference.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: For example, 
   System.Type.GetType(System.String,System.Boolean,System.Boolean) (&quot;System.Int32[]&quot;).HasElementTypeImpl returns
   <CODE>true</CODE>
, but System.Type.GetType(System.String,System.Boolean,System.Boolean) (&quot;System.Int32&quot;).HasElementTypeImpl returns
   <CODE>false</CODE>
. System.Type.HasElementTypeImpl also returns <CODE>true</CODE>
 for &quot;System.Int32*&quot; and &quot;System.Int32&amp;&quot;.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%2C%20System.Globalization.CultureInfo%2C%20System.String%5B%5D%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Invokes or
      accesses a member defined on the type represented by the current instance
      that matches the specified binding criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default.<P>

</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound if and only if <I>nameParameters</I> is <CODE>null</CODE>
. If <I>namedParameters</I> is not <CODE>null</CODE>
, the order of the elements in <I>args</I> corresponds to the order of the parameters specified in <I>namedParameters</I>. Specify an empty array or <CODE>null</CODE>
 for a member that takes no parameters.</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
<DT>culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
<DT>namedParameters</DT>
<DD>An array of <A HREF="String.html" TARGET="contents">String</A> objects containing the names of the parameters to which the values in <I>args</I> are passed. These names are processed in a case-sensitive manner and have a one-to-one correspondence with the elements of <I>args</I>. Specify an empty array or <CODE>null</CODE>
 for a member that takes no parameters. Specify <CODE>null</CODE>
 to have this parameter ignored.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked or accessed member. If the member
does not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethod and at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

-or-<P>

<I>namedParameters</I>.Length &gt; <I>args</I>.Length .<P>

-or-<P>

At least one element in <I>namedParameters</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one element in <I>args</I> is not assignment-compatible with the corresponding parameter in <I>namedParameters</I>.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria cannot be found.</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) calls a constructor or a method , gets or sets a property , gets or sets a field, or gets or sets an element of an array.<P>

 The binder finds all of the matching members. These
   members are found based upon the type of binding specified by <I>InvokeAttr</I> . The System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@) is
   responsible for selecting the method to be invoked. The default binder selects
   the most specific match. The set of members is then filtered by name, number of
   arguments, and a set of search modifiers defined in the binder. After the member is selected, it is invoked or accessed.
   Accessibility is checked at that point. Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.<P>

The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
members to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.FlattenHierarchy to include
      static members declared in ancestors in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: Each parameter in the <I>namedParameters</I> array is assigned the value in the
   corresponding element in the <I>args</I> array. If the length of <I>args</I> is
   greater than the length of <I>namedParameters</I>, the remaining argument values
   are passed in order.<P>

A member will be found only
   if the number of parameters in the member declaration equals the number of
   arguments in the args array (unless default arguments are defined on the
   member). Also, The type of each argument is required to be convertible by
   the binder to the type
   of the parameter. <P>

It is required that the caller specify values for <I>bindingAttr</I> as
follows:<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Action</TH><TH>BindingFlags</TH></TR>
<TR><TD> Invoke a constructor. </TD><TD>System.Reflection.BindingFlags.CreateInstance. This
      flag is not valid with the other flags in this table. If this flag is
      specified, <I>name</I> is ignored. </TD></TR>
<TR><TD> Invoke a method. </TD><TD>System.Reflection.BindingFlags.InvokeMethod. This
   flag if not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.SetField, or System.Reflection.BindingFlags.SetProperty. </TD></TR>
<TR><TD> Define a field value. </TD><TD>System.Reflection.BindingFlags.SetField. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.GetField.</TD></TR>
<TR><TD> Return a field value. </TD><TD>System.Reflection.BindingFlags.GetField. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.SetField.</TD></TR>
<TR><TD> Set a property. </TD><TD>System.Reflection.BindingFlags.SetProperty. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.GetProperty.</TD></TR>
<TR><TD> Get a property.</TD><TD>System.Reflection.BindingFlags.GetProperty. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.SetProperty.</TD></TR>
</TABLE>
<P>

[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> .]<P>

<P>

]<P>

[<I>Usage</I>: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) can be used to invoke methods with
   parameters that have default values. To bind to these methods, System.Reflection.BindingFlags.OptionalParamBinding must be specified. For a parameter that has a
   default value, the caller can supply a value or supply System.Type.Missing
   
   to use the default value.<P>

System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) can be used to set a field to a
particular value by specifying System.Reflection.BindingFlags.SetField . For example, to set a public instance field named F on class C, where F is a string, the value is set using the following statement:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{
   &quot;strings new value&quot;}, null, null, null);</CODE><P>

 A string array F can be initialized as follows:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{new
      String[]{&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;}, null, null, null);<P>

</CODE> Use System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) to set the value of an element in an array by specifying the index of the value and the new value for the element as follows:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{1,
   &quot;b&quot;}, null, null, null);</CODE><P>

The preceding statement changes &quot;z&quot; in array
   F to &quot;b&quot;. <P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the use of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) to
   construct a <A HREF="String.html" TARGET="contents">String</A>, obtain its System.String.Length property, invoke System.String.Insert(System.Int32,System.String) on it, and
   then set its value using the System.String.Empty field.<P>

<PRE>using System;
using System.Reflection;

class InvokeMemberExample
{
   static void Main(string[] args)
   {
      // Create the parameter arrays that will
      // be passed to InvokeMember.
      char[] cAry = 
      new char[] {&apos;A&apos;,&apos; &apos;,&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;i&apos;,&apos;n&apos;,&apos;g&apos;};
      object[] oAry = new object[] {cAry, 0, cAry.Length};

      Type t = typeof(string);

      // Invoke the constructor of a string.
      string str =
         (string)t.InvokeMember(null, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.CreateInstance, null,
         null, oAry, null, null, null);
      Console.WriteLine(&quot;The string is \&quot;{0}\&quot;.&quot;, str);

      // Access a property of the string.
      int i =
         (int) t.InvokeMember(&quot;Length&quot;, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.GetProperty, null, 
         str, null, null, null, null);
      Console.WriteLine(&quot;The length of the string is {0}.&quot;, i);

      // Invoke a method on the string.
      string newStr = &quot;new &quot;;
      object[] oAry2 = new Object[] {2, newStr};
      str = (string) t.InvokeMember(&quot;Insert&quot;, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.InvokeMethod, null, str, 
         oAry2, null, null, null);
      Console.WriteLine(&quot;The modified string is \&quot;{0}\&quot;.&quot;, str);

      // Access a field of the string.
      str = (string) t.InvokeMember(&quot;Empty&quot;, BindingFlags.Static | 
         BindingFlags.Public | BindingFlags.GetField, null, str, 
         null);
      Console.WriteLine(&quot;The empty string is \&quot;{0}\&quot;.&quot;, str);
  
   }
}
</PRE>
The output is <P>

<CODE>The string is &quot;A string&quot;. <P>

The length of the string is 8. <P>

 The modified string is &quot;A new string&quot;<P>

The empty string is &quot;&quot;. <P>

</CODE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the specified member, using the specified binding constraints
      and matching the specified argument list and culture.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default. <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <CODE>null</CODE>
 for a member that has no parameters.</DD>
<DT>culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>n</I><I>ame</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethodand at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) is equivalent to System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(
<I>name</I>, <I>invokeAttr</I>, <I>binder</I>, <I>target</I>, <I>args</I>, 
<CODE>null</CODE>
, <I>culture</I>, <CODE>null</CODE>
 ). <P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 For an example that demonstrates
   System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) , see System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(
   <A HREF="String.html" TARGET="contents">String</A>, <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>,
   <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A>, <A HREF="Object.html" TARGET="contents">Object</A>, <A HREF="Object.html" TARGET="contents">Object</A>[], <A HREF="../System/Reflection/ParameterModifier.html" TARGET="contents">ParameterModifier</A>[], <A HREF="../System/Globalization/CultureInfo.html" TARGET="contents">CultureInfo</A>, <A HREF="String.html" TARGET="contents">String</A>[]).
      <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the specified member, using the specified binding constraints and
      matching the specified argument list.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default.</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <CODE>null</CODE>
 for a member that has no parameters.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethod and at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria cannot be found.</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) is equivalent to System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(<I>name</I>, <I>invokeAttr</I>, <I>binder</I>,
<I>target</I>, <I>args</I>, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

[<I>Note</I>: For a demonstration of the use of
System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]), see the example for System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])( 
<A HREF="String.html" TARGET="contents">String</A>, <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>, 
<A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A>, <A HREF="Object.html" TARGET="contents">Object</A>, <A HREF="Object.html" TARGET="contents">Object</A>[], <A HREF="../System/Reflection/ParameterModifier.html" TARGET="contents">ParameterModifier</A>[], <A HREF="../System/Globalization/CultureInfo.html" TARGET="contents">CultureInfo</A>, <A HREF="String.html" TARGET="contents">String</A>[]).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsArrayImpl%20Method"><H3>Type.IsArrayImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsArrayImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class implements the System.Type.IsArray property returning a
<A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether
   the type represented by the current instance is an array.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
An instance of the <A HREF="Array.html" TARGET="contents">Array</A> class is required to return <CODE>false</CODE>
 because it is an object, not an
   array.[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAssignableFrom%20Method"><H3>Type.IsAssignableFrom Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsAssignableFrom(Type c);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Determines whether an instance of the current <A HREF="Type.html" TARGET="contents">Type</A> can be assigned
   from an instance of the specified <A HREF="Type.html" TARGET="contents">Type</A> .
   <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>c</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> to compare with the current <A HREF="Type.html" TARGET="contents">Type</A> . </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>false</CODE>
 if <I>c</I> is a null reference.<P>

<CODE>true</CODE>
 if one or more of the following
statements are true; otherwise <CODE>false</CODE>
. <P>

<UL>
<LI>
      
      If <I>c</I> and the current <A HREF="Type.html" TARGET="contents">Type</A> represent the same type.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is in the inheritance hierarchy of <I>c</I>.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is an interface and <I>c</I> supports that
      interface.</LI>
</UL>
<CODE></CODE>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsAssignableFrom(System.Type)
method using arrays.<P>

<PRE>using System;
class ArrayTypeTest {
 public static void Main() {
 int i = 1;
 int [] array10 = new int [10];
 int [] array2 = new int[2];
 int [,]array22 = new int[2,2];
 int [,]array24 = new int[2,4];
 int [,,]array333 = new int[3,3,3];
 Type array10Type = array10.GetType();
 Type array2Type = array2.GetType();
 Type array22Type = array22.GetType();
 Type array24Type = array24.GetType();
 Type array333Type = array333.GetType();

 // If X and Y are not both arrays, then false
 Console.WriteLine(&quot;int[2] is assignable from int? {0} &quot;, array2Type.IsAssignableFrom(i.GetType()));
 // If X and Y have same type and rank, then true.
 Console.WriteLine(&quot;int[2] is assignable from int[10]? {0} &quot;,  array2Type.IsAssignableFrom(array10Type));
 Console.WriteLine(&quot;int[2,2] is assignable from int[2,4]? {0}&quot;,  array22Type.IsAssignableFrom(array24Type));
 Console.WriteLine(&quot;int[2,4] is assignable from int[2,2]? {0}&quot;,  array24Type.IsAssignableFrom(array22Type));
 Console.WriteLine(&quot;&quot;);
 // If X and Y do not have the same rank, then false.
 Console.WriteLine(&quot;int[2,2] is assignable from int[10]? {0}&quot;,  array22Type.IsAssignableFrom(array10Type));
 Console.WriteLine(&quot;int[2,2] is assignable from int[3,3,3]? {0}&quot;,  array22Type.IsAssignableFrom(array333Type));
 Console.WriteLine(&quot;int[3,3,3] is assignable from int[2,2]? {0}&quot;,  array333Type.IsAssignableFrom(array22Type));
 }
}
</PRE>
The output is<P>

<CODE>int[2] is assignable from int? False<P>

int[2] is assignable from int[10]? True<P>

int[2,2] is assignable from int[2,4]? True<P>

int[2,4] is assignable from int[2,2]? True<P>

int[2,2] is assignable from int[10]? False<P>

int[2,2] is assignable from int[3,3,3]? False<P>

int[3,3,3] is assignable from int[2,2]? False<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsByRefImpl%20Method"><H3>Type.IsByRefImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsByRefImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsByRef
property and determines whether the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsCOMObjectImpl%20Method"><H3>Type.IsCOMObjectImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsCOMObjectImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Reserved.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>false</CODE>
<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This abstract method is required to be present for
      legacy implementations. Conforming implementations are permitted to throw the
   <A HREF="NotSupportedException.html" TARGET="contents">NotSupportedException</A>
   as their implementation.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsInstanceOfType%20Method"><H3>Type.IsInstanceOfType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsInstanceOfType(object o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Determines whether the specified object is an instance
      of the current <A HREF="Type.html" TARGET="contents">Type</A>.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The object to compare with the current <A HREF="Type.html" TARGET="contents">Type</A>. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if either of the following
   statements is true; otherwise <CODE>false</CODE>
.
   <P>

<UL>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is in the inheritance hierarchy of <I>o</I>.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is an interface and <I>o</I> supports that
      interface.</LI>
</UL>
If <I>o</I> is a null reference, returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsInstanceOfType(System.Object)
method.<P>

<PRE>using System;
public interface IFoo { }
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest {
 public static void Main() {
 Type ifooType=typeof(IFoo);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayType = typeof(Array);
 Console.WriteLine(&quot;int[] is instance of Array? {0}&quot;, arrayType.IsInstanceOfType(array));
 Console.WriteLine(&quot;myclass instance is instance of MyClass? {0}&quot;, mcType.IsInstanceOfType(mc));
 Console.WriteLine(&quot;myderivedclass instance is instance of MyClass? {0}&quot;,  mcType.IsInstanceOfType(mdc));
 Console.WriteLine(&quot;myclass instance is instance of IFoo? {0}&quot;, ifooType.IsInstanceOfType(mc));
 Console.WriteLine(&quot;myderivedclass instance is instance of IFoo? {0}&quot;,  ifooType.IsInstanceOfType(mdc));
 }
}
</PRE>
The output is <P>

<CODE>int[] is instance of Array? True<P>

myclass instance is instance of MyClass? True<P>

myderivedclass instance is instance of MyClass? True<P>

myclass instance is instance of IFoo? True<P>

myderivedclass instance is instance of IFoo? True<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPointerImpl%20Method"><H3>Type.IsPointerImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsPointerImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsPointer property and determines whether the
<A HREF="Type.html" TARGET="contents">Type</A> is a pointer.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is a pointer; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPrimitiveImpl%20Method"><H3>Type.IsPrimitiveImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsPrimitiveImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsPrimitive property and determines whether the
<A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This method 
      returns <CODE>true</CODE>
 if the underlying type of the current instance is
      one of the following: <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Byte.html" TARGET="contents">Byte</A>, <A HREF="SByte.html" TARGET="contents">SByte</A>, <A HREF="Int16.html" TARGET="contents">Int16</A>, <A HREF="UInt16.html" TARGET="contents">UInt16</A>, <A HREF="Int32.html" TARGET="contents">Int32</A>, <A HREF="UInt32.html" TARGET="contents">UInt32</A>, <A HREF="Int64.html" TARGET="contents">Int64</A>, <A HREF="UInt64.html" TARGET="contents">UInt64</A>, <A HREF="Char.html" TARGET="contents">Char</A>, <A HREF="Double.html" TARGET="contents">Double</A>, and <A HREF="Single.html" TARGET="contents">Single</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSubclassOf%20Method"><H3>Type.IsSubclassOf Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsSubclassOf(Type c);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines whether the current <A HREF="Type.html" TARGET="contents">Type</A> derives from the
   specified <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>c</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> to compare with the current <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if <I>c</I> and the current
<A HREF="Type.html" TARGET="contents">Type</A> represent 
   classes, and the class represented by the current <A HREF="Type.html" TARGET="contents">Type</A> derives from the class represented by
<I>c</I>; otherwise <CODE>false</CODE>
. Returns <CODE>false</CODE>
 if 
<I>c</I> and the current <A HREF="Type.html" TARGET="contents">Type</A> represent the same class.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsSubclassOf(System.Type)
method.<P>

<PRE>using System;
public interface IFoo { }
public interface IBar:IFoo{}
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsSubclassTest {
 public static void Main() {
 Type ifooType = typeof(IFoo);
 Type ibarType = typeof(IBar);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayOfIntsType = array.GetType();
 Type arrayType = typeof(Array);
 
 Console.WriteLine(&quot;Array is subclass of int[]? {0}&quot;, arrayType.IsSubclassOf(arrayOfIntsType));
 Console.WriteLine(&quot;int [] is subclass of Array? {0}&quot;, arrayOfIntsType.IsSubclassOf(arrayType));
 Console.WriteLine(&quot;IFoo is subclass of IBar? {0}&quot;, ifooType.IsSubclassOf(ibarType));
 Console.WriteLine(&quot;myclass is subclass of MyClass? {0}&quot;, mcType.IsSubclassOf(mcType));
 Console.WriteLine(&quot;myderivedclass is subclass of MyClass? {0}&quot;, mdcType.IsSubclassOf(mcType));
 }
}
</PRE>
The output is <P>

<CODE>Array is subclass of int[]? False<P>

int [] is subclass of Array? True<P>

IFoo is subclass of IBar? False<P>

myclass is subclass of MyClass? False<P>

myderivedclass is subclass of MyClass? True<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.ToString%20Method"><H3>Type.ToString Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override string ToString();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns a <A HREF="String.html" TARGET="contents">String</A> representation of the current <A HREF="Type.html" TARGET="contents">Type</A>.
   <P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
Returns System.Type.FullName .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: This method
      overrides System.Object.ToString
      .]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Delimiter%20Field"><H3>Type.Delimiter Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly char Delimiter;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Specifies the character that separates elements in the fully qualified name
      of a <A HREF="Type.html" TARGET="contents">Type</A>
      .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.EmptyTypes%20Field"><H3>Type.EmptyTypes Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly Type[] EmptyTypes;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns an empty array of type <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

The empty <A HREF="Type.html" TARGET="contents">Type</A> array returned by this field is used to specify that 
   lookup methods in the <A HREF="Type.html" TARGET="contents">Type</A> class, such as System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) and System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]),
   search for members that do not take parameters. [<I>Note</I>: For example, to locate the public instance constructor that takes no
   parameters, invoke System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) (System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
, System.Type.EmptyTypes,
<CODE>null</CODE>
).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Missing%20Field"><H3>Type.Missing Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly object Missing;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Represents a missing value in the <A HREF="Type.html" TARGET="contents">Type</A> information.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

Use the <CODE>Missing</CODE>
 
field for invocation through reflection to ensure that a call will be made
with the default value of a parameter as specified in the metadata. [<I>Note</I>: If the <CODE>Missing</CODE>
 field is specified for a
parameter value and there is no default value for that parameter, a <A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A> is
thrown.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Assembly%20Property"><H3>Type.Assembly Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Assembly Assembly { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> that the type is declared in. <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> instance that describes assembly containing the current type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.AssemblyQualifiedName%20Property"><H3>Type.AssemblyQualifiedName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string AssemblyQualifiedName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the fully qualified name of the type represented by 
      the current instance
      including the name of the assembly from which the <A HREF="Type.html" TARGET="contents">Type</A> was loaded.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="String.html" TARGET="contents">String</A> containing the 
   fully qualified name of the type represented by the current instance,
   including the name of the assembly from which the <A HREF="Type.html" TARGET="contents">Type</A> was loaded.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>:  
         This property is read-only.<P>

Compilers emit the simple name of a nested class, and reflection constructs a 
         mangled name when queried, in accordance with the following conventions.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Delimiter</TH><TH>Meaning</TH></TR>
<TR><TD> Backslash (\)</TD><TD>Escape character.</TD></TR>
<TR><TD> Comma (,)</TD><TD>Precedes the Assembly name.</TD></TR>
<TR><TD> Plus sign (+)</TD><TD>Precedes a nested class.</TD></TR>
<TR><TD> Period (.)</TD><TD>Denotes namespace identifiers. </TD></TR>
</TABLE>
[<I>Note</I>: For example, the fully qualified name for a class might look like this: <P>

TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly <P>

If the namespace were TopNamespace.Sub+Namespace, then the string would
            have to precede the plus sign (+) with an escape character (\) to prevent
            it from being interpreted as a nesting separator. Reflection
            emits this string as follows:<P>

TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly<P>

A &quot;++&quot; becomes &quot;\+\+&quot;, and a &quot;\&quot; becomes &quot;\\&quot;.<P>

]<P>

Type names are permitted to include trailing characters that denote
         additional information about the type, such as whether the type is a reference
         type, a pointer type or an array type. To retrieve the type name without these
         trailing characters, use <CODE>t.GetElementType().ToString()</CODE>, where <I>t</I>
      is the type.<P>

Spaces are significant in all type name components except the assembly
      name. In the assembly name, spaces before the &apos;,&apos; separator are significant, but
      spaces after the &apos;,&apos; separator are ignored.<P>

]<P>

[<I>Usage</I>: The name returned by this method can be persisted and later used to load the <A HREF="Type.html" TARGET="contents">Type</A>.
   To search for and load a <A HREF="Type.html" TARGET="contents">Type</A>, use System.Type.GetType(System.String,System.Boolean,System.Boolean) either with the type name only or with
   the assembly qualified type name. System.Type.GetType(System.String,System.Boolean,System.Boolean) with the type name only will look for
   the <A HREF="Type.html" TARGET="contents">Type</A>
   in the caller&apos;s assembly and then in the System assembly. System.Type.GetType(System.String,System.Boolean,System.Boolean) with the
   assembly qualified type name will look for the <A HREF="Type.html" TARGET="contents">Type</A> in any assembly.<P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Attributes%20Property"><H3>Type.Attributes Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public TypeAttributes Attributes { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the attributes associated with the type represented 
      by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> object representing the attribute set of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.BaseType%20Property"><H3>Type.BaseType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type BaseType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the base <A HREF="Type.html" TARGET="contents">Type</A> of the current <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object 
   representing the type from which the current <A HREF="Type.html" TARGET="contents">Type</A> directly inherits, or
<CODE>null</CODE>
 
if the current <A HREF="Type.html" TARGET="contents">Type</A> represents the <A HREF="Object.html" TARGET="contents">Object</A> class.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>:  This property is read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.BaseType
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 Type t = typeof(int);
 Console.WriteLine(&quot;{0} inherits from {1}&quot;, t,t.BaseType);
 }
}
</PRE>
The output is<P>

<CODE>System.Int32
   inherits from System.ValueType</CODE><P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.DeclaringType%20Property"><H3>Type.DeclaringType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override Type DeclaringType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the type that declares the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> object for
   the class that declares the type represented by the current
   instance. If the type is a nested type, this property returns the enclosing type; otherwise, returns
   the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: This property overrides System.Reflection.MemberInfo.DeclaringType.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the
   System.Type.DeclaringType property. <P>

<PRE>using System;
using System.Reflection;

public abstract class DeclaringTypeTest{
   public abstract class MyClassA {
      public abstract int m(); 
   }
   public abstract class MyClassB : MyClassA {
   }
   public static void Main() { 
      Console.WriteLine(&quot;Declaring type of m is {0}&quot;,
         typeof(MyClassB).GetMethod(&quot;m&quot;).DeclaringType);
   }
}
   </PRE>
 The output is <P>

<CODE>Declaring type of m is DeclaringTypeTest+MyClassA <P>

</CODE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.DefaultBinder%20Property"><H3>Type.DefaultBinder Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Binder DefaultBinder { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the default binder used by the system.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The default <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> used by the system.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Reflection models the accessibility rules of the common
      type system. For example, if the caller is in the same assembly, the caller does
      not need special permissions for internal members. Otherwise, the caller needs
   <A HREF="../System/Security/Permissions/ReflectionPermission.html" TARGET="contents">ReflectionPermission</A>
   . This is consistent with lookup of members that
   are protected, private, and so on. <P>

[<I>Note</I>: The general principle is that System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo) 
typically performs only widening coercions,
which never lose data. An example of a widening coercion is coercing a
value that is a 32-bit signed integer to a value that is a 64-bit signed integer.
This is distinguished from a narrowing coercion, which may lose data. An
example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit
signed integer. ]<P>

<P>

The following table lists the coercions performed by the default binder&apos;s implementation of
<CODE>ChangeType</CODE>
.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Source Type</TH><TH>Target Type</TH></TR>
<TR><TD> Any type</TD><TD>Its base type.</TD></TR>
<TR><TD> Any type</TD><TD>The interface it implements.</TD></TR>
<TR><TD> Char</TD><TD>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Byte</TD><TD>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> SByte</TD><TD>Int16, Int32, Int64, Single, Double</TD></TR>
<TR><TD> UInt16</TD><TD>UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Int16</TD><TD>Int32, Int64, Single, Double</TD></TR>
<TR><TD> UInt32</TD><TD>UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Int32</TD><TD>Int64, Single, Double</TD></TR>
<TR><TD> UInt64</TD><TD>Single, Double</TD></TR>
<TR><TD> Int64</TD><TD>Single, Double</TD></TR>
<TR><TD> Single</TD><TD>Double</TD></TR>
<TR><TD> Non-reference</TD><TD>By-reference.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.FullName%20Property"><H3>Type.FullName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string FullName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the fully qualified name of the type represented by 
      the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="String.html" TARGET="contents">String</A> containing the fully qualified name of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: For example, the
      fully qualified name of the C# string type is &quot;System.String&quot;.]<P>

<P>

[<I>Behaviors</I>: This property is
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.FullName
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 Type t = typeof(Array);
 Console.WriteLine(&quot;Full name of Array type is {0}&quot;,t.FullName);
 }
}
</PRE>
The output is<P>

<CODE>Full name of
   Array type is System.Array</CODE><P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.HasElementType%20Property"><H3>Type.HasElementType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool HasElementType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the type represented by the 
   current instance encompasses or refers
   to another type; that is, whether the current <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: For example, System.Type.GetType(System.String,System.Boolean,System.Boolean)(&quot;<A HREF="Int32.html" TARGET="contents">Int32</A> []&quot;).HasElementType returns
<CODE>true</CODE>
, but System.Type.GetType(System.String,System.Boolean,System.Boolean)(&quot;<A HREF="Int32.html" TARGET="contents">Int32</A> &quot;).HasElementType returns
<CODE>false</CODE>
. System.Type.HasElementType also returns
<CODE>true</CODE>
 for &quot;Int32*&quot; and &quot;Int32&amp;&quot;.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAbstract%20Property"><H3>Type.IsAbstract Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsAbstract { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating 
   whether the type represented by the current instance is abstract and is required to be overridden.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is abstract; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsArray%20Property"><H3>Type.IsArray Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsArray { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents an array.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents an
   array; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns <CODE>true</CODE>
 for an array of objects, but
   not for the <A HREF="Array.html" TARGET="contents">Array</A>
   type itself, which is a class.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.IsArray
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 int [] array = {1,2,3,4};
 Type at = typeof(Array);
 Type t = array.GetType();
 Console.WriteLine(&quot;Type is {0}. IsArray? {1}&quot;, at, at.IsArray);
 Console.WriteLine(&quot;Type is {0}. IsArray? {1}&quot;, t, t.IsArray);
 }
}
</PRE>
The output is<P>

<CODE>Type is System.Array. IsArray? False<P>

Type is System.Int32[]. IsArray? True<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAutoLayout%20Property"><H3>Type.IsAutoLayout Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsAutoLayout { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.AutoLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type
   layout attribute System.Reflection.TypeAttributes.AutoLayout is specified for the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: The System.Reflection.TypeAttributes.AutoLayout attribute specifies that the system
      selects the layout the objects of the type. Types marked with this attribute indicate that the
      system will choose the appropriate way to lay out the type; any layout information
      that may have been specified is ignored. <P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsByRef%20Property"><H3>Type.IsByRef Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsByRef { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the <A HREF="Type.html" TARGET="contents">Type</A> is
   passed by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsClass%20Property"><H3>Type.IsClass Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsClass { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a class;
   otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Note that this property returns <CODE>true</CODE>
 for
<A HREF="Type.html" TARGET="contents">Type</A> instances 
   representing <A HREF="Enum.html" TARGET="contents">Enum</A> and <A HREF="ValueType.html" TARGET="contents">ValueType</A> .<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsEnum%20Property"><H3>Type.IsEnum Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsEnum { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents an enumeration.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents an
   enumeration; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns <CODE>true</CODE>
 for an enumeration, but not
   for the <A HREF="Enum.html" TARGET="contents">Enum</A>
   type itself, which is a class.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.IsEnum
property.<P>

<PRE>using System;
public enum Color {
Red, Blue, Green
}
class TestType {
 public static void Main() {
 Type colorType = typeof(Color);
 Type enumType = typeof(Enum);
 Console.WriteLine(&quot;Color is enum ? {0}&quot;, colorType.IsEnum);
 Console.WriteLine(&quot;Color is valueType? {0}&quot;, colorType.IsValueType);
 Console.WriteLine(&quot;Enum is enum Type? {0}&quot;, enumType.IsEnum);
 Console.WriteLine(&quot;Enum is value? {0}&quot;, enumType.IsValueType);
 }
}
</PRE>
The output is<P>

<CODE>Color is enum ? True<P>

Color is valueType? True<P>

Enum is enum Type? False<P>

Enum is value? False<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsExplicitLayout%20Property"><H3>Type.IsExplicitLayout Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsExplicitLayout { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.ExplicitLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type layout attribute System.Reflection.TypeAttributes.ExplicitLayout is specified for the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise,
<CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Types marked with the System.Reflection.TypeAttributes.ExplicitLayout attribute cause
      the system to ignore field sequence and to use the explicit layout rules provided,
      in the form of field offsets, overall class size and alignment. <P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsImport%20Property"><H3>Type.IsImport Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsImport { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the <A HREF="Type.html" TARGET="contents">Type</A> was imported from another class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> was imported from another class; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsInterface%20Property"><H3>Type.IsInterface Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsInterface { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the  current <A HREF="Type.html" TARGET="contents">Type</A> represents an interface.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A>  represents an
   interface; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsLayoutSequential%20Property"><H3>Type.IsLayoutSequential Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsLayoutSequential { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.SequentialLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type layout attribute
System.Reflection.TypeAttributes.SequentialLayout is specified for the current 
<A HREF="Type.html" TARGET="contents">Type</A>; otherwise, 
<CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>:  The System.Reflection.TypeAttributes.SequentialLayout attribute is used
      to indicate that
      the system is to preserve field order as emitted, but otherwise the specific offsets are calculated based on the type
      of the field; these may be shifted by explicit offset, padding, or alignment information.<P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsMarshalByRef%20Property"><H3>Type.IsMarshalByRef Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsMarshalByRef { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current type is marshaled by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is marshaled by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedAssembly%20Property"><H3>Type.IsNestedAssembly Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedAssembly { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamANDAssem%20Property"><H3>Type.IsNestedFamANDAssem Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamANDAssem { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only to classes that belong to both its own family and
   its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only to classes that belong to both its own family and its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamORAssem%20Property"><H3>Type.IsNestedFamORAssem Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamORAssem { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only to classes that belong to either its
   own family or to its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only to classes that belong to its own family or to its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamily%20Property"><H3>Type.IsNestedFamily Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamily { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its
   own family.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only within its own family; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedPrivate%20Property"><H3>Type.IsNestedPrivate Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedPrivate { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and declared private.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested and declared private; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedPublic%20Property"><H3>Type.IsNestedPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating 
   whether the current <A HREF="Type.html" TARGET="contents">Type</A> is a public nested class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if
   the class is nested and declared public; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNotPublic%20Property"><H3>Type.IsNotPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNotPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the top-level <A HREF="Type.html" TARGET="contents">Type</A> is not declared public.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the
   top-level <A HREF="Type.html" TARGET="contents">Type</A> is not declared public; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPointer%20Property"><H3>Type.IsPointer Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPointer { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a pointer.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
This property is read-only.<P>

<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a
   pointer; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPrimitive%20Property"><H3>Type.IsPrimitive Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPrimitive { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

The primitive types are <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Byte.html" TARGET="contents">Byte</A>, <A HREF="SByte.html" TARGET="contents">SByte</A>, <A HREF="Int16.html" TARGET="contents">Int16</A>, <A HREF="UInt16.html" TARGET="contents">UInt16</A>, <A HREF="Int32.html" TARGET="contents">Int32</A>, <A HREF="UInt32.html" TARGET="contents">UInt32</A>, <A HREF="Int64.html" TARGET="contents">Int64</A>, <A HREF="UInt64.html" TARGET="contents">UInt64</A>, <A HREF="Char.html" TARGET="contents">Char</A>, <A HREF="Double.html" TARGET="contents">Double</A>, and <A HREF="Single.html" TARGET="contents">Single</A>.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPublic%20Property"><H3>Type.IsPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the top-level <A HREF="Type.html" TARGET="contents">Type</A> is declared public.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the top-level <A HREF="Type.html" TARGET="contents">Type</A> is declared public; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSealed%20Property"><H3>Type.IsSealed Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsSealed { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is declared sealed.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is declared sealed; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSpecialName%20Property"><H3>Type.IsSpecialName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsSpecialName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> has a name that requires special handling.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> has a name that requires special handling; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Names that begin with or contain an
      underscore character (_) are examples of type names that
      might require special treatment by some tools. ]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsValueType%20Property"><H3>Type.IsValueType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsValueType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a value type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a value
   type (structure); otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns true for enumerations, but not for
      the <A HREF="Enum.html" TARGET="contents">Enum</A> type
      itself, which is a class. [<I>Note</I>: For an example
      that demonstrates this behavior, see System.Type.IsEnum
      .]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Module%20Property"><H3>Type.Module Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Module Module { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the module in which the current <A HREF="Type.html" TARGET="contents">Type</A> is defined.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/Module.html" TARGET="contents">Module</A> that reflects the module in which the current <A HREF="Type.html" TARGET="contents">Type</A> is defined.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Namespace%20Property"><H3>Type.Namespace Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string Namespace { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the namespace of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="String.html" TARGET="contents">String</A> containing the namespace of the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: A namespace is a 
      logical design-time naming convenience, used mainly to define scope in an
      application and organize classes and other types in a hierarchical structure.
      From the viewpoint of the system, there are no namespaces.]<P>

<P>

[<I>Behaviors</I>: This property is 
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.ReflectedType%20Property"><H3>Type.ReflectedType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override Type ReflectedType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the type that was used to obtain the current
      instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <CODE>Type</CODE>
 object
   through which the current instance was obtained.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: This property
      overrides System.Reflection.MemberInfo.ReflectedType.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.ReflectedType property. Although the method <I>m</I> is
   declared in <CODE>MyClassA</CODE>
, its reflected type is obtained from
<CODE>MyClassB</CODE>
 .<P>

<PRE>using System;
using System.Reflection;
public abstract class ReflectedTypeTest {
    public abstract class MyClassA {
        public abstract int m();
    }
    public abstract class MyClassB : MyClassA {
    }
    public static void Main(string[] args) {
        Console.WriteLine(&quot;Reflected type of m is {0}&quot;,
            typeof(MyClassB).GetMethod(&quot;m&quot;).ReflectedType);
    }
}
</PRE>
The output is <P>

<CODE>Reflected type of m is ReflectedTypeTest+MyClassB<P>

</CODE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.TypeHandle%20Property"><H3>Type.TypeHandle Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract RuntimeTypeHandle TypeHandle { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the handle for the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> for the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> encapsulates a pointer to an internal data structure that represents the type. This
   handle is unique during the process lifetime. The handle is valid only in
   the application domain in which it was obtained.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.TypeInitializer%20Property"><H3>Type.TypeInitializer Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo TypeInitializer { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the initializer for the<CODE> </CODE>
type
   represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> containing the name of the static
   constructor for the type represented by the current instance<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Type initializers are available through System.Type.GetMember(System.String),
System.Type.GetMembers, System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object), and System.Type.GetConstructors.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.UnderlyingSystemType%20Property"><H3>Type.UnderlyingSystemType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type UnderlyingSystemType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the system-supplied type
      that represents the current type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The underlying system type for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Behaviors</I>: As described 
      above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

</BODY>
</HTML>
