<HTML>
<HEAD>
<TITLE>System.Type Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Type Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract class Type : Object</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> (excluded)<BR>
&nbsp;&nbsp;&nbsp;&nbsp;Type<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
BCL
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Provides information about a type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 The <A HREF="Type.html" TARGET="contents">Type</A> class is abstract, as is the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A>
class and its subclasses <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A>, <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A>, <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>,
and <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A>. <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> and <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A>
are subclasses of <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>. The runtime
provides non-public implementations of these classes. [<I>Note</I>:  For example, System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is typed
as returning a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object. The
returned object is actually an instance of the non-public runtime type that
implements <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> .]<P>

<P>

A conforming CLI program which is written to run on only the Kernel profile 
   cannot subclass <A HREF="Type.html" TARGET="contents">Type</A>. [<I>Note</I>:  This only applies
   to conforming programs not conforming implementations.]<P>

<P>

 A <A HREF="Type.html" TARGET="contents">Type</A> object that represents a type is unique; that is, two
<A HREF="Type.html" TARGET="contents">Type</A> object 
references refer to the same object if and only if they represent the same type.
This allows for comparison of <A HREF="Type.html" TARGET="contents">Type</A>
objects using reference
equality.<P>

[<I>Note</I>:  An instance of <A HREF="Type.html" TARGET="contents">Type</A>
can represent any one of the following
types:<P>

<UL>
<LI>Classes</LI>
<LI>Value types</LI>
<LI>Arrays</LI>
<LI>Interfaces</LI>
<LI>Pointers</LI>
<LI>Enumerations</LI>
<LI>Constructed generic types and generic type definitions</LI>
<LI>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</LI>
</UL>
The following table shows what members of a base class are returned by the
   methods that return members of types, such as System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) and
System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]).<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Member Type</TH><TH>Static</TH></TR>
<TR><TD> Constructor</TD><TD>No</TD></TR>
<TR><TD> Field</TD><TD>No</TD></TR>
<TR><TD> Event</TD><TD>Not applicable</TD></TR>
<TR><TD> Method</TD><TD>No</TD></TR>
<TR><TD> Nested Type</TD><TD>No</TD></TR>
<TR><TD> Property</TD><TD>Not applicable</TD></TR>
</TABLE>
<P>

For reflection, properties and events are hide-by-name-and-signature. If a
   property has both a get and a set accessor in the base class, but the derived
   class has only a get accessor, the derived class property hides the base class
   property, and the setter on the base class will not be accessible. <P>

]<P>

The description of System.Type.IsGenericType  contains definitions for some important terms.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

Type Constructors<P>

<A HREF="#Type%20Constructor" TARGET="contents">Type Constructor</A><BR>
<P>

Type Methods<P>

<A HREF="#Type.Equals%20Method" TARGET="contents">Type.Equals Method</A><BR>
<A HREF="#Type.GetArrayRank%20Method" TARGET="contents">Type.GetArrayRank Method</A><BR>
<A HREF="#Type.GetAttributeFlagsImpl%20Method" TARGET="contents">Type.GetAttributeFlagsImpl Method</A><BR>
<A HREF="#Type.GetConstructor%28System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetConstructor%28System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetConstructor(System.Type[]) Method</A><BR>
<A HREF="#Type.GetConstructors%28%29%20Method" TARGET="contents">Type.GetConstructors() Method</A><BR>
<A HREF="#Type.GetConstructors%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetConstructors(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetDefaultMembers%20Method" TARGET="contents">Type.GetDefaultMembers Method</A><BR>
<A HREF="#Type.GetElementType%20Method" TARGET="contents">Type.GetElementType Method</A><BR>
<A HREF="#Type.GetEvent%28System.String%29%20Method" TARGET="contents">Type.GetEvent(System.String) Method</A><BR>
<A HREF="#Type.GetEvent%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetEvent(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetEvents%28%29%20Method" TARGET="contents">Type.GetEvents() Method</A><BR>
<A HREF="#Type.GetEvents%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetEvents(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetField%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetField(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetField%28System.String%29%20Method" TARGET="contents">Type.GetField(System.String) Method</A><BR>
<A HREF="#Type.GetFields%28%29%20Method" TARGET="contents">Type.GetFields() Method</A><BR>
<A HREF="#Type.GetFields%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetFields(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetGenericArguments%20Method" TARGET="contents">Type.GetGenericArguments Method</A><BR>
<A HREF="#Type.GetGenericParameterConstraints%20Method" TARGET="contents">Type.GetGenericParameterConstraints Method</A><BR>
<A HREF="#Type.GetGenericTypeDefinition%20Method" TARGET="contents">Type.GetGenericTypeDefinition Method</A><BR>
<A HREF="#Type.GetHashCode%20Method" TARGET="contents">Type.GetHashCode Method</A><BR>
<A HREF="#Type.GetInterface%28System.String%2C%20bool%29%20Method" TARGET="contents">Type.GetInterface(System.String, bool) Method</A><BR>
<A HREF="#Type.GetInterface%28System.String%29%20Method" TARGET="contents">Type.GetInterface(System.String) Method</A><BR>
<A HREF="#Type.GetInterfaces%20Method" TARGET="contents">Type.GetInterfaces Method</A><BR>
<A HREF="#Type.GetMember%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMember(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMember%28System.String%29%20Method" TARGET="contents">Type.GetMember(System.String) Method</A><BR>
<A HREF="#Type.GetMembers%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMembers(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMembers%28%29%20Method" TARGET="contents">Type.GetMembers() Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%29%20Method" TARGET="contents">Type.GetMethod(System.String) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Type[]) Method</A><BR>
<A HREF="#Type.GetMethod%28System.String%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetMethods%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetMethods(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetMethods%28%29%20Method" TARGET="contents">Type.GetMethods() Method</A><BR>
<A HREF="#Type.GetNestedType%28System.String%29%20Method" TARGET="contents">Type.GetNestedType(System.String) Method</A><BR>
<A HREF="#Type.GetNestedType%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetNestedType(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetNestedTypes%28%29%20Method" TARGET="contents">Type.GetNestedTypes() Method</A><BR>
<A HREF="#Type.GetNestedTypes%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetNestedTypes(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetProperties%28System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetProperties(System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetProperties%28%29%20Method" TARGET="contents">Type.GetProperties() Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type, System.Type[]) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type[]) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Type%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Type) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%29%20Method" TARGET="contents">Type.GetProperty(System.String) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Reflection.BindingFlags) Method</A><BR>
<A HREF="#Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method" TARGET="contents">Type.GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) Method</A><BR>
<A HREF="#Type.GetPropertyImpl%20Method" TARGET="contents">Type.GetPropertyImpl Method</A><BR>
<A HREF="#Type.GetType%28System.String%2C%20bool%2C%20bool%29%20Method" TARGET="contents">Type.GetType(System.String, bool, bool) Method</A><BR>
<A HREF="#Type.GetType%28System.String%2C%20bool%29%20Method" TARGET="contents">Type.GetType(System.String, bool) Method</A><BR>
<A HREF="#Type.GetType%28System.String%29%20Method" TARGET="contents">Type.GetType(System.String) Method</A><BR>
<A HREF="#Type.GetTypeArray%20Method" TARGET="contents">Type.GetTypeArray Method</A><BR>
<A HREF="#Type.GetTypeFromHandle%20Method" TARGET="contents">Type.GetTypeFromHandle Method</A><BR>
<A HREF="#Type.GetTypeHandle%20Method" TARGET="contents">Type.GetTypeHandle Method</A><BR>
<A HREF="#Type.HasElementTypeImpl%20Method" TARGET="contents">Type.HasElementTypeImpl Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) Method</A><BR>
<A HREF="#Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%2C%20System.Globalization.CultureInfo%2C%20System.String%5B%5D%29%20Method" TARGET="contents">Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[]) Method</A><BR>
<A HREF="#Type.IsArrayImpl%20Method" TARGET="contents">Type.IsArrayImpl Method</A><BR>
<A HREF="#Type.IsAssignableFrom%20Method" TARGET="contents">Type.IsAssignableFrom Method</A><BR>
<A HREF="#Type.IsByRefImpl%20Method" TARGET="contents">Type.IsByRefImpl Method</A><BR>
<A HREF="#Type.IsCOMObjectImpl%20Method" TARGET="contents">Type.IsCOMObjectImpl Method</A><BR>
<A HREF="#Type.IsInstanceOfType%20Method" TARGET="contents">Type.IsInstanceOfType Method</A><BR>
<A HREF="#Type.IsPointerImpl%20Method" TARGET="contents">Type.IsPointerImpl Method</A><BR>
<A HREF="#Type.IsPrimitiveImpl%20Method" TARGET="contents">Type.IsPrimitiveImpl Method</A><BR>
<A HREF="#Type.IsSubclassOf%20Method" TARGET="contents">Type.IsSubclassOf Method</A><BR>
<A HREF="#Type.MakeArrayType%28%29%20Method" TARGET="contents">Type.MakeArrayType() Method</A><BR>
<A HREF="#Type.MakeArrayType%28int%29%20Method" TARGET="contents">Type.MakeArrayType(int) Method</A><BR>
<A HREF="#Type.MakeByRefType%20Method" TARGET="contents">Type.MakeByRefType Method</A><BR>
<A HREF="#Type.MakeGenericType%20Method" TARGET="contents">Type.MakeGenericType Method</A><BR>
<A HREF="#Type.MakePointerType%20Method" TARGET="contents">Type.MakePointerType Method</A><BR>
<A HREF="#Type.ToString%20Method" TARGET="contents">Type.ToString Method</A><BR>
<P>

Type Fields<P>

<A HREF="#Type.Delimiter%20Field" TARGET="contents">Type.Delimiter Field</A><BR>
<A HREF="#Type.EmptyTypes%20Field" TARGET="contents">Type.EmptyTypes Field</A><BR>
<A HREF="#Type.Missing%20Field" TARGET="contents">Type.Missing Field</A><BR>
<P>

Type Properties<P>

<A HREF="#Type.Assembly%20Property" TARGET="contents">Type.Assembly Property</A><BR>
<A HREF="#Type.AssemblyQualifiedName%20Property" TARGET="contents">Type.AssemblyQualifiedName Property</A><BR>
<A HREF="#Type.Attributes%20Property" TARGET="contents">Type.Attributes Property</A><BR>
<A HREF="#Type.BaseType%20Property" TARGET="contents">Type.BaseType Property</A><BR>
<A HREF="#Type.ContainsGenericParameters%20Property" TARGET="contents">Type.ContainsGenericParameters Property</A><BR>
<A HREF="#Type.DeclaringMethod%20Property" TARGET="contents">Type.DeclaringMethod Property</A><BR>
<A HREF="#Type.DeclaringType%20Property" TARGET="contents">Type.DeclaringType Property</A><BR>
<A HREF="#Type.DefaultBinder%20Property" TARGET="contents">Type.DefaultBinder Property</A><BR>
<A HREF="#Type.FullName%20Property" TARGET="contents">Type.FullName Property</A><BR>
<A HREF="#Type.GenericParameterAttributes%20Property" TARGET="contents">Type.GenericParameterAttributes Property</A><BR>
<A HREF="#Type.GenericParameterPosition%20Property" TARGET="contents">Type.GenericParameterPosition Property</A><BR>
<A HREF="#Type.HasElementType%20Property" TARGET="contents">Type.HasElementType Property</A><BR>
<A HREF="#Type.IsAbstract%20Property" TARGET="contents">Type.IsAbstract Property</A><BR>
<A HREF="#Type.IsAnsiClass%20Property" TARGET="contents">Type.IsAnsiClass Property</A><BR>
<A HREF="#Type.IsArray%20Property" TARGET="contents">Type.IsArray Property</A><BR>
<A HREF="#Type.IsAutoClass%20Property" TARGET="contents">Type.IsAutoClass Property</A><BR>
<A HREF="#Type.IsAutoLayout%20Property" TARGET="contents">Type.IsAutoLayout Property</A><BR>
<A HREF="#Type.IsByRef%20Property" TARGET="contents">Type.IsByRef Property</A><BR>
<A HREF="#Type.IsClass%20Property" TARGET="contents">Type.IsClass Property</A><BR>
<A HREF="#Type.IsEnum%20Property" TARGET="contents">Type.IsEnum Property</A><BR>
<A HREF="#Type.IsExplicitLayout%20Property" TARGET="contents">Type.IsExplicitLayout Property</A><BR>
<A HREF="#Type.IsGenericParameter%20Property" TARGET="contents">Type.IsGenericParameter Property</A><BR>
<A HREF="#Type.IsGenericType%20Property" TARGET="contents">Type.IsGenericType Property</A><BR>
<A HREF="#Type.IsGenericTypeDefinition%20Property" TARGET="contents">Type.IsGenericTypeDefinition Property</A><BR>
<A HREF="#Type.IsImport%20Property" TARGET="contents">Type.IsImport Property</A><BR>
<A HREF="#Type.IsInterface%20Property" TARGET="contents">Type.IsInterface Property</A><BR>
<A HREF="#Type.IsLayoutSequential%20Property" TARGET="contents">Type.IsLayoutSequential Property</A><BR>
<A HREF="#Type.IsMarshalByRef%20Property" TARGET="contents">Type.IsMarshalByRef Property</A><BR>
<A HREF="#Type.IsNestedAssembly%20Property" TARGET="contents">Type.IsNestedAssembly Property</A><BR>
<A HREF="#Type.IsNestedFamANDAssem%20Property" TARGET="contents">Type.IsNestedFamANDAssem Property</A><BR>
<A HREF="#Type.IsNestedFamORAssem%20Property" TARGET="contents">Type.IsNestedFamORAssem Property</A><BR>
<A HREF="#Type.IsNestedFamily%20Property" TARGET="contents">Type.IsNestedFamily Property</A><BR>
<A HREF="#Type.IsNestedPrivate%20Property" TARGET="contents">Type.IsNestedPrivate Property</A><BR>
<A HREF="#Type.IsNestedPublic%20Property" TARGET="contents">Type.IsNestedPublic Property</A><BR>
<A HREF="#Type.IsNotPublic%20Property" TARGET="contents">Type.IsNotPublic Property</A><BR>
<A HREF="#Type.IsPointer%20Property" TARGET="contents">Type.IsPointer Property</A><BR>
<A HREF="#Type.IsPrimitive%20Property" TARGET="contents">Type.IsPrimitive Property</A><BR>
<A HREF="#Type.IsPublic%20Property" TARGET="contents">Type.IsPublic Property</A><BR>
<A HREF="#Type.IsSealed%20Property" TARGET="contents">Type.IsSealed Property</A><BR>
<A HREF="#Type.IsSpecialName%20Property" TARGET="contents">Type.IsSpecialName Property</A><BR>
<A HREF="#Type.IsUnicodeClass%20Property" TARGET="contents">Type.IsUnicodeClass Property</A><BR>
<A HREF="#Type.IsValueType%20Property" TARGET="contents">Type.IsValueType Property</A><BR>
<A HREF="#Type.Module%20Property" TARGET="contents">Type.Module Property</A><BR>
<A HREF="#Type.Namespace%20Property" TARGET="contents">Type.Namespace Property</A><BR>
<A HREF="#Type.ReflectedType%20Property" TARGET="contents">Type.ReflectedType Property</A><BR>
<A HREF="#Type.TypeHandle%20Property" TARGET="contents">Type.TypeHandle Property</A><BR>
<A HREF="#Type.TypeInitializer%20Property" TARGET="contents">Type.TypeInitializer Property</A><BR>
<A HREF="#Type.UnderlyingSystemType%20Property" TARGET="contents">Type.UnderlyingSystemType Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="Type%20Constructor"><H3>Type Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected Type();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Constructs a new instance of the <A HREF="Type.html" TARGET="contents">Type</A> class.
   <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Equals%20Method"><H3>Type.Equals Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool Equals(Type o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines if the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A> is the same as the
   underlying system type of the specified <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> whose underlying system type is to be compared with the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the underlying system type of <I>o</I> is the same
   as the underlying system type of the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetArrayRank%20Method"><H3>Type.GetArrayRank Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual int GetArrayRank();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the number of dimensions in the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Int32.html" TARGET="contents">Int32</A> containing the number of dimensions in the  current
<A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The current <A HREF="Type.html" TARGET="contents">Type</A> is  not an array.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetAttributeFlagsImpl%20Method"><H3>Type.GetAttributeFlagsImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract TypeAttributes GetAttributeFlagsImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived type implements the System.Type.Attributes
property and returns the attributes specified for the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> value that signifies the attributes of the
   type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is read-only.<P>

This method returns a <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> value that indicates the attributes set in
      the metadata of the type represented by the current
      instance.<P>

]<P>

[<I>Usage</I>: Use this property to determine the
   visibility, semantics, and layout format of the type represented by the
   current instance. Also use this property to determine if the type represented by
   the current instance has a special name.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructor%28System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetConstructor(System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a constructor defined in the type represented by the current
      instance. The parameters of the constructor match the specified argument types
      and modifiers, under the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> object that reflects the constructor
   that matches the specified criteria. If an exact match does not exist,
<I>binder</I> will attempt to coerce the parameter types specified in 
<I>types</I> to select a match. If <I>binder</I> is unable to select a 
   match, returns <CODE>null</CODE>
 . If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   constructors to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public constructors
      in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      constructors (that is, private and protected constructors) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the  <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> with the type parameters replaced by the appropriate type arguments. If the current instance represents an unassigned type parameter of a generic type or method, this method always returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructor%28System.Type%5B%5D%29%20Method"><H3>Type.GetConstructor(System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo GetConstructor(Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a public instance constructor defined in the type represented by the
      current instance. The parameters of the constructor match the specified argument
      types.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the constructor to be returned. Specify System.Type.EmptyTypes to obtain a constructor that takes no parameters.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> object representing the public instance
   constructor whose parameters match exactly the types in <I>types</I> , if found;
   otherwise, <CODE>null</CODE>
. If the type represented by the current
   instance is contained in a loaded assembly, the constructor that matches the
   specified criteria is not public, and the caller does not have sufficient
   permissions, returns <CODE>null</CODE>
. <P>

If the current instance represents a generic type, this method returns the  <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> with the type parameters replaced by the appropriate type arguments. If the current instance represents an unassigned type parameter of a generic type or method, this method always returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<I>types</I>, <CODE>null</CODE>
).<P>

<CODE></CODE>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructors%28%29%20Method"><H3>Type.GetConstructors() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo[] GetConstructors();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of the public constructors defined in the type represented
      by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects that reflect the public constructors
   defined in the type represented by the current instance. If no public
   constructors are defined in the type represented by the current instance, or if the current instance represents an unassigned type parameter of a generic type or method,
   returns an empty array.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents a generic type parameter, the System.Type.GetConstructorsmethod returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetConstructors is equivalent to System.Type.GetConstructors(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance).<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetConstructors%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetConstructors(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of constructors defined in the type represented by the
      current instance, under the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects that reflect the constructors that
   are defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I>. If System.Reflection.BindingFlags.NonPublic and System.Reflection.BindingFlags.Static are specified, this array
   includes the type initializer if it is defined. If no constructors meeting the
   constraints of <I>bindingAttr</I> are defined in the type represented by the
   current instance, or if the current instance represents an unassigned type parameter of a generic type or method, returns an empty array. If the type represented by the current
   instance is contained in a loaded assembly, the constructors that match the
   specified criteria are not public, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
 .<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents a generic type parameter, the System.Type.GetConstructorsmethod returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   constructors to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public constructors
      in the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      constructors (that is, private and protected constructors) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetDefaultMembers%20Method"><H3>Type.GetDefaultMembers Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual MemberInfo[] GetDefaultMembers();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the default members
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects reflecting the default members of the
   type represented by the current instance. If the type represented by the current
   instance does not have any default members, returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: The members returned
      by this method have the <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A>
      attribute.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetElementType%20Method"><H3>Type.GetElementType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetElementType();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the element type of the current <A HREF="Type.html" TARGET="contents">Type</A>
.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> that represents 
   the type used to create the current instance if the current
   instance represents an array, pointer, or an argument
   passed by reference. Otherwise, returns <CODE>null</CODE>

 if the current instance is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter of a generic type or method.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.GetElementType
method.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 int[] array = {1,2,3};
 Type t = array.GetType();
 Type t2 = t.GetElementType();
 Console.WriteLine(&quot;{0} element type is {1}&quot;,array, t2.ToString());

 TestType newMe = new TestType();
 t = newMe.GetType();
 t2 = t.GetElementType();
 Console.WriteLine(&quot;{0} element type is {1}&quot;, newMe, t2==null? &quot;null&quot; : t2.ToString());
 }
}
</PRE>
The output is<P>

<CODE>System.Int32[] element type is System.Int32<P>

TestType element type is null<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvent%28System.String%29%20Method"><H3>Type.GetEvent(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public EventInfo GetEvent(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the public event that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public event to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object 
   reflecting the public event that is named
<I>name</I> and is defined in the type represented by the current instance, if 
   found; otherwise, <CODE>null</CODE>
.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetEvent(System.String) is equivalent to System.Type.GetEvent(System.String)( <I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).<P>

The search for <I>name</I> is case-sensitive.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvent%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetEvent(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract EventInfo GetEvent(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the event that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the event to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> object reflecting the event that is named
<I>name</I>, is defined in the type represented by the current instance, and 
   matches the constraints of <I>bindingAttr</I>. If an event
   matching these criteria is not found, returns <CODE>null</CODE>
. If the event is not
   public, the current instance represents
   a type from a loaded assembly, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   events to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public events in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      events(that is, private and protected events) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the events
      declared on the type, not events that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvents%28%29%20Method"><H3>Type.GetEvents() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual EventInfo[] GetEvents();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the public events
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the public events
   defined in the type represented by the current instance. If no public events
   are defined in the type represented by the current instance, returns an empty
   array.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

[<I>Default</I>: This version of System.Type.GetEvents is
   equivalent to System.Type.GetEvents(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetEvents%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetEvents(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract EventInfo[] GetEvents(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the events that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns null. <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects that reflect the events that are
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no events match
   these constraints, returns an empty array. If the type reflected by the current
   instance is from a loaded assembly and the caller does not have permission to
   reflect on non-public objects in loaded assemblies, returns only public
   events.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/EventInfo.html" TARGET="contents">EventInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   events to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public events in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public
      events (that is, private and protected events) in the
      search.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the events of the class constraint; the events of all interface constraints; and the events of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetField%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetField(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract FieldInfo GetField(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that has the
   specified name, is defined in the type represented by the current instance, and
   matches the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the field to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that is named
<I>name</I>, is defined in the type represented by the current instance, and 
   matches the constraints of <I>bindingAttr</I>. If a field matching these criteria
   cannot be found, returns <CODE>null</CODE>
. If the field is not public, the current type is
   from a loaded assembly, and the caller does not have sufficient permission,
   returns <CODE>null</CODE>
.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> with the type parameters replaced by the appropriate type arguments.
<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   fields to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public fields in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public fields
      (that is, private and protected fields) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the fields
   declared in the type, not fields that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. <P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetField%28System.String%29%20Method"><H3>Type.GetField(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public FieldInfo GetField(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the field to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> object reflecting the field that is named
<I>name</I> and is defined in the type represented by the current instance, if 
   found; otherwise, <CODE>null</CODE>
. If the selected field is non-public, the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns <CODE>null</CODE>
.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> with the type parameters replaced by the appropriate type arguments.
<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetField(System.String,System.Reflection.BindingFlags) is equivalent to System.Type.GetField(System.String,System.Reflection.BindingFlags)(
<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance ).<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetFields%28%29%20Method"><H3>Type.GetFields() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public FieldInfo[] GetFields();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the public fields
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the public fields
   defined in the type represented by the current instance. If no public fields
   are defined in the type represented by the current instance, returns an empty
   array.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetFields is equivalent to System.Type.GetFields( System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetFields%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetFields(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract FieldInfo[] GetFields(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the fields that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects that reflect the fields that are
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no fields match
   these constraints, returns an empty array. If the type represented by the
   current instance is from a loaded assembly and the caller does not have
   sufficient permission to reflect on non-public objects in loaded assemblies,
   returns only public fields.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/FieldInfo.html" TARGET="contents">FieldInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   fields to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static in
      order to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public fields in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public fields
      (that is, private and protected fields) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the fields
      declared in the type, not fields that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the fields of the class constraint; the fields of all interface constraints; and the fields of any interfaces inherited from class or interface constraints. <P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetGenericArguments%20Method"><H3>Type.GetGenericArguments Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type[] GetGenericArguments()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="Type.html" TARGET="contents">Type</A> objects that represent the type arguments of a generic type or the type parameters of a generic type definition.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects that represent the type arguments of a generic type or the type parameters of a generic type definition. Returns an empty array if the current type is not a generic type. The array elements are returned in the order in which they appear in the list of type arguments for the generic type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current type is a closed constructed type, the array returned by the System.Type.GetGenericArguments method contains the type arguments that are bound to the type parameters. If the current type is a generic type definition, the array contains the type parameters. If the current type is an open constructed type in which some of the type parameters are bound to specific types, the array contains both type arguments and type parameters.<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.GenericParameterPosition.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetGenericParameterConstraints%20Method"><H3>Type.GetGenericParameterConstraints Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type[] GetGenericParameterConstraints()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="Type.html" TARGET="contents">Type</A> objects that represent the type constraints on the current generic type parameter.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects that represent the type constraints on the current generic type parameter.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current <A HREF="Type.html" TARGET="contents">Type</A> object is not a generic type parameter. That is, the System.Type.IsGenericParameter property returns <CODE>false</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Each constraint on a generic type parameter is expressed as a <A HREF="Type.html" TARGET="contents">Type</A> object. The first element of the array is the class constraint, if any. If a type parameter has no class constraint and no interface constraints, an empty array of <A HREF="Type.html" TARGET="contents">Type</A> is returned for that type parameter. Use System.Reflection.GenericParameterAttributes to get the special constraints.<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetGenericTypeDefinition%20Method"><H3>Type.GetGenericTypeDefinition Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type GetGenericTypeDefinition()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="Type.html" TARGET="contents">Type</A> object that represents a generic type from which the current type can be constructed.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing a generic type from which the current type can be constructed.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current type is not a generic type.  That is, System.Type.HasGenericArguments returns <CODE>false</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If two constructed types are created from the same generic type definition, the System.Type.GetGenericTypeDefinition method  returns the same <A HREF="Type.html" TARGET="contents">Type</A> object for both types.<P>

If you call System.Type.GetGenericTypeDefinition on a <A HREF="Type.html" TARGET="contents">Type</A> object that already represents a generic type definition, it returns the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

[<I>Note</I>: An array type whose element type is a generic type is not itself generic. Use System.Type.IsGenericType  to determine whether a type is generic before calling System.Type.GetGenericTypeDefinition.]<P>

<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.MakeGenericType.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetHashCode%20Method"><H3>Type.GetHashCode Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override int GetHashCode();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Generates a hash code for the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Int32.html" TARGET="contents">Int32</A>
containing the hash code for this instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The algorithm used to
      generate the hash code is unspecified.<P>

[<I>Note</I>: This method
      overrides System.Object.GetHashCode
      .]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterface%28System.String%2C%20bool%29%20Method"><H3>Type.GetInterface(System.String, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetInterface(string name, bool ignoreCase);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the specified interface,
      specifying whether to do a case-sensitive search.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the interface to return.</DD>
<DT>ignoreCase</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A> where<CODE> true</CODE>
 indicates that the name search is to be done case-insensitively, and <CODE>false</CODE>
 performs a case-sensitive search.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing
   the interface with the specified name, implemented or inherited by the type
   represented by the instance, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>The current instance represents a type that implements the same generic interface with different type arguments.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this method returns the <A HREF="Type.html" TARGET="contents">Type</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

[<I>Note</I>: Even with the introduction of generics, this method continues to return only non-generic members. To get the generic ones, one must call System.Type.GetInterfaces, and filter them out.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterface%28System.String%29%20Method"><H3>Type.GetInterface(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type GetInterface(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Searches for the interface with the specified name.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the interface to get. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="Type.html" TARGET="contents">Type</A> object
   representing the interface with the specified name, implemented or inherited by
   the current <A HREF="Type.html" TARGET="contents">Type</A>, if found; otherwise, <CODE>null</CODE>
.
   <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>The current instance represents a type that implements the same generic interface with different type arguments.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 The search for <I>name</I> is case-sensitive.
   <P>

If the current instance represents a generic type, this method returns the <A HREF="Type.html" TARGET="contents">Type</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

[<I>Note</I>: Even with the introduction of generics, this method continues to return only non-generic members. To get the generic ones, one must call System.Type.GetInterfaces, and filter them out.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetInterfaces%20Method"><H3>Type.GetInterfaces Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type[] GetInterfaces();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns all interfaces implemented or inherited by the
      type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing the interfaces implemented or
   inherited by the type represented by the current instance. If no interfaces are
   found, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this method returns the <A HREF="Type.html" TARGET="contents">Type</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: Even with the introduction of generics, the overloads of System.Type.GetInterface continue to return only non-generic members. To get the generic ones, one must call System.Type.GetInterfaces, and filter them out.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMember%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMember(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members defined in
   the type represented by the current instance that have the specified name
   and match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the member to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members
   named <I>name</I>, are defined in the type represented by the current instance
   and match the constraints of <I>bindingAttr</I> .
   If no members match these constraints, returns an empty array.
   If the selected member is non-public, the type reflected by the current instance is from a
   loaded assembly and the caller does not have sufficient permission to reflect on
   non-public objects in loaded assemblies, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
   declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMember%28System.String%29%20Method"><H3>Type.GetMember(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MemberInfo[] GetMember(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members that
   have the specified name and are defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the members to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members that
   are named <I>name</I> and are defined in the type represented by the current instance. If no public
   members with the specified name are defined in the type represented by the
   current instance, returns an empty array.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMember(System.String) is equivalent to System.Type.GetMember(System.String)( <I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public ).<P>

The search for <I>name</I> is case-sensitive.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMembers%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMembers(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MemberInfo[] GetMembers(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members that are
   defined in the type represented by the current instance and match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the members
   defined in the type represented by the current instance that match the
   constraints of <I>bindingAttr</I> . If no members match these constraints,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have sufficient permission to reflect
   on non-public objects in loaded assemblies, returns only public members.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMembers%28%29%20Method"><H3>Type.GetMembers() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MemberInfo[] GetMembers();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects that reflect the public members
   defined in the type represented by the current instance. If no public members
   are defined in the type represented by the current instance, returns an empty
   array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMembers is equivalent to System.Type.GetMembers(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MemberInfo.html" TARGET="contents">MemberInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the members of the class constraint, or the members of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the members of all interface constraints; and the members of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the method that matches the
   specified criteria and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the method to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects
   the method defined in the type represented by the current instance that
   matches the specified criteria. If no method matching the specified criteria is found, returns
<CODE>null</CODE>
 . If the 
   selected method is non-public, the type reflected by
   the current instance is from a loaded assembly, and the caller
   does not have permission to reflect on non-public objects in loaded assemblies,
   returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMethod(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the method that has the
   specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the method to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object
   that reflects the method that is defined
   in the type represented by the current instance and matches the specified
   criteria, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I> ,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%29%20Method"><H3>Type.GetMethod(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting the public method that is
   defined in the type represented by the current instance and has the specified
   name, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<CODE>null</CODE>
, <CODE>null</CODE>
).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method defined in
   the type represented by the current instance that has the specified name and parameter
   information.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting
   the public method defined in the type represented by the current instance
   that matches the specified criteria. If no public method matching the specified criteria
   is found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
,
<I>types</I>, <CODE>null</CODE>
).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethod%28System.String%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetMethod(System.String, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object that reflects the public method that
   has the specified name and is defined in the type represented by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public method to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the method to be returned.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> object reflecting the public method that is
   defined in the type represented by the current instance and matches the
   specified criteria, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one method matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default binder does not process
      <I>modifier</I> . <P>

The search for <I>name</I> is case-sensitive.<P>

This version of System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) ( <I>name</I>, System.Reflection.BindingFlags.Public |System.Reflection.BindingFlags.Static |System.Reflection.BindingFlags.Instance , <CODE>null</CODE>
,<I> types</I> , <I>modifiers</I>).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethods%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetMethods(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MethodInfo[] GetMethods(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects that reflect the methods defined in the type
   represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects reflecting the methods defined in the type
   represented by the current instance that match the constraints of
<I>bindingAttr</I> . If no such methods found, returns an 
   empty array. If the type represented by the current instance is from a loaded
   assembly and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns only public methods.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetMethods%28%29%20Method"><H3>Type.GetMethods() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public MethodInfo[] GetMethods();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the public methods defined in the type represented by the current
      instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects reflecting the public methods defined in the type represented by the current instance. If no methods are found, returns an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetMethods is equivalent to System.Type.GetMethods( System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the methods of the class constraint, or the methods of <A HREF="Object.html" TARGET="contents">Object</A> if there is no class constraint; the methods of all interface constraints; and the methods of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedType%28System.String%29%20Method"><H3>Type.GetNestedType(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type GetNestedType(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the public nested type defined in the type represented by the current instance<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public nested type to return. Specify the unqualified name of the nested type. [<I>Note</I>: For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType(&quot;B&quot;). ]<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object
   representing the public nested type with the specified
   name, if found; otherwise, <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The search for <I>name</I> is case-sensitive.<P>

Use the simple name of the nested class for <I>name</I>; do not qualify it with the name of the outer class. CLS rules require a naming pattern for nested types; see Partition I.<P>

If the current instance represents an unassigned type parameter of a generic type or method definition, this method does not search the nested types of the class constraint.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments. For example, passing &quot;MyGenericNestedType&lt;int&gt;&quot; to this method searches for a nested type with the text name &quot;MyGenericNestedType&lt;int&gt;&quot;, rather than for a nested type named MyGenericNestedType that has one generic argument of type <CODE>int</CODE>
.]<P>

[<I>Note</I>: If the nested type is generic, what is returned is always a generic type definition.]<P>

<P>

For information on constructing nested generic types from their generic type definitions, see the  System.Type.MakeGenericType<CODE>(System.Type[])</CODE>
 method.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedType%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetNestedType(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type GetNestedType(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns a nested types defined in the type represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the nested type to return. Specify the unqualified name of the nested type. [<I>Note</I>: For example, for a type B nested within A, if typeA represents the type object for A, the correct invocation is typeA.GetNestedType(&quot;B&quot;).]<P>

</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing the nested type that
   matches the specified criteria, if found; otherwise, <CODE>null</CODE>
. If the selected nested
   type is non-public, the current instance represents a type contained in a loaded
   assembly and the caller does not have sufficient permissions, returns
<CODE>null</CODE>
 
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.<P>

[<I>Note</I>: The <I>name</I> parameter cannot include type arguments.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedTypes%28%29%20Method"><H3>Type.GetNestedTypes() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public Type[] GetNestedTypes();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns all the public types nested within the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing all public types nested within the type
   represented by the current instance, if any. Otherwise, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetNestedTypes is equivalent to System.Type.GetNestedTypes(System.Reflection.BindingFlags.Public).<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetNestedTypes%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetNestedTypes(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type[] GetNestedTypes(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns an array containing the nested types defined in
      the type represented by the current instance that match the specified binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing all types nested within the type
   represented by the current instance that match the specified binding constraints,
   if any. Otherwise, returns an empty <A HREF="Type.html" TARGET="contents">Type</A> array. If the type reflected by the current instance is
   contained in a loaded assembly, the type that matches the specified criteria is
   not public, and the caller does not have sufficient permission, returns only
   public types.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the nested types of the class constraint.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperties%28System.Reflection.BindingFlags%29%20Method"><H3>Type.GetProperties(System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract PropertyInfo[] GetProperties(BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the properties
   defined for the type represented by the current instance that match the specified
   binding constraints.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the properties
   defined in the type represented by the current instance and match the
   constraints of <I>bindingAttr</I> . If no matching properties are found,
   returns an empty array. If the type represented by the current instance is from
   a loaded assembly and the caller does not have permission to reflect on
   non-public objects in loaded assemblies, returns only public properties.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members
      declared in the type, not members that were simply inherited.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

[<I>Behaviors</I>: A property is considered by
   reflection to be <CODE>public</CODE>
 if it has at least one accessor that is
<CODE>public</CODE>
 . Otherwise, the property is not
<CODE>public</CODE>
.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperties%28%29%20Method"><H3>Type.GetProperties() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo[] GetProperties();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects that reflect the public properties
   defined in the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> 
objects that reflect the public properties defined in the type
represented by the current instance. If no public properties are found, returns
an empty array.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperties(System.Reflection.BindingFlags) is equivalent to System.Type.GetProperties(System.Reflection.BindingFlags)(
System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Public ).<P>

A property is considered by reflection
   to be <CODE>public</CODE>
 if it has at least one accessor that is
<CODE>public</CODE>
. Otherwise, the property is considered to be not 
<CODE>public</CODE>
.<P>

If the current instance represents a generic type, this method returns the <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> objects with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Type, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type returnType, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public property
   defined in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public property to be returned.</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the public property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes for a property that is not indexed.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object
   reflecting the public property defined in the type represented by
   the current instance that matches the specified criteria. If no matching property is
   found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <I>returnTypes</I>, <I>types</I>, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed
   property using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Type[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type[] types);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the public property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <CODE>null</CODE>
, <I>types</I>, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

Different programming languages use different syntax to 
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Type%29%20Method"><H3>Type.GetProperty(System.String, System.Type) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, Type returnType);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> 
object that reflects the public property defined in the type represented by the current
instance that matches the specified search criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined 
   on the type represented by the current instance that matches the specified
   criteria. If no matching property is found, returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <I>returnType</I>, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%29%20Method"><H3>Type.GetProperty(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the public
   property defined in the type represented by the current instance that has the specified
   name.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object reflecting the public property defined 
   on the type represented by the current instance that has the specified name. If
   no matching property is found, returns <CODE>null</CODE>
 . <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%29%20Method"><H3>Type.GetProperty(System.String, System.Reflection.BindingFlags) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, BindingFlags bindingAttr);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A>
object reflecting the property defined in the type represented by
the current instance that matches the specified criteria. If no matching property is
found, returns <CODE>null</CODE>
 . If the type reflected by the current
instance is contained in a loaded assembly, the property that matches the
specified criteria is not public, and the caller does not have sufficient
permission, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I>,
<CODE>null</CODE>
, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

The search for <I>name</I> is case-sensitive.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetProperty%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Type%2C%20System.Type%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%29%20Method"><H3>Type.GetProperty(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Type, System.Type[], System.Reflection.ParameterModifier[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property
   defined in the type represented by the current instance that matches the specified search
   criteria .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object
   reflecting the property that is defined in the type represented by the
   current instance and matches the specified criteria. If no matching property is
   found, returns <CODE>null</CODE>
 . If the type reflected by the current
   instance is contained in a loaded assembly, the property that matches the
   specified criteria is not public, and the caller does not have sufficient
   permission, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

This version of System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) is equivalent to System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])(<I>name</I>, <I>bindingAttr</I>, <I>binder</I>,
<I>returnType</I>, <I>types</I>, <I>modifiers</I>).<P>

 Different programming languages use different syntax to
   specify indexed properties. Internally, this property is referred to by the name
   &quot;Item&quot; in the metadata. Therefore, any attempt to retrieve an indexed property
   using reflection is required to specify this internal
   name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.<P>

If the current instance represents a generic type, this method returns the <CODE>System.Reflection.PropertyInfo</CODE>
 with the type parameters replaced by the appropriate type arguments.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this method searches the properties of the class constraint; the properties of all interface constraints; and the properties of any interfaces inherited from class or interface constraints.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetPropertyImpl%20Method"><H3>Type.GetPropertyImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class implements the 
   System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[]) 
   method and returns a <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object that reflects the property defined
   in the type represented by the current instance that matches the specified search
   criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the property to be returned.</DD>
<DT>bindingAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, this method returns <CODE>null</CODE>
 . <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT> returnType</DT>
<DD>A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of the property to be returned.</DD>
<DT>types</DT>
<DD>An array of <A HREF="Type.html" TARGET="contents">Type</A> objects. The elements in the array are of the same number, in the same order, and represent the same types as the parameters for the indexer to be returned. Specify System.Type.EmptyTypes to obtain a property that is not indexed.<P>

</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/PropertyInfo.html" TARGET="contents">PropertyInfo</A> object representing the property that matches the
   specified search criteria, if found; otherwise, <CODE>null</CODE>
. If the type reflected by the current
   instance is from a loaded assembly, the matching property is not
   public, and the caller does not have permission to reflect on non-public
   objects in loaded assemblies, returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one property matching the specified criteria was found.</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> or <I>types</I> is <CODE>null</CODE>
, or at least one of the elements in <I>types</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>types</I> has more than one dimension.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
   members to include in the search:<P>

<UL>
<LI>
      
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>:  Different
   programming languages use different syntax to specify indexed properties.
   Internally, this property is referred to by the name &quot;Item&quot; in the metadata.
   Therefore, any attempt to retrieve an indexed property using reflection is required to
   specify this internal name in order for the <CODE>PropertyInfo</CODE>
 to be returned correctly.
]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%2C%20bool%2C%20bool%29%20Method"><H3>Type.GetType(System.String, bool, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A>
with the specified name, optionally performing a case-insensitive search
and optionally throwing an exception if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
<DT>throwOnError</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify <CODE>true</CODE>
 to throw a <A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A> if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>. Specify <CODE>false</CODE>
 to ignore errors while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</DD>
<DT>ignoreCase</DT>
<DD> A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify<CODE> true</CODE>
 to perform a case-insensitive search for <I>typeName.</I> Specify <CODE>false</CODE>
 to perform a case-sensitive search for <I>typeName</I> .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
. If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
<TR><TD><A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A></TD><TD><I>throwOnError</I> is <CODE>true</CODE>
 and an error was encountered while loading the selected <A HREF="Type.html" TARGET="contents">Type</A>.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
<I>typeName</I> can be a simple
   type name, a fully qualified name, or a complex name that includes an assembly
   name. [<I>Note</I>: System.Type.AssemblyQualifiedName
   returns a fully qualified type name including nested types,
  the assembly name, and generic type arguments. ]<P>

<P>

If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method searches in the
calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.<P>

[<I>Note</I>: <CODE></CODE>
<P>

 The following table shows calls to
<CODE>GetType</CODE>
 for various types.  (Some long strings have been wrapped to fit in the right column.)<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>To Get this Type</TH><TH>Use this String</TH></TR>
<TR><TD>An unmanaged pointer to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType*&quot;)</CODE></TD></TR>
<TR><TD>An unmanaged pointer to a pointer to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType**&quot;)</CODE></TD></TR>
<TR><TD>A managed pointer or reference to <CODE>MyType</CODE>
</TD><TD><CODE>Type.GetType(&quot;MyType&amp;&quot;)</CODE>Note that unlike pointers, references are limited to one level.</TD></TR>
<TR><TD>A parent class and a nested class</TD><TD><CODE>Type.GetType(&quot;MyParentClass+MyNestedClass&quot;)</CODE></TD></TR>
<TR><TD>A one-dimensional array with a lower bound of 0</TD><TD><CODE>Type.GetType(&quot;MyArray[]&quot;)</CODE></TD></TR>
<TR><TD>A one-dimensional array with an unknown lower bound</TD><TD><CODE>Type.GetType(&quot;MyArray[*]&quot;)</CODE></TD></TR>
<TR><TD>An n-dimensional array</TD><TD>A comma (,) inside the brackets a total of n-1 times. For example, <CODE>System.Object[,,]</CODE> represents a three-dimensional <CODE>Object</CODE>
 array.</TD></TR>
<TR><TD>A two-dimensional array&apos;s array</TD><TD><CODE>Type.GetType(&quot;MyArray[][]&quot;)</CODE></TD></TR>
<TR><TD>A rectangular two-dimensional array with unknown lower bounds</TD><TD><CODE>Type.GetType(&quot;MyArray[*,*]&quot;) </CODE>or <CODE> Type.GetType(&quot;MyArray[,]&quot;)</CODE></TD></TR>
<TR><TD>A generic type with one type argument</TD><TD><CODE>Type.GetType(&quot;MyGenericType[MyType]&quot;)</CODE></TD></TR>
<TR><TD>A generic type with two type arguments</TD><TD><CODE>Type.GetType(&quot;MyGenericType[MyType,AnotherType]&quot;)</CODE></TD></TR>
<TR><TD>A generic type with two assembly-qualified type arguments</TD><TD><CODE>Type.GetType(&quot;MyGenericType[[MyType,MyAssembly],
[AnotherType,AnotherAssembly]]&quot;)
</CODE></TD></TR>
<TR><TD>An assembly-qualified generic type with an assembly-qualified type argument</TD><TD><CODE>Type.GetType(&quot;MyGenericType[[MyType,MyAssembly]]
,MyGenericTypeAssembly&quot;)</CODE></TD></TR>
<TR><TD>A generic type whose type argument is a generic type with two type arguments</TD><TD><CODE>Type.GetType(&quot;MyGenericType[AnotherGenericType
[MyType,AnotherType]]&quot;)
</CODE></TD></TR>
</TABLE>
]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%2C%20bool%29%20Method"><H3>Type.GetType(System.String, bool) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName, bool throwOnError);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, optionally throwing an
   exception if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the case-sensitive name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
<DT>throwOnError</DT>
<DD>A <A HREF="Boolean.html" TARGET="contents">Boolean</A>. Specify <CODE>true</CODE>
 to throw a <A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A> if an error occurs while loading the <A HREF="Type.html" TARGET="contents">Type</A>. Specify <CODE>false</CODE>
 to ignore errors while loading the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
 . If the
   requested type is non-public and the caller does not have permission to reflect non-public objects
   outside the current assembly, this method returns <CODE>null</CODE>
 .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
<TR><TD><A HREF="TypeLoadException.html" TARGET="contents">TypeLoadException</A></TD><TD><I>throwOnError</I> is <CODE>true</CODE>
 and an error was encountered while loading the <A HREF="Type.html" TARGET="contents">Type</A>.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Type.GetType(System.String,System.Boolean,System.Boolean)(<I>name</I>, <I>throwOnError</I>, 
<CODE>false</CODE>
).<P>

<I>typeName</I> can be a simple
type name, a fully qualified name, or a complex name that includes an assembly
name specification. If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method searches in the
calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.<P>

[<I>Note</I>: System.Type.AssemblyQualifiedName can return a fully
qualified type name including nested types, the assembly name, and generic type arguments. For complete
details, see System.Type.GetType(System.String,System.Boolean,System.Boolean)(<A HREF="String.html" TARGET="contents">String</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>). ]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetType%28System.String%29%20Method"><H3>Type.GetType(System.String) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetType(string typeName);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the <A HREF="Type.html" TARGET="contents">Type</A> with the specified name.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeName</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the case-sensitive name of the <A HREF="Type.html" TARGET="contents">Type</A> to return.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> with the specified name, if found; otherwise, <CODE>null</CODE>
. If the
   requested type is non-public and the caller does not have permission to reflect
   non-public objects outside the current assembly, this method returns
<CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeName</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method is equivalent to System.Type.GetType(System.String,System.Boolean,System.Boolean)(<I>name</I>, <CODE>false</CODE>
,
<CODE>false</CODE>
).<P>

<I>typeName</I> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification. If <I>typeName</I> includes only the name of the <A HREF="Type.html" TARGET="contents">Type</A>, this method
searches in the calling object&apos;s assembly, then in the mscorlib.dll assembly. If
<I>typeName</I> 
is fully qualified with the partial or complete assembly name, this method
searches in the specified assembly.<P>

[<I>Note</I>: System.Type.AssemblyQualifiedName can return a fully qualified type name including
   nested types, the assembly name, and generic type arguments. For complete details, see System.Type.GetType(System.String,System.Boolean,System.Boolean)(<A HREF="String.html" TARGET="contents">String</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Boolean.html" TARGET="contents">Boolean</A>).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeArray%20Method"><H3>Type.GetTypeArray Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type[] GetTypeArray(object[] args);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the types of the objects in the specified array.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>args</DT>
<DD>An array of objects whose types are to be returned. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 An array of <A HREF="Type.html" TARGET="contents">Type</A> objects representing the types of the corresponding
   elements in <I>args</I>. If a requested type is not public
   and the caller does not have permission to
   reflect non-public objects outside the current assembly, the corresponding element in the
   array returned by this method will be <CODE>null</CODE>
.
   <P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>args</I> is <CODE>null</CODE>
. </TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The type initializers were invoked and at least one threw an exception. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeFromHandle%20Method"><H3>Type.GetTypeFromHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Type GetTypeFromHandle(RuntimeTypeHandle handle);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the <A HREF="Type.html" TARGET="contents">Type</A> referenced by the specified type handle.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>handle</DT>
<DD>The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> object that refers to the desired <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> referenced by the specified <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A>.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>handle</I> is <CODE>null</CODE>
.</TD></TR>
<TR><TD><A HREF="../System/Security/SecurityException.html" TARGET="contents">SecurityException</A></TD><TD>The requested type is non-public and outside the current assembly, and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>A type initializer was invoked and threw an exception.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handles are valid only in the application domain in which they were obtained. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GetTypeHandle%20Method"><H3>Type.GetTypeHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static RuntimeTypeHandle GetTypeHandle(object o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns the handle for the <A HREF="Type.html" TARGET="contents">Type</A> of the specified object.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The object for which to get the type handle.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> for the <A HREF="Type.html" TARGET="contents">Type</A> of the specified <A HREF="Object.html" TARGET="contents">Object</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handle is valid only in the application domain in which it was obtained. <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.HasElementTypeImpl%20Method"><H3>Type.HasElementTypeImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool HasElementTypeImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.HasElementType property and
   determines whether the current <A HREF="Type.html" TARGET="contents">Type</A> encompasses or
   refers to another type; that is,
   whether the current <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by
   reference.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: For example, 
   System.Type.GetType(System.String,System.Boolean,System.Boolean) (&quot;System.Int32[]&quot;).HasElementTypeImpl returns
   <CODE>true</CODE>
, but System.Type.GetType(System.String,System.Boolean,System.Boolean) (&quot;System.Int32&quot;).HasElementTypeImpl returns
   <CODE>false</CODE>
. System.Type.HasElementTypeImpl also returns <CODE>true</CODE>
 for &quot;System.Int32*&quot; and &quot;System.Int32&amp;&quot;.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Globalization.CultureInfo) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, CultureInfo culture);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the specified member, using the specified binding constraints
      and matching the specified argument list and culture.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default. <P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <CODE>null</CODE>
 for a member that has no parameters.</DD>
<DT>culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>n</I><I>ame</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethodand at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria was not found.<P>

-or-<P>

The current instance object represents a type that contains open type parameters (that is, <P>

System.Type.ContainsGenericParameters returns <P>

<CODE>true</CODE>
).<P>

</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) is equivalent to System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(
<I>name</I>, <I>invokeAttr</I>, <I>binder</I>, <I>target</I>, <I>args</I>, 
<CODE>null</CODE>
, <I>culture</I>, <CODE>null</CODE>
 ). <P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 For an example that demonstrates
   System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) , see System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(
   <A HREF="String.html" TARGET="contents">String</A>, <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>,
   <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A>, <A HREF="Object.html" TARGET="contents">Object</A>, <A HREF="Object.html" TARGET="contents">Object</A>[], <A HREF="../System/Reflection/ParameterModifier.html" TARGET="contents">ParameterModifier</A>[], <A HREF="../System/Globalization/CultureInfo.html" TARGET="contents">CultureInfo</A>, <A HREF="String.html" TARGET="contents">String</A>[]).
      <P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the specified member, using the specified binding constraints and
      matching the specified argument list.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default.</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> object that defines a set of properties and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to use the System.Type.DefaultBinder .<P>

</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound. Specify an empty array or <CODE>null</CODE>
 for a member that has no parameters.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked member. If the invoked member does
not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethod and at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria cannot be found.<P>

-or-<P>

The current instance object represents a type that contains open type parameters (that is, <P>

System.Type.ContainsGenericParameters returns <P>

<CODE>true</CODE>
).<P>

</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) is equivalent to System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])(<I>name</I>, <I>invokeAttr</I>, <I>binder</I>,
<I>target</I>, <I>args</I>, <CODE>null</CODE>
, <CODE>null</CODE>
, 
<CODE>null</CODE>
).<P>

[<I>Note</I>: For a demonstration of the use of
System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]), see the example for System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])( 
<A HREF="String.html" TARGET="contents">String</A>, <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>, 
<A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A>, <A HREF="Object.html" TARGET="contents">Object</A>, <A HREF="Object.html" TARGET="contents">Object</A>[], <A HREF="../System/Reflection/ParameterModifier.html" TARGET="contents">ParameterModifier</A>[], <A HREF="../System/Globalization/CultureInfo.html" TARGET="contents">CultureInfo</A>, <A HREF="String.html" TARGET="contents">String</A>[]).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.InvokeMember%28System.String%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%2C%20System.Object%5B%5D%2C%20System.Reflection.ParameterModifier%5B%5D%2C%20System.Globalization.CultureInfo%2C%20System.String%5B%5D%29%20Method"><H3>Type.InvokeMember(System.String, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object, System.Object[], System.Reflection.ParameterModifier[], System.Globalization.CultureInfo, System.String[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, object[] args, ParameterModifier[] modifiers, CultureInfo culture, string[] namedParameters);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Invokes or
      accesses a member defined on the type represented by the current instance
      that matches the specified binding criteria.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>name</DT>
<DD>A <A HREF="String.html" TARGET="contents">String</A> containing the name of the constructor or method to invoke, or property or field to access. If the type represented by the current instance has a default member, specify System.String.Empty to invoke that member. [<I>Note</I>: For more information on default members, see <A HREF="../System/Reflection/DefaultMemberAttribute.html" TARGET="contents">DefaultMemberAttribute</A> .]<P>

<P>

</DD>
<DT>invokeAttr</DT>
<DD>A bitwise combination of <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values that control the binding process. If zero is specified, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance is used by default.<P>

</DD>
<DT>binder</DT>
<DD>A <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> that defines a set of properties, and enables the binding, coercion of argument types, and invocation of members using reflection. Specify <CODE>null</CODE>
 to useSystem.Type.DefaultBinder.</DD>
<DT>target</DT>
<DD>A <A HREF="Object.html" TARGET="contents">Object</A> on which to invoke the member that matches the other specified criteria. If the matching member is <CODE>static</CODE>
 , this parameter is ignored.</DD>
<DT>args</DT>
<DD>An array of objects containing the arguments to pass to the member to be invoked. The elements of this array are of the same number and in the same order by assignment-compatible type as specified by the contract of the member to be bound if and only if <I>nameParameters</I> is <CODE>null</CODE>
. If <I>namedParameters</I> is not <CODE>null</CODE>
, the order of the elements in <I>args</I> corresponds to the order of the parameters specified in <I>namedParameters</I>. Specify an empty array or <CODE>null</CODE>
 for a member that takes no parameters.</DD>
<DT>modifiers</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
<DT>culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
<DT>namedParameters</DT>
<DD>An array of <A HREF="String.html" TARGET="contents">String</A> objects containing the names of the parameters to which the values in <I>args</I> are passed. These names are processed in a case-sensitive manner and have a one-to-one correspondence with the elements of <I>args</I>. Specify an empty array or <CODE>null</CODE>
 for a member that takes no parameters. Specify <CODE>null</CODE>
 to have this parameter ignored.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Object.html" TARGET="contents">Object</A>
containing the return value of the invoked or accessed member. If the member
does not have a return value, returns a <A HREF="Object.html" TARGET="contents">Object</A> containing <A HREF="Void.html" TARGET="contents">Void</A> .<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>name</I> is <CODE>null</CODE>
.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD><I>args</I> has more than one dimension.<P>

-or-<P>

<I>invokeAttr</I> is not a valid <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> value.<P>

-or-<P>

The member to be invoked is a constructor and System.Reflection.BindingFlags.CreateInstance is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be invoked is a method that is not a type initializer or instance constructor, and System.Reflection.BindingFlags.InvokeMethod is not specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a field, and neither System.Reflection.BindingFlags.GetField nor System.Reflection.BindingFlags.SetField is specified in <I>invokeAttr</I>.<P>

-or-<P>

The member to be accessed is a property, and neither System.Reflection.BindingFlags.GetProperty nor System.Reflection.BindingFlags.SetProperty is specified in <I>invokeAttr</I>.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.CreateInstance and at least one of System.Reflection.BindingFlags.InvokeMethod, System.Reflection.BindingFlags.GetField, System.Reflection.BindingFlags.SetField, System.Reflection.BindingFlags.GetProperty, or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetField and System.Reflection.BindingFlags.SetField.<P>

-or-<P>

<I>invokeAttr</I> contains both System.Reflection.BindingFlags.GetProperty and System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.InvokeMethod and at least one of System.Reflection.BindingFlags.SetField or System.Reflection.BindingFlags.SetProperty.<P>

-or-<P>

<I>invokeAttr</I> contains System.Reflection.BindingFlags.SetField and <I>args</I> has more than one element.<P>

-or-<P>

<I>namedParameters</I>.Length &gt; <I>args</I>.Length .<P>

-or-<P>

At least one element in <I>namedParameters</I> is <CODE>null</CODE>
.<P>

-or-<P>

At least one element in <I>args</I> is not assignment-compatible with the corresponding parameter in <I>namedParameters</I>.<P>

</TD></TR>
<TR><TD><A HREF="MissingFieldException.html" TARGET="contents">MissingFieldException</A></TD><TD>A field or property matching the specified criteria was not found.</TD></TR>
<TR><TD><A HREF="MissingMethodException.html" TARGET="contents">MissingMethodException</A></TD><TD>A method matching the specified criteria cannot be found.<P>

-or-<P>

The current instance object represents a type that contains open type parameters (that is, <P>

System.Type.ContainsGenericParameters returns <P>

<CODE>true</CODE>
).<P>

</TD></TR>
<TR><TD><A HREF="MethodAccessException.html" TARGET="contents">MethodAccessException</A></TD><TD>The requested member is non-public and the caller does not have the required permission.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetException.html" TARGET="contents">TargetException</A></TD><TD>The member matching the specified criteria cannot be invoked on <I>target</I>.</TD></TR>
<TR><TD><A HREF="../System/Reflection/TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The member matching the specified criteria threw an exception.</TD></TR>
<TR><TD><A HREF="../System/Reflection/AmbiguousMatchException.html" TARGET="contents">AmbiguousMatchException</A></TD><TD>More than one member matches the specified criteria.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) calls a constructor or a method , gets or sets a property , gets or sets a field, or gets or sets an element of an array.<P>

 The binder finds all of the matching members. These
   members are found based upon the type of binding specified by <I>invokeAttr</I> . The System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@) is
   responsible for selecting the method to be invoked. The default binder selects
   the most specific match. The set of members is then filtered by name, number of
   arguments, and a set of search modifiers defined in the binder. After the member is selected, it is invoked or accessed.
   Accessibility is checked at that point. Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.<P>

The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> are used to define which
members to include in the search:<P>

<UL>
<LI>
      Specify either System.Reflection.BindingFlags.Instance or System.Reflection.BindingFlags.Static
      to get a return value other than <CODE>null</CODE>
.</LI>
<LI>
      Specify System.Reflection.BindingFlags.Public to include public members in
      the search.</LI>
<LI>
      Specify System.Reflection.BindingFlags.NonPublic to include non-public members
      (that is, private and protected members) in the search.</LI>
</UL>
The following <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> values can be used to change how the
search works:<P>

<UL>
<LI>System.Reflection.BindingFlags.DeclaredOnly to search only the members 
      declared in the type, not members that were simply inherited.</LI>
<LI>System.Reflection.BindingFlags.IgnoreCase to ignore the case of
   <I>name</I>.</LI>
</UL>
[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A>.]<P>

<P>

[<I>Behaviors</I>: Each parameter in the <I>namedParameters</I> array is assigned the value in the
   corresponding element in the <I>args</I> array. If the length of <I>args</I> is
   greater than the length of <I>namedParameters</I>, the remaining argument values
   are passed in order.<P>

A member will be found only
   if the number of parameters in the member declaration equals the number of
   arguments in the args array (unless default arguments are defined on the
   member). Also, The type of each argument is required to be convertible by
   the binder to the type
   of the parameter. <P>

It is required that the caller specify values for <I>invokeAttr</I> as
follows:<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Action</TH><TH>BindingFlags</TH></TR>
<TR><TD> Invoke a constructor. </TD><TD>System.Reflection.BindingFlags.CreateInstance. This
      flag is not valid with the other flags in this table. If this flag is
      specified, <I>name</I> is ignored. </TD></TR>
<TR><TD> Invoke a method. </TD><TD>System.Reflection.BindingFlags.InvokeMethod. This
   flag if not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.SetField, or System.Reflection.BindingFlags.SetProperty. </TD></TR>
<TR><TD> Define a field value. </TD><TD>System.Reflection.BindingFlags.SetField. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.GetField.</TD></TR>
<TR><TD> Return a field value. </TD><TD>System.Reflection.BindingFlags.GetField. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.SetField.</TD></TR>
<TR><TD> Set a property. </TD><TD>System.Reflection.BindingFlags.SetProperty. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.GetProperty.</TD></TR>
<TR><TD> Get a property.</TD><TD>System.Reflection.BindingFlags.GetProperty. This
   flag is not valid with System.Reflection.BindingFlags.CreateInstance, System.Reflection.BindingFlags.InvokeMethod, or System.Reflection.BindingFlags.SetProperty.</TD></TR>
</TABLE>
<P>

[<I>Note</I>: For more information, see <A HREF="../System/Reflection/BindingFlags.html" TARGET="contents">BindingFlags</A> .]<P>

<P>

]<P>

[<I>Usage</I>: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) can be used to invoke methods with
   parameters that have default values. To bind to these methods, System.Reflection.BindingFlags.OptionalParamBinding must be specified. For a parameter that has a
   default value, the caller can supply a value or supply System.Type.Missing
   
   to use the default value.<P>

System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) can be used to set a field to a
particular value by specifying System.Reflection.BindingFlags.SetField . For example, to set a public instance field named F on class C, where F is a string, the value is set using the following statement:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{
   &quot;strings new value&quot;}, null, null, null);</CODE><P>

 A string array F can be initialized as follows:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{new
      String[]{&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;}, null, null, null);<P>

</CODE> Use System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) to set the value of an element in an array by specifying the index of the value and the new value for the element as follows:<P>

<CODE>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, C, new Object{1,
   &quot;b&quot;}, null, null, null);</CODE><P>

The preceding statement changes &quot;z&quot; in array
   F to &quot;b&quot;. <P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the use of System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[]) to
   construct a <A HREF="String.html" TARGET="contents">String</A>, obtain its System.String.Length property, invoke System.String.Insert(System.Int32,System.String) on it, and
   then set its value using the System.String.Empty field.<P>

<PRE>using System;
using System.Reflection;

class InvokeMemberExample
{
   static void Main(string[] args)
   {
      // Create the parameter arrays that will
      // be passed to InvokeMember.
      char[] cAry = 
      new char[] {&apos;A&apos;,&apos; &apos;,&apos;s&apos;,&apos;t&apos;,&apos;r&apos;,&apos;i&apos;,&apos;n&apos;,&apos;g&apos;};
      object[] oAry = new object[] {cAry, 0, cAry.Length};

      Type t = typeof(string);

      // Invoke the constructor of a string.
      string str =
         (string)t.InvokeMember(null, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.CreateInstance, null,
         null, oAry, null, null, null);
      Console.WriteLine(&quot;The string is \&quot;{0}\&quot;.&quot;, str);

      // Access a property of the string.
      int i =
         (int) t.InvokeMember(&quot;Length&quot;, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.GetProperty, null, 
         str, null, null, null, null);
      Console.WriteLine(&quot;The length of the string is {0}.&quot;, i);

      // Invoke a method on the string.
      string newStr = &quot;new &quot;;
      object[] oAry2 = new Object[] {2, newStr};
      str = (string) t.InvokeMember(&quot;Insert&quot;, BindingFlags.Instance |
         BindingFlags.Public | BindingFlags.InvokeMethod, null, str, 
         oAry2, null, null, null);
      Console.WriteLine(&quot;The modified string is \&quot;{0}\&quot;.&quot;, str);

      // Access a field of the string.
      str = (string) t.InvokeMember(&quot;Empty&quot;, BindingFlags.Static | 
         BindingFlags.Public | BindingFlags.GetField, null, str, 
         null);
      Console.WriteLine(&quot;The empty string is \&quot;{0}\&quot;.&quot;, str);
  
   }
}
</PRE>
The output is <P>

<CODE>The string is &quot;A string&quot;. <P>

The length of the string is 8. <P>

 The modified string is &quot;A new string&quot;<P>

The empty string is &quot;&quot;. <P>

</CODE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsArrayImpl%20Method"><H3>Type.IsArrayImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsArrayImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class implements the System.Type.IsArray property returning a
<A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether
   the type represented by the current instance is an array.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
An instance of the <A HREF="Array.html" TARGET="contents">Array</A> class is required to return <CODE>false</CODE>
 because it is an object, not an
   array.[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAssignableFrom%20Method"><H3>Type.IsAssignableFrom Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsAssignableFrom(Type c);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Determines whether an instance of the current <A HREF="Type.html" TARGET="contents">Type</A> can be assigned
   from an instance of the specified <A HREF="Type.html" TARGET="contents">Type</A> .
   <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>c</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> to compare with the current <A HREF="Type.html" TARGET="contents">Type</A> . </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>false</CODE>
 if <I>c</I> is a null reference.<P>

<CODE>true</CODE>
 if one or more of the following
statements are true; otherwise <CODE>false</CODE>
. <P>

<UL>
<LI>
      
      If <I>c</I> and the current <A HREF="Type.html" TARGET="contents">Type</A> represent the same type.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is in the inheritance hierarchy of <I>c</I>.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is an interface and <I>c</I> supports that
      interface.</LI>
<LI>If <I>c</I> is a generic type parameter and the current instance represents one of the constraints of <I>c</I>.</LI>
</UL>
<CODE></CODE>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: A generic type definition is not assignable from a closed constructed type.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsAssignableFrom(System.Type)
method using arrays.<P>

<PRE>using System;
class ArrayTypeTest {
 public static void Main() {
 int i = 1;
 int [] array10 = new int [10];
 int [] array2 = new int[2];
 int [,]array22 = new int[2,2];
 int [,]array24 = new int[2,4];
 int [,,]array333 = new int[3,3,3];
 Type array10Type = array10.GetType();
 Type array2Type = array2.GetType();
 Type array22Type = array22.GetType();
 Type array24Type = array24.GetType();
 Type array333Type = array333.GetType();

 // If X and Y are not both arrays, then false
 Console.WriteLine(&quot;int[2] is assignable from int? {0} &quot;, array2Type.IsAssignableFrom(i.GetType()));
 // If X and Y have same type and rank, then true.
 Console.WriteLine(&quot;int[2] is assignable from int[10]? {0} &quot;,  array2Type.IsAssignableFrom(array10Type));
 Console.WriteLine(&quot;int[2,2] is assignable from int[2,4]? {0}&quot;,  array22Type.IsAssignableFrom(array24Type));
 Console.WriteLine(&quot;int[2,4] is assignable from int[2,2]? {0}&quot;,  array24Type.IsAssignableFrom(array22Type));
 Console.WriteLine(&quot;&quot;);
 // If X and Y do not have the same rank, then false.
 Console.WriteLine(&quot;int[2,2] is assignable from int[10]? {0}&quot;,  array22Type.IsAssignableFrom(array10Type));
 Console.WriteLine(&quot;int[2,2] is assignable from int[3,3,3]? {0}&quot;,  array22Type.IsAssignableFrom(array333Type));
 Console.WriteLine(&quot;int[3,3,3] is assignable from int[2,2]? {0}&quot;,  array333Type.IsAssignableFrom(array22Type));
 }
}
</PRE>
The output is<P>

<CODE>int[2] is assignable from int? False<P>

int[2] is assignable from int[10]? True<P>

int[2,2] is assignable from int[2,4]? True<P>

int[2,4] is assignable from int[2,2]? True<P>

int[2,2] is assignable from int[10]? False<P>

int[2,2] is assignable from int[3,3,3]? False<P>

int[3,3,3] is assignable from int[2,2]? False<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsByRefImpl%20Method"><H3>Type.IsByRefImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsByRefImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsByRef
property and determines whether the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsCOMObjectImpl%20Method"><H3>Type.IsCOMObjectImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsCOMObjectImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Reserved.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>false</CODE>
<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This abstract method is required to be present for
      legacy implementations. Conforming implementations are permitted to throw the
   <A HREF="NotSupportedException.html" TARGET="contents">NotSupportedException</A>
   as their implementation.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsInstanceOfType%20Method"><H3>Type.IsInstanceOfType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsInstanceOfType(object o);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Determines whether the specified object is an instance
      of the current <A HREF="Type.html" TARGET="contents">Type</A>.
      <P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>o</DT>
<DD>The object to compare with the current <A HREF="Type.html" TARGET="contents">Type</A>. </DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if either of the following
   statements is true; otherwise <CODE>false</CODE>
.
   <P>

<UL>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is in the inheritance hierarchy of <I>o</I>.</LI>
<LI>
      
      If the current <A HREF="Type.html" TARGET="contents">Type</A> is an interface and <I>o</I> supports that
      interface.</LI>
</UL>
If <I>o</I> is a null reference or if the current instance is an open generic type (that is, System.Type.ContainsGenericParameters  returns <CODE>true</CODE>
) returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
As described above.<P>

[<I>Note</I>: A constructed type is not an instance of its generic type definition.<P>

]<P>

[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsInstanceOfType(System.Object)
method.<P>

<PRE>using System;
public interface IFoo { }
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsInstanceTest {
 public static void Main() {
 Type ifooType=typeof(IFoo);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayType = typeof(Array);
 Console.WriteLine(&quot;int[] is instance of Array? {0}&quot;, arrayType.IsInstanceOfType(array));
 Console.WriteLine(&quot;myclass instance is instance of MyClass? {0}&quot;, mcType.IsInstanceOfType(mc));
 Console.WriteLine(&quot;myderivedclass instance is instance of MyClass? {0}&quot;,  mcType.IsInstanceOfType(mdc));
 Console.WriteLine(&quot;myclass instance is instance of IFoo? {0}&quot;, ifooType.IsInstanceOfType(mc));
 Console.WriteLine(&quot;myderivedclass instance is instance of IFoo? {0}&quot;,  ifooType.IsInstanceOfType(mdc));
 }
}
</PRE>
The output is <P>

<CODE>int[] is instance of Array? True<P>

myclass instance is instance of MyClass? True<P>

myderivedclass instance is instance of MyClass? True<P>

myclass instance is instance of IFoo? True<P>

myderivedclass instance is instance of IFoo? True<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPointerImpl%20Method"><H3>Type.IsPointerImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsPointerImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsPointer property and determines whether the
<A HREF="Type.html" TARGET="contents">Type</A> is a pointer.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is a pointer; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPrimitiveImpl%20Method"><H3>Type.IsPrimitiveImpl Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected abstract bool IsPrimitiveImpl();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
When overridden in a derived class, implements the System.Type.IsPrimitive property and determines whether the
<A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This method 
      returns <CODE>true</CODE>
 if the underlying type of the current instance is
      one of the following: <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Byte.html" TARGET="contents">Byte</A>, <A HREF="SByte.html" TARGET="contents">SByte</A>, <A HREF="Int16.html" TARGET="contents">Int16</A>, <A HREF="UInt16.html" TARGET="contents">UInt16</A>, <A HREF="Int32.html" TARGET="contents">Int32</A>, <A HREF="UInt32.html" TARGET="contents">UInt32</A>, <A HREF="Int64.html" TARGET="contents">Int64</A>, <A HREF="UInt64.html" TARGET="contents">UInt64</A>, <A HREF="Char.html" TARGET="contents">Char</A>, <A HREF="Double.html" TARGET="contents">Double</A>, and <A HREF="Single.html" TARGET="contents">Single</A>.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSubclassOf%20Method"><H3>Type.IsSubclassOf Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsSubclassOf(Type c);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Determines whether the current <A HREF="Type.html" TARGET="contents">Type</A> derives from the
   specified <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>c</DT>
<DD>The <A HREF="Type.html" TARGET="contents">Type</A> to compare with the current <A HREF="Type.html" TARGET="contents">Type</A>.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if <I>c</I> and the current
<A HREF="Type.html" TARGET="contents">Type</A> represent 
   classes, and the class represented by the current <A HREF="Type.html" TARGET="contents">Type</A> derives from the class represented by
<I>c</I>; otherwise <CODE>false</CODE>
. Returns <CODE>false</CODE>
 if 
<I>c</I> and the current <A HREF="Type.html" TARGET="contents">Type</A> represent the same class.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Interfaces are not considered.<P>

If the current instance represents an unassigned type parameter of a generic type or method, it derives from its class constraint, or from <A HREF="Object.html" TARGET="contents">Object</A> if it has no class constraint.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates the System.Type.IsSubclassOf(System.Type)
method.<P>

<PRE>using System;
public interface IFoo { }
public interface IBar:IFoo{}
public class MyClass : IFoo {}
public class MyDerivedClass : MyClass {}
class IsSubclassTest {
 public static void Main() {
 Type ifooType = typeof(IFoo);
 Type ibarType = typeof(IBar);
 MyClass mc = new MyClass();
 Type mcType = mc.GetType();
 MyClass mdc = new MyDerivedClass();
 Type mdcType = mdc.GetType();
 int [] array = new int [10];
 Type arrayOfIntsType = array.GetType();
 Type arrayType = typeof(Array);
 
 Console.WriteLine(&quot;Array is subclass of int[]? {0}&quot;, arrayType.IsSubclassOf(arrayOfIntsType));
 Console.WriteLine(&quot;int [] is subclass of Array? {0}&quot;, arrayOfIntsType.IsSubclassOf(arrayType));
 Console.WriteLine(&quot;IFoo is subclass of IBar? {0}&quot;, ifooType.IsSubclassOf(ibarType));
 Console.WriteLine(&quot;myclass is subclass of MyClass? {0}&quot;, mcType.IsSubclassOf(mcType));
 Console.WriteLine(&quot;myderivedclass is subclass of MyClass? {0}&quot;, mdcType.IsSubclassOf(mcType));
 Console.WriteLine(&quot;IBar is subclass of IFoo? {0}&quot;, ibarType.IsSubclassOf(ifooType)); 
  }
}
</PRE>
The output is <P>

<CODE>Array is subclass of int[]? False<P>

int [] is subclass of Array? True<P>

IFoo is subclass of IBar? False<P>

myclass is subclass of MyClass? False<P>

myderivedclass is subclass of MyClass? True<P>

IBar is subclass of IFoo? False<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.MakeArrayType%28%29%20Method"><H3>Type.MakeArrayType() Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type MakeArrayType()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing a one-dimensional array type whose element type is the current type, with a lower bound of zero.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method provides a way to generate an array type with any possible element type, including generic types.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.MakeArrayType%28int%29%20Method"><H3>Type.MakeArrayType(int) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type MakeArrayType(int rank)</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing an array of the current type, with the specified number of dimensions.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>rank</DT>
<DD>The number of dimensions for the array.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object representing an array of the current type, with the specified number of dimensions.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="IndexOutOfRangeException.html" TARGET="contents">IndexOutOfRangeException</A></TD><TD><I>rank</I> is invalid (being less than 1, for example).<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method provides a way to generate an array with any possible element type, including generic types.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.MakeByRefType%20Method"><H3>Type.MakeByRefType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type MakeByRefType()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="Type.html" TARGET="contents">Type</A> object that represents the current type when passed as a byref parameter.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the current type when passed as a byref parameter.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method provides a way to generate a byref type for any type. <P>

[<I>Note</I>: Using ilasm syntax, if the current <A HREF="Type.html" TARGET="contents">Type</A> object represents <CODE>int32</CODE>
, this method returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing <CODE>int32&amp;</CODE>
.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.MakeGenericType%20Method"><H3>Type.MakeGenericType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override Type MakeGenericType(System.Type[] typeArguments)</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Substitutes the elements of an array of types for the type parameters of the current generic type definition, and returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing the resulting constructed type.<P>

The current type shall be a generic type definition.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeArguments</DT>
<DD>An array of types to be substituted for the type parameters of the current generic type definition.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> representing the constructed type formed by substituting the elements of <I>typeArguments</I> for the type parameters of the current generic type definition.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The number of elements in 
<I>typeArguments</I> is not the same as the number of type parameters of the current generic type definition.<P>

-or-<P>

An element of <I>typeArguments</I> does not satisfy the constraints specified for the corresponding type parameter of the current generic type definition.<P>

</TD></TR>
<TR><TD><A HREF="ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeArguments</I> is <CODE>null</CODE>
. <P>

-or-<P>

An element of <I>typeArguments</I> is <CODE>null</CODE>
. <P>

</TD></TR>
<TR><TD><A HREF="InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current type does not represent the definition of a generic type. That is, System.Type.IsGenericTypeDefinition  returns <CODE>false</CODE>
. <P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This  method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <A HREF="Type.html" TARGET="contents">Type</A> object that represents a particular constructed type. You can use this <A HREF="Type.html" TARGET="contents">Type</A> object to create runtime instances of the constructed type.<P>

The <A HREF="Type.html" TARGET="contents">Type</A> object returned by this method is the same as that obtained by calling the System.Object.GetType method of the resulting constructed type, or the System.Object.GetType method of any constructed type that was created from the same generic type using the same type arguments.<P>

[<I>Note</I>: An array type whose element type is a generic type is not itself a generic type. Thus, you cannot call this method to bind an array type. To bind a type argument to this type, call System.Type.GetElementType to obtain the generic type, then this method to bind the type argument to the generic type, and, finally,  System.Type.MakeArrayType to create the array type. ]<P>

<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example uses System.Type.GetType and System.Type.MakeGenericType to create a constructed type from the generic System.Collections.Generic.Dictionary type. The constructed type represents a System.Collections.Generic.Dictionary of <CODE>Test</CODE>
 objects with string keys.   <P>

<PRE>using System;
using System.Reflection;
using System.Collections.Generic;

public class Test
{
	public static void Main()
	{
		Console.WriteLine(&quot;\n--- Create a constructed type from the generic  Dictionary type.&quot;);

		// Create a type object representing the generic Dictionary 
		// type.       
		Type generic = Type.GetType(&quot;System.Collections.Generic.Dictionary&quot;);

		DisplayTypeInfo(generic);

		// Create an array of types to substitute for the type
		// parameters of Dictionary. The key is of type string, and
		// the type to be contained in the Dictionary is Test.
		Type[] typeArgs = { typeof(string), typeof(Test) };
		Type constructed = generic.MakeGenericType(typeArgs);

		DisplayTypeInfo(constructed);

		// Compare the type objects obtained above to type objects
		// obtained using typeof() and GetGenericTypeDefinition().
		Console.WriteLine(&quot;\n--- Compare types obtained by different methods:&quot;);

		Type t = typeof(Dictionary&lt;string, Test&gt;);

		Console.WriteLine(&quot;\tAre the constructed types equal? {0}&quot;, t == constructed);
		Console.WriteLine(&quot;\tAre the generic types equal? {0}&quot;, t.GetGenericTypeDefinition() == generic);
	}

	private static void DisplayTypeInfo(Type t)
	{
		Console.WriteLine(&quot;\n{0}&quot;, t);
		Console.WriteLine(&quot;\tIs this a generic type definition? {0}&quot;, t.IsGenericTypeDefinition);
		Console.WriteLine(&quot;\tDoes it have generic type arguments? {0}&quot;, t.HasGenericArguments);

		Type[] typeArguments = t.GetGenericArguments();

		Console.WriteLine(&quot;\tList type arguments ({0}):&quot;, typeArguments.Length);
		foreach (Type tParam in typeArguments)
		{
			Console.WriteLine(&quot;\t\t{0}&quot;, tParam);
		}
	}
}

/* This example produces the following output:

--- Create a constructed type from the generic Dictionary type.

System.Collections.Generic.Dictionary[KeyType,ValueType]
        Is this a generic type definition? True
        Does it have generic type arguments? True
        List type arguments (2):
                K
                V

System.Collections.Generic.Dictionary[System.String, Test]
        Is this a generic type definition? False
        Does it have generic type arguments? True
        List type arguments (2):
                System.String
                Test

--- Compare types obtained by different methods:
        Are the constructed types equal? True
        Are the generic types equal? True
 */
</PRE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.MakePointerType%20Method"><H3>Type.MakePointerType Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type MakePointerType()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of an unmanaged pointer to the current type.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object that represents the type of an unmanaged pointer to the current type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This method provides a way to generate an unmanaged pointer type for types computed at runtime. <P>

[<I>Note</I>: Using ilasm syntax, if the current <A HREF="Type.html" TARGET="contents">Type</A> object represents <CODE>int32</CODE>
, this method returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing <CODE>int32*</CODE>
.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.ToString%20Method"><H3>Type.ToString Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override string ToString();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns a <A HREF="String.html" TARGET="contents">String</A> representation of the current <A HREF="Type.html" TARGET="contents">Type</A>.
   <P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
Returns System.Type.FullName .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: This method
      overrides System.Object.ToString
      .]<P>

<P>

If the current instance represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current instance represents an unassigned type parameter of a generic type or method, this method returns the unqualified name of the type parameter.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Delimiter%20Field"><H3>Type.Delimiter Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly char Delimiter;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Specifies the character that separates elements in the fully qualified name
      of a <A HREF="Type.html" TARGET="contents">Type</A>
      .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.EmptyTypes%20Field"><H3>Type.EmptyTypes Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly Type[] EmptyTypes;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns an empty array of type <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

The empty <A HREF="Type.html" TARGET="contents">Type</A> array returned by this field is used to specify that 
   lookup methods in the <A HREF="Type.html" TARGET="contents">Type</A> class, such as System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) and System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]),
   search for members that do not take parameters. [<I>Note</I>: For example, to locate the public instance constructor that takes no
   parameters, invoke System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[]) (System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance, <CODE>null</CODE>
, System.Type.EmptyTypes,
<CODE>null</CODE>
).]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Missing%20Field"><H3>Type.Missing Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static readonly object Missing;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Represents a missing value in the <A HREF="Type.html" TARGET="contents">Type</A> information.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This field is read-only.<P>

Use the <CODE>Missing</CODE>
 
field for invocation through reflection to ensure that a call will be made
with the default value of a parameter as specified in the metadata. [<I>Note</I>: If the <CODE>Missing</CODE>
 field is specified for a
parameter value and there is no default value for that parameter, a <A HREF="ArgumentException.html" TARGET="contents">ArgumentException</A> is
thrown.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Assembly%20Property"><H3>Type.Assembly Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Assembly Assembly { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> in which the type is declared.  For generic types, gets the <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> that contains the generic type definition.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> instance that describes the assembly containing the current type.  For generic types, the instance describes the assembly that contains the definition of the generic type.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this property returns the assembly in which the type was defined. For example, suppose you create an assembly named MyGenerics.dll that contains a class named <CODE>MyGenericStack&lt;T&gt;</CODE>
. If you create an instance of <CODE>MyGenericStack&lt;int&gt;</CODE>
 in another assembly, the System.Type.Assembly property for the constructed type returns a <A HREF="../System/Reflection/Assembly.html" TARGET="contents">Assembly</A> that represents MyGenerics.dll.<P>

Similarly, if the current instance represents a generic parameter T, this property returns the assembly that contains the generic type definition that defines T.<P>

[<I>Behaviors</I>: This property is read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.AssemblyQualifiedName%20Property"><H3>Type.AssemblyQualifiedName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string AssemblyQualifiedName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the fully qualified name of the type represented by 
      the current instance
      including the name of the assembly from which the <A HREF="Type.html" TARGET="contents">Type</A> was loaded.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The assembly-qualified name of the <A HREF="Type.html" TARGET="contents">Type</A>, including the name of the assembly from which the <A HREF="Type.html" TARGET="contents">Type</A> was loaded. If the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a generic parameter, this property returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>:  
         This property is read-only.<P>

Compilers emit the simple name of a nested class, and reflection constructs a 
         mangled name when queried, in accordance with the following conventions.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Delimiter</TH><TH>Meaning</TH></TR>
<TR><TD> Backslash (\)</TD><TD>Escape character.</TD></TR>
<TR><TD> Comma (,)</TD><TD>Precedes the Assembly name.</TD></TR>
<TR><TD> Plus sign (+)</TD><TD>Precedes a nested class.</TD></TR>
<TR><TD> Period (.)</TD><TD>Denotes namespace identifiers. </TD></TR>
<TR><TD>Square brackets ([])</TD><TD>After a type name, denotes an array of that type.<P>

-or-<P>

For a generic type, encloses the entire generic type argument list.<P>

-or-<P>

Within a type argument list, encloses an assembly-qualified type.<P>

</TD></TR>
</TABLE>
[<I>Note</I>: For example, the fully qualified name for a class might look like this: <P>

TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly <P>

If the namespace were TopNamespace.Sub+Namespace, then the string would
            have to precede the plus sign (+) with an escape character (\) to prevent
            it from being interpreted as a nesting separator. Reflection
            emits this string as follows:<P>

TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly<P>

A &quot;++&quot; becomes &quot;\+\+&quot;, and a &quot;\&quot; becomes &quot;\\&quot;.<P>

]<P>

Type names are permitted to include trailing characters that denote
         additional information about the type, such as whether the type is a reference
         type, a pointer type or an array type. To retrieve the type name without these
         trailing characters, use <CODE>t.GetElementType().ToString()</CODE>, where <I>t</I>
      is the type.<P>

Spaces are significant in all type name components except the assembly
      name. In the assembly name, spaces before the &apos;,&apos; separator are significant, but
      spaces after the &apos;,&apos; separator are ignored.<P>

Generic arguments of generic types are themselves fully qualified. For example, the output from the following C# program, if compiled to an assembly called Try64<P>

<PRE>using System;
using System.Reflection;

class MyTest {
  public static void Main(String[] args) {
    Type b = typeof(B&lt;string,object&gt;);
    Console.WriteLine(b.AssemblyQualifiedName);
  }
}
public class B&lt;T,U&gt; { }</PRE>
is as follows:<P>

<PRE>B`2[[System.String, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089],[System.Object, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], Try64, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null</PRE>
]<P>

[<I>Usage</I>: The name returned by this method can be persisted and later used to load the <A HREF="Type.html" TARGET="contents">Type</A>.
   To search for and load a <A HREF="Type.html" TARGET="contents">Type</A>, use System.Type.GetType(System.String,System.Boolean,System.Boolean) either with the type name only or with
   the assembly qualified type name. System.Type.GetType(System.String,System.Boolean,System.Boolean) with the type name only will look for
   the <A HREF="Type.html" TARGET="contents">Type</A>
   in the caller&apos;s assembly and then in the System assembly. System.Type.GetType(System.String,System.Boolean,System.Boolean) with the
   assembly qualified type name will look for the <A HREF="Type.html" TARGET="contents">Type</A> in any assembly.<P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Attributes%20Property"><H3>Type.Attributes Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public TypeAttributes Attributes { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the attributes associated with the type represented 
      by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/TypeAttributes.html" TARGET="contents">TypeAttributes</A> object representing the attribute set of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents a generic type, this property returns the attributes of the generic type definition.<P>

If the current instance represents a generic type parameter T, the System.Reflection.TypeAttributes returned by this property includes System.Reflection.TypeAttributes.Abstract, System.Reflection.TypeAttributes.AnsiClass, System.Reflection.TypeAttributes.AutoLayout, System.Reflection.TypeAttributes.Class, System.Reflection.TypeAttributes.Public, and System.Reflection.TypeAttributes.Sealed. These are arbitrary choices which have no meaning in the context of a type parameter.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.BaseType%20Property"><H3>Type.BaseType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type BaseType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the base <A HREF="Type.html" TARGET="contents">Type</A> of the current <A HREF="Type.html" TARGET="contents">Type</A> .<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="Type.html" TARGET="contents">Type</A> object 
   representing the type from which the current <A HREF="Type.html" TARGET="contents">Type</A> directly inherits, or
<CODE>null</CODE>
 
if the current <A HREF="Type.html" TARGET="contents">Type</A> represents the <A HREF="Object.html" TARGET="contents">Object</A> class.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The base type is the type from which the current type directly inherits. <A HREF="Object.html" TARGET="contents">Object</A> is the only type that does not have a base type, therefore <CODE>null</CODE>
 is returned as the base type of <A HREF="Object.html" TARGET="contents">Object</A> .<P>

Interfaces inherit from <A HREF="Object.html" TARGET="contents">Object</A> and from zero or more base interfaces; therefore, the base type of an interface is considered to be <A HREF="Object.html" TARGET="contents">Object</A> .<P>

If the current instance represents a constructed generic type, the base type reflects the generic arguments.<P>

If the current instance represents an unassigned type parameter, System.Type.BaseType returns the base class type constraint declared for that parameter, or <A HREF="Object.html" TARGET="contents">Object</A> if no base class type constraint was declared.<P>

[<I>Behaviors</I>:  This property is read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.BaseType
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 Type t = typeof(int);
 Console.WriteLine(&quot;{0} inherits from {1}&quot;, t,t.BaseType);
 }
}
</PRE>
The output is<P>

<CODE>System.Int32
   inherits from System.ValueType</CODE><P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.ContainsGenericParameters%20Property"><H3>Type.ContainsGenericParameters Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool ContainsGenericParameters { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether a <A HREF="Type.html" TARGET="contents">Type</A> object contains unassigned generic parameters.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if a <A HREF="Type.html" TARGET="contents">Type</A> object contains unassigned generic parameters; otherwise <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
In order to create an instance of a generic type, there must be no generic type definitions or open constructed types in the type arguments. For other constructed types, such as arrays and managed pointers, the types from which they are constructed must be able to be instantiated. If the System.Type.ContainsGenericParameters property returns <CODE>true</CODE>
, the type cannot be instantiated.<P>

The  System.Type.ContainsGenericParameters property searches recursively for type parameters. For example, it returns true for an array whose element type is <CODE>A&lt;T&gt;</CODE>
, even though the array type itself is not generic. Contrast this with the behavior of the System.Type.IsGenericType property, which returns <CODE>false</CODE>
 for arrays.<P>

For a set of example classes and a table showing the values of the System.Type.ContainsGenericParameters property, see the System.Type.IsGenericType property description.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.GenericParameterPosition.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.DeclaringMethod%20Property"><H3>Type.DeclaringMethod Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual MethodBase DeclaringMethod { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic method, gets a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A>  that represents the declaring method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic method, a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A>  that represents the declaring method; otherwise <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The declaring method is a generic method definition. That is, if System.Type.DeclaringMethod does not return <CODE>null</CODE>
, then DeclaringMethod.IsGenericMethodDefinition returns <CODE>true</CODE>
.<P>

The System.Type.DeclaringType and System.Type.DeclaringMethod properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:<P>

<UL>
<LI>If the System.Type.DeclaringMethod property returns a <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>, that <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A> represents a generic method definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic method definition.<P>

</LI>
<LI>If the System.Type.DeclaringMethod property returns a <CODE>null</CODE>
, then the System.Type.DeclaringType property always returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing a generic type definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic type definition.<P>

</LI>
</UL>
For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.DeclaringType%20Property"><H3>Type.DeclaringType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type DeclaringType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the type that declares the type represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <A HREF="Type.html" TARGET="contents">Type</A> object for
   the class that declares the type represented by the current
   instance. If the type is a nested type, this property returns the enclosing type; otherwise, returns
   the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: This property implements the abstract property inherited from System.Reflection.MemberInfo.]<P>

<P>

If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic type or method definition, the System.Type.DeclaringType and System.Type.DeclaringMethod properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:<P>

<UL>
<LI>If the System.Type.DeclaringMethod property returns a <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>, that <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A> represents a generic method definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic method definition.<P>

</LI>
<LI>If the System.Type.DeclaringMethod property returns a <CODE>null</CODE>
, then the System.Type.DeclaringType property always returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing a generic type definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic type definition.<P>

</LI>
</UL>
For a type parameter of a generic method, this property returns the type that contains the generic method definition.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.DefaultBinder%20Property"><H3>Type.DefaultBinder Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static Binder DefaultBinder { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the default binder used by the system.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The default <A HREF="../System/Reflection/Binder.html" TARGET="contents">Binder</A> used by the system.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Reflection models the accessibility rules of the common
      type system. For example, if the caller is in the same assembly, the caller does
      not need special permissions for internal members. Otherwise, the caller needs
   <A HREF="../System/Security/Permissions/ReflectionPermission.html" TARGET="contents">ReflectionPermission</A>
   . This is consistent with lookup of members that
   are protected, private, and so on. <P>

[<I>Note</I>: The general principle is that System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo) 
typically performs only widening coercions,
which never lose data. An example of a widening coercion is coercing a
value that is a 32-bit signed integer to a value that is a 64-bit signed integer.
This is distinguished from a narrowing coercion, which can lose data. An
example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit
signed integer. ]<P>

<P>

The following table lists the coercions performed by the default binder&apos;s implementation of
<CODE>ChangeType</CODE>
.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Source Type</TH><TH>Target Type</TH></TR>
<TR><TD> Any type</TD><TD>Its base type.</TD></TR>
<TR><TD> Any type</TD><TD>The interface it implements.</TD></TR>
<TR><TD> Char</TD><TD>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Byte</TD><TD>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> SByte</TD><TD>Int16, Int32, Int64, Single, Double</TD></TR>
<TR><TD> UInt16</TD><TD>UInt32, Int32, UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Int16</TD><TD>Int32, Int64, Single, Double</TD></TR>
<TR><TD> UInt32</TD><TD>UInt64, Int64, Single, Double</TD></TR>
<TR><TD> Int32</TD><TD>Int64, Single, Double</TD></TR>
<TR><TD> UInt64</TD><TD>Single, Double</TD></TR>
<TR><TD> Int64</TD><TD>Single, Double</TD></TR>
<TR><TD> Single</TD><TD>Double</TD></TR>
<TR><TD> Non-reference</TD><TD>By-reference.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.FullName%20Property"><H3>Type.FullName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string FullName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the fully qualified name of the type represented by 
      the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="String.html" TARGET="contents">String</A> containing the fully qualified name of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: For example, the
      fully qualified name of the C# string type is &quot;System.String&quot;.]<P>

<P>

If the current instance represents a generic type, the type arguments in the string returned by System.Type.FullName are qualified by their assembly, version, and so on, even though the string representation of the generic type itself is not qualified by assembly. Thus, <CODE>t.FullName + &quot;, &quot; + t.Assembly.FullName</CODE>
 produces the same result as <CODE>t.AssemblyQualifiedName</CODE>
, as with types that are not generic.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>null</CODE>
.<P>

[<I>Behaviors</I>: This property is
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.FullName
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 Type t = typeof(Array);
 Console.WriteLine(&quot;Full name of Array type is {0}&quot;,t.FullName);
 }
}
</PRE>
The output is<P>

<CODE>Full name of
   Array type is System.Array</CODE><P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GenericParameterAttributes%20Property"><H3>Type.GenericParameterAttributes Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual GenericParameterAttributes GenericParameterAttributes { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a combination of <A HREF="../System/Reflection/GenericParameterAttributes.html" TARGET="contents">GenericParameterAttributes</A> flags that describe the variance and special constraints of the current generic type parameter. <P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/GenericParameterAttributes.html" TARGET="contents">GenericParameterAttributes</A> value that describes the variance and special constraints of the current generic type parameter.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current <A HREF="Type.html" TARGET="contents">Type</A> object is not a generic type parameter. That is, the System.Type.IsGenericParameter property returns <CODE>false</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

The value of this property contains flags that describe whether the current generic type parameter is variant, and flags that describe any special constraints. Use System.GenericParameterAttributes.VarianceMask to select the variance flags, and System.GenericParameterAttributes.SpecialConstraintMask to select the constraint flags. Use System.Reflection.GetGenericParameterConstraints to get the type constraints.<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.GenericParameterPosition%20Property"><H3>Type.GenericParameterPosition Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual int GenericParameterPosition { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
For a <A HREF="Type.html" TARGET="contents">Type</A> object that represents a type parameter of a generic type or generic method, gets the position of the type parameter in the type parameter list of the generic type or generic method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A zero-based integer representing the position of a type parameter in the type parameter list of the generic type or generic method that declared the parameter.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current type does not represent a type parameter. That is, System.Type.IsGenericParameter  returns <CODE>false</CODE>
.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This read-only property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The System.Type.DeclaringType and System.Type.DeclaringMethod properties identify the generic type or method definition:<P>

<UL>
<LI>If the System.Type.DeclaringMethod property returns a <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A>, that <A HREF="../System/Reflection/MethodBase.html" TARGET="contents">MethodBase</A> represents a generic method definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic method definition.<P>

</LI>
<LI>If the System.Type.DeclaringMethod property returns a <CODE>null</CODE>
, then the System.Type.DeclaringType property always returns a <A HREF="Type.html" TARGET="contents">Type</A> object representing a generic type definition, and the current <A HREF="Type.html" TARGET="contents">Type</A> object represents a type parameter of that generic type definition.<P>

</LI>
</UL>
To provide the correct context for the value of the System.Type.GenericParameterPosition property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method <CODE>GetSomething</CODE>
 in the following C# code: <P>

<PRE>public class B&lt;T, U&gt; { }
 public class A&lt;V&gt;
 {
     public B&lt;V, X&gt; GetSomething&lt;X&gt;()
     {
         return new Base&lt;V, X&gt;();
     }
 }</PRE>
The type returned by <CODE>GetSomething</CODE>
 depends on the type arguments supplied to class <CODE>A</CODE>
 and <CODE>GetSomething</CODE>
 itself. You can obtain a <A HREF="../System/Reflection/MethodInfo.html" TARGET="contents">MethodInfo</A> for <CODE>GetSomething</CODE>
 and from that you can obtain the return type. When you examine the type parameters of the return type, System.Type.GenericParameterPosition returns zero for both. The position of <CODE>V</CODE>
 is zero because <CODE>V</CODE>
 is the first type parameter in the type parameter list for class <CODE>A</CODE>
. The position of<CODE>X</CODE>
 is zero because <CODE>X</CODE>
 is the first type parameter in the type parameter list for <CODE>GetSomething</CODE>
.<P>

[<I>Note</I>: Calling the System.Type.GenericParameterPosition property causes an exception if the current <A HREF="Type.html" TARGET="contents">Type</A> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the System.Type.IsGenericParameter property to tell which are type parameters and which are types. The System.Type.IsGenericParameter property returns<CODE>true</CODE>
 for a type parameter; you can then use the System.Type.GenericParameterPosition method to obtain its position, and the System.Type.DeclaringMethod and System.Type.DeclaringType properties to determine the generic method or type definition that defines it.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example defines a generic class with two type parameters, and a generic class that derives from it. The base class of the derived type has one unbound type parameter and one type parameter bound to <A HREF="Int32.html" TARGET="contents">Int32</A>. The example displays information about these generic classes, including the positions reported by System.Type.GenericParameterPosition.<P>

<PRE>using System;
using System.Reflection;
using System.Collections.Generic;
// Define a base class with two type parameters.
public class Base&lt;T, U&gt; { }

// Define a derived class. The derived class inherits from a constructed
// class that meets the following criteria:
//   (1) Its generic type definition is Base&lt;T, U&gt;.
//   (2) It specifies int for the first type parameter.
//   (3) For the second type parameter, it uses the same type that is used
//       for the type parameter of the derived class.
// Thus, the derived class is a generic type with one type parameter, but
// its base class is an open constructed type with one type argument and
// one type parameter.
public class Derived&lt;V&gt;: Base&lt;int,V&gt; { }

public class Test
{
	public static void Main()
	{
		Console.WriteLine(&quot;\n--- Display a generic type and the open constructed&quot;);
		Console.WriteLine(&quot;    type from which it is derived.&quot;);

		// Create a Type object representing the generic type Derived.
		//
		Type derivedType = Type.GetType(&quot;Derived&quot;);

		DisplayGenericTypeInfo(derivedType);

		// Display its open constructed base type.
		DisplayGenericTypeInfo(derivedType.BaseType);
	}

	private static void DisplayGenericTypeInfo(Type t)
	{
		Console.WriteLine(&quot;\n{0}&quot;, t);
		Console.WriteLine(&quot;\tIs this a generic type definition? {0}&quot;, t.IsGenericTypeDefinition);
		Console.WriteLine(&quot;\tDoes it have generic arguments? {0}&quot;, t.HasGenericArguments);
		Console.WriteLine(&quot;\tDoes it have unbound generic parameters? {0}&quot;, t.ContainsGenericParameters);
		if (t.HasGenericArguments)
		{
			// If the type is a generic type definition or a 
			// constructed type, display the type arguments.
			//
			Type[] typeArguments = t.GetGenericArguments();

			Console.WriteLine(&quot;\tList type arguments ({0}):&quot;, typeArguments.Length);
			foreach (Type tParam in typeArguments)
			{
				// IsGenericParameter is true only for generic type
				// parameters.
				//
				if (tParam.IsGenericParameter)
				{
					Console.WriteLine(&quot;\t\t{0}  (unbound - parameter position {1})&quot;, tParam, tParam.GenericParameterPosition);
				}
				else
				{
					Console.WriteLine(&quot;\t\t{0}&quot;, tParam);
				}
			}
		}
		else
		{
			Console.WriteLine(&quot;\tThis is not a generic or constructed type.&quot;);
		}
	}
}

/* This example produces the following output:

--- Display a generic type and the open constructed
    type from which it is derived.

Derived[V]
        Is this a generic type definition? True
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (1):
                V  (unbound - parameter position 0)

Base[System.Int32, V]
        Is this a generic type definition? False
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (2):
                System.Int32
                V  (unbound - parameter position 0)
 */</PRE>
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.HasElementType%20Property"><H3>Type.HasElementType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool HasElementType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the type represented by the 
   current instance encompasses or refers
   to another type; that is, whether the current <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is an array, a pointer, or is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: For example, System.Type.GetType(System.String,System.Boolean,System.Boolean)(&quot;<A HREF="Int32.html" TARGET="contents">Int32</A> []&quot;).HasElementType returns
<CODE>true</CODE>
, but System.Type.GetType(System.String,System.Boolean,System.Boolean)(&quot;<A HREF="Int32.html" TARGET="contents">Int32</A> &quot;).HasElementType returns
<CODE>false</CODE>
. System.Type.HasElementType also returns
<CODE>true</CODE>
 for &quot;Int32*&quot; and &quot;Int32&amp;&quot;.]<P>

<P>

If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAbstract%20Property"><H3>Type.IsAbstract Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsAbstract { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating 
   whether the type represented by the current instance is abstract and is required to be overridden.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is abstract; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property always returns <CODE>true</CODE>
. This is because it is not possible to create an instance of a generic type parameter.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAnsiClass%20Property"><H3>Type.IsAnsiClass Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsAnsiClass { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Indicates whether the type attribute System.Reflection.TypeAttributes.AnsiClass is selected for the current type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type attribute System.Reflection.TypeAttributes.AnsiClass  is selected for the current type; otherwise, <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a generic type, this property applies to the definition of the type. If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsArray%20Property"><H3>Type.IsArray Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsArray { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents an array.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents an
   array; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns <CODE>true</CODE>
 for an array of objects, but
   not for the <A HREF="Array.html" TARGET="contents">Array</A>
   type itself, which is a class.<P>

If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.IsArray
property.<P>

<PRE>using System;
class TestType {
 public static void Main() {
 int [] array = {1,2,3,4};
 Type at = typeof(Array);
 Type t = array.GetType();
 Console.WriteLine(&quot;Type is {0}. IsArray? {1}&quot;, at, at.IsArray);
 Console.WriteLine(&quot;Type is {0}. IsArray? {1}&quot;, t, t.IsArray);
 }
}
</PRE>
The output is<P>

<CODE>Type is System.Array. IsArray? False<P>

Type is System.Int32[]. IsArray? True<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAutoClass%20Property"><H3>Type.IsAutoClass Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsAutoClass { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Indicates whether the type attribute System.Reflection.TypeAttributes.AutoClass is selected for the current type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type attribute System.Reflection.TypeAttributes.AutoClass  is selected for the current type; otherwise, <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a generic type, this property applies to the definition of the type. If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsAutoLayout%20Property"><H3>Type.IsAutoLayout Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsAutoLayout { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.AutoLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type
   layout attribute System.Reflection.TypeAttributes.AutoLayout is specified for the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

[<I>Note</I>: The System.Reflection.TypeAttributes.AutoLayout attribute specifies that the system
      selects the layout the objects of the type. Types marked with this attribute indicate that the
      system will choose the appropriate way to lay out the type; any layout information
      that might have been specified is ignored. <P>

]<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsByRef%20Property"><H3>Type.IsByRef Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsByRef { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the <A HREF="Type.html" TARGET="contents">Type</A> is
   passed by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is passed by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsClass%20Property"><H3>Type.IsClass Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsClass { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a class;
   otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Note that this property returns <CODE>true</CODE>
 for
<A HREF="Type.html" TARGET="contents">Type</A> instances 
   representing <A HREF="Enum.html" TARGET="contents">Enum</A> and <A HREF="ValueType.html" TARGET="contents">ValueType</A> .<P>

If the current instance represents a generic type, this property returns <CODE>true</CODE>
 if the generic type definition is a class definition (that is, it does not define an interface or a value type).<P>

If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsEnum%20Property"><H3>Type.IsEnum Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsEnum { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents an enumeration.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents an
   enumeration; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns <CODE>true</CODE>
 for an enumeration, but not
   for the <A HREF="Enum.html" TARGET="contents">Enum</A>
   type itself, which is a class.<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following example demonstrates using the System.Type.IsEnum
property.<P>

<PRE>using System;
public enum Color {
Red, Blue, Green
}
class TestType {
 public static void Main() {
 Type colorType = typeof(Color);
 Type enumType = typeof(Enum);
 Console.WriteLine(&quot;Color is enum ? {0}&quot;, colorType.IsEnum);
 Console.WriteLine(&quot;Color is valueType? {0}&quot;, colorType.IsValueType);
 Console.WriteLine(&quot;Enum is enum Type? {0}&quot;, enumType.IsEnum);
 Console.WriteLine(&quot;Enum is value? {0}&quot;, enumType.IsValueType);
 }
}
</PRE>
The output is<P>

<CODE>Color is enum ? True<P>

Color is valueType? True<P>

Enum is enum Type? False<P>

Enum is value? False<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsExplicitLayout%20Property"><H3>Type.IsExplicitLayout Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsExplicitLayout { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.ExplicitLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type layout attribute System.Reflection.TypeAttributes.ExplicitLayout is specified for the current <A HREF="Type.html" TARGET="contents">Type</A>; otherwise,
<CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Types marked with the System.Reflection.TypeAttributes.ExplicitLayout attribute cause
      the system to ignore field sequence and to use the explicit layout rules provided,
      in the form of field offsets, overall class size and alignment. <P>

]<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsGenericParameter%20Property"><H3>Type.IsGenericParameter Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsGenericParameter { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current type represents a type parameter of a generic type or method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current object represents a type parameter of a generic type or method; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Use this property to distinguish between type parameters and type arguments. When you call  System.Type.GetGenericArguments to obtain the type arguments of a generic type, some elements of the array might be specific types (type arguments) and others might be type parameters.System.Type.IsGenericParameter returns <CODE>false</CODE>
 for the types and <CODE>true</CODE>
 for the type parameters.<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.GenericParameterPosition.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsGenericType%20Property"><H3>Type.IsGenericType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsGenericType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current type has type arguments, and is therefore a generic type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current type has type arguments; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Use this property to determine whether a <A HREF="Type.html" TARGET="contents">Type</A> object represents a generic type. Use the System.Type.ContainsGenericParameters property to determine whether a <A HREF="Type.html" TARGET="contents">Type</A> object represents an open constructed type or a closed constructed type.<P>

[<I>Note</I>: The  System.Type.HasGenericArguments property returns <CODE>false</CODE>
 if the immediate type is not generic.  ]<P>

<P>

The following table summarizes the invariant conditions for common terms used in generic reflection.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Term</TH><TH>Invariant</TH></TR>
<TR><TD>generic type definition</TD><TD>The System.Type.IsGenericTypeDefinition property is <CODE>true</CODE>
.<P>

Defines a generic type. A constructed type is created by calling the System.Type.MakeGenericType<CODE>(System.Type[])</CODE>
 method on a <A HREF="Type.html" TARGET="contents">Type</A> object that represents a generic type definition, and specifying an array of type arguments.<P>

System.Type.MakeGenericType<CODE>(System.Type[])</CODE>
 can be called only on generic type definitions. <P>

Any generic type definition is a generic type, but the converse is not true.<P>

</TD></TR>
<TR><TD>generic type</TD><TD>The System.Type.IsGenericType property is <CODE>true</CODE>
.<P>

Can be a generic type definition, an open constructed type, or a closed constructed type. <P>

Note that an array type whose element type is generic is not itself a generic type. The same is true of a <A HREF="Type.html" TARGET="contents">Type</A> object representing a pointer to a generic type.<P>

</TD></TR>
<TR><TD>open constructed type</TD><TD>The System.Type.ContainsGenericParameters property is <CODE>true</CODE>
.<P>

It is not possible to create an instance of an open constructed type.<P>

Note that not all open constructed types are generic, such as an array type whose element type is a generic type definition.<P>

</TD></TR>
<TR><TD>closed constructed type</TD><TD>The System.Type.ContainsGenericParameters property is <CODE>false</CODE>
.<P>

When examined recursively, the type has no unassigned generic parameters. The containing type or method has no generic type parameters, and, recursively, no type arguments have unassigned generic type parameters.<P>

</TD></TR>
<TR><TD>generic type parameter</TD><TD>The System.Type.IsGenericParameter property is <CODE>true</CODE>
.<P>

In a generic type definition, a placeholder for a type that will be assigned later.<P>

</TD></TR>
<TR><TD>generic type argument</TD><TD>Can be any type, including a generic type parameter.<P>

Type arguments are specified as an array of <A HREF="Type.html" TARGET="contents">Type</A> objects passed to the System.Type.MakeGenericType<CODE>(System.Type[])</CODE>
 method when creating a constructed generic type. If instances of the resulting type are to be created, the System.Type.ContainsGenericParameters property must be <CODE>false</CODE>
 for all the type arguments.<P>

</TD></TR>
</TABLE>
<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.MakeGenericType.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsGenericTypeDefinition%20Property"><H3>Type.IsGenericTypeDefinition Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsGenericTypeDefinition { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current object represents the definition of a generic type, or whether one or more of its type parameters has been specified.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current object represents the definition of a generic type, none of whose type parameters have been bound to specific types; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

Use this property to determine whether type arguments have been specified for any of the type parameters of a generic type. If type arguments have been specified (that is, bound to the corresponding type parameters), this property returns <CODE>false</CODE>
.<P>

For a list of the invariant conditions for terms used in generic reflection, see the System.Type.IsGenericType property description.<P>

[<I>Note</I>: An open generic type can have type parameters even if types have been specified for its type parameters.<P>

]<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
For an example of using this method, see the example for System.Type.MakeGenericType..<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsImport%20Property"><H3>Type.IsImport Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsImport { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the <A HREF="Type.html" TARGET="contents">Type</A> was imported from another class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> was imported from another class; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsInterface%20Property"><H3>Type.IsInterface Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsInterface { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the  current <A HREF="Type.html" TARGET="contents">Type</A> represents an interface.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A>  represents an
   interface; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsLayoutSequential%20Property"><H3>Type.IsLayoutSequential Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsLayoutSequential { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating
   whether the type layout attribute System.Reflection.TypeAttributes.SequentialLayout is specified for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type layout attribute
System.Reflection.TypeAttributes.SequentialLayout is specified for the current 
<A HREF="Type.html" TARGET="contents">Type</A>; otherwise, 
<CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>:  The System.Reflection.TypeAttributes.SequentialLayout attribute is used
      to indicate that
      the system is to preserve field order as emitted, but otherwise the specific offsets are calculated based on the type
      of the field; these might be shifted by explicit offset, padding, or alignment information.<P>

]<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsMarshalByRef%20Property"><H3>Type.IsMarshalByRef Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsMarshalByRef { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current type is marshaled by reference.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is marshaled by reference; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedAssembly%20Property"><H3>Type.IsNestedAssembly Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedAssembly { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamANDAssem%20Property"><H3>Type.IsNestedFamANDAssem Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamANDAssem { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only to classes that belong to both its own family and
   its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only to classes that belong to both its own family and its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamORAssem%20Property"><H3>Type.IsNestedFamORAssem Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamORAssem { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only to classes that belong to either its
   own family or to its own assembly.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only to classes that belong to its own family or to its own assembly; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedFamily%20Property"><H3>Type.IsNestedFamily Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedFamily { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and visible only within its
   own family.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested
   and visible only within its own family; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
 This property is read-only.<P>

A <A HREF="Type.html" TARGET="contents">Type</A> object&apos;s family is defined as all objects of the exact
   same <A HREF="Type.html" TARGET="contents">Type</A> and of its subclasses.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedPrivate%20Property"><H3>Type.IsNestedPrivate Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedPrivate { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is nested and declared private.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is nested and declared private; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNestedPublic%20Property"><H3>Type.IsNestedPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNestedPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating 
   whether the current <A HREF="Type.html" TARGET="contents">Type</A> is a public nested class.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if
   the class is nested and declared public; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsNotPublic%20Property"><H3>Type.IsNotPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsNotPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the top-level <A HREF="Type.html" TARGET="contents">Type</A> is not declared public.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the
   top-level <A HREF="Type.html" TARGET="contents">Type</A> is not declared public; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPointer%20Property"><H3>Type.IsPointer Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPointer { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a pointer.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
This property is read-only.<P>

<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a
   pointer; otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents a generic type, or a type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPrimitive%20Property"><H3>Type.IsPrimitive Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPrimitive { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is one of the primitive types; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

The primitive types are <A HREF="Boolean.html" TARGET="contents">Boolean</A>, <A HREF="Byte.html" TARGET="contents">Byte</A>, <A HREF="SByte.html" TARGET="contents">SByte</A>, <A HREF="Int16.html" TARGET="contents">Int16</A>, <A HREF="UInt16.html" TARGET="contents">UInt16</A>, <A HREF="Int32.html" TARGET="contents">Int32</A>, <A HREF="UInt32.html" TARGET="contents">UInt32</A>, <A HREF="Int64.html" TARGET="contents">Int64</A>, <A HREF="UInt64.html" TARGET="contents">UInt64</A>, <A HREF="Char.html" TARGET="contents">Char</A>, <A HREF="Double.html" TARGET="contents">Double</A>, and <A HREF="Single.html" TARGET="contents">Single</A>.<P>

If the current instance represents a generic type, or a type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsPublic%20Property"><H3>Type.IsPublic Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsPublic { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the top-level <A HREF="Type.html" TARGET="contents">Type</A> is declared public.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the top-level <A HREF="Type.html" TARGET="contents">Type</A> is declared public; otherwise, <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>true</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSealed%20Property"><H3>Type.IsSealed Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsSealed { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> is declared sealed.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> is declared sealed; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents an unassigned type parameter of a generic type, this property returns <CODE>true</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsSpecialName%20Property"><H3>Type.IsSpecialName Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsSpecialName { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value indicating whether the current <A HREF="Type.html" TARGET="contents">Type</A> has a name that requires special handling.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="Type.html" TARGET="contents">Type</A> has a name that requires special handling; otherwise, <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Names that begin with or contain an
      underscore character (_) are examples of type names that
      might require special treatment by some tools. ]<P>

<P>

If the current instance represents a generic type, this property applies to the definition of the type. If the current instance represents an unassigned type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsUnicodeClass%20Property"><H3>Type.IsUnicodeClass Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsUnicodeClass { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Indicates whether the type attribute System.Reflection.TypeAttributes.UnicodeClass is selected for the current type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the type attribute System.Reflection.TypeAttributes.UnicodeClass  is selected for the current type; otherwise, <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a generic type, this property applies to the definition of the type. If the current <A HREF="Type.html" TARGET="contents">Type</A> represents a type parameter of a generic type or method, this property always returns <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.IsValueType%20Property"><H3>Type.IsValueType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public bool IsValueType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a <A HREF="Boolean.html" TARGET="contents">Boolean</A> value that indicates whether the current <A HREF="Type.html" TARGET="contents">Type</A> represents a value type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="Type.html" TARGET="contents">Type</A> represents a value
   type (structure); otherwise <CODE>false</CODE>
. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

This property returns true for enumerations, but not for
      the <A HREF="Enum.html" TARGET="contents">Enum</A> type
      itself, which is a class. [<I>Note</I>: For an example
      that demonstrates this behavior, see System.Type.IsEnum
      .]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Module%20Property"><H3>Type.Module Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Module Module { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the module in which the current <A HREF="Type.html" TARGET="contents">Type</A> is defined.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/Module.html" TARGET="contents">Module</A> that reflects the module in which the current <A HREF="Type.html" TARGET="contents">Type</A> is defined.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this property returns the module in which the type was defined.<P>

Similarly, if the current instance represents a generic parameter T, this property returns the assembly that contains the generic type that defines T.<P>

[<I>Behaviors</I>: This property is
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.Namespace%20Property"><H3>Type.Namespace Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract string Namespace { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the namespace of the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="String.html" TARGET="contents">String</A> containing the namespace of the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current instance represents a generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current instance represents a generic parameter T, this property returns the namespace that contains the generic type that defines T.<P>

[<I>Note</I>: A namespace is a 
      logical design-time naming convenience, used mainly to define scope in an
      application and organize classes and other types in a hierarchical structure.
      From the viewpoint of the system, there are no namespaces.]<P>

<P>

[<I>Behaviors</I>: This property is 
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.ReflectedType%20Property"><H3>Type.ReflectedType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override Type ReflectedType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the type that was used to obtain the current
      instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <CODE>Type</CODE>
 object
   through which the current instance was obtained.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

If the current instance represents a generic type, or a type parameter of a generic type or method, this property returns the current instance.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.TypeHandle%20Property"><H3>Type.TypeHandle Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract RuntimeTypeHandle TypeHandle { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the handle for the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> for the current <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

The <A HREF="RuntimeTypeHandle.html" TARGET="contents">RuntimeTypeHandle</A> encapsulates a pointer to an internal data structure that represents the type. This
   handle is unique during the process lifetime. The handle is valid only in
   the application domain in which it was obtained.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.TypeInitializer%20Property"><H3>Type.TypeInitializer Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public ConstructorInfo TypeInitializer { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Gets the initializer for the<CODE> </CODE>
type
   represented by the current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="../System/Reflection/ConstructorInfo.html" TARGET="contents">ConstructorInfo</A> containing the name of the static
   constructor for the type represented by the current instance<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Note</I>: Type initializers are available through System.Type.GetMember(System.String),
System.Type.GetMembers, and System.Type.GetConstructors.]<P>

<P>

If the current instance represents an unassigned type parameter of a generic type or method, this property returns <CODE>null</CODE>
.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="Type.UnderlyingSystemType%20Property"><H3>Type.UnderlyingSystemType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type UnderlyingSystemType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the system-supplied type
      that represents the current type.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
The underlying system type for the <A HREF="Type.html" TARGET="contents">Type</A>.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This property is read-only.<P>

[<I>Behaviors</I>: As described 
      above.]<P>

<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Type.html" TARGET="contents">System.Type Class</A>, <A HREF="System.html" TARGET="members">System Namespace</A>
</BLOCKQUOTE>

</BODY>
</HTML>
