<HTML>
<HEAD>
<TITLE>System.Runtime.InteropServices.InAttribute Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Runtime.InteropServices.InAttribute Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public sealed class InAttribute : Attribute</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="../../../System/Attribute.html" TARGET="contents">Attribute</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;InAttribute<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Indicates that a parameter will be marshaled from the caller to
      the callee.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: The
   <A HREF="InAttribute.html" TARGET="contents">InAttribute</A> and <A HREF="OutAttribute.html" TARGET="contents">OutAttribute</A>
   are not
   required. In the absence of explicit settings, the system assumes that all
   arguments passed by reference are passed
<CODE>in</CODE>
/<CODE>out</CODE>
 and that all non-reference 
   parameters are <CODE>in</CODE>
. The only exception is the <A HREF="../../../System/Text/StringBuilder.html" TARGET="contents">StringBuilder</A>
   class, which is always assumed to be
<CODE>in</CODE>
/<CODE>out</CODE>
. The <A HREF="InAttribute.html" TARGET="contents">InAttribute</A> and <A HREF="OutAttribute.html" TARGET="contents">OutAttribute</A> are 
   particularly useful when applied to formatted types that cannot be block-copied.
   Since these types require copying during marshaling, you can use <A HREF="InAttribute.html" TARGET="contents">InAttribute</A>
   and <A HREF="OutAttribute.html" TARGET="contents">OutAttribute</A> to eliminate the generation of unnecessary
   copies.]<P>

<P>

Compilers are required to not preserve this type
   in metadata as a custom attribute. Instead, compilers are required to emit it
   directly in the file format, as described in Partition II of the CLI
   Specification. Metadata consumers, such as the Reflection API, are required to
   retrieve this data from the file format and return it as if it were a custom
   attribute. <P>

</BLOCKQUOTE>

<H4>Attributes</H4>

<BLOCKQUOTE>
<CODE>AttributeUsageAttribute(AttributeTargets.Parameter, AllowMultiple=false, Inherited=false)</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="InteropServices.html" TARGET="members">System.Runtime.InteropServices Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

InAttribute Constructors<P>

<A HREF="#InAttribute%20Constructor" TARGET="contents">InAttribute Constructor</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="InAttribute%20Constructor"><H3>InAttribute Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public InAttribute();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Constructs and initializes a new instance of the <A HREF="InAttribute.html" TARGET="contents">InAttribute</A>
class.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="InAttribute.html" TARGET="contents">System.Runtime.InteropServices.InAttribute Class</A>, <A HREF="InteropServices.html" TARGET="members">System.Runtime.InteropServices Namespace</A>
</BLOCKQUOTE>

</BODY>
</HTML>
