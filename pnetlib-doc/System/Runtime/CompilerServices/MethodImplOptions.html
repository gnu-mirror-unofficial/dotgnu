<HTML>
<HEAD>
<TITLE>System.Runtime.CompilerServices.MethodImplOptions Enum</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Runtime.CompilerServices.MethodImplOptions Enum</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public enum MethodImplOptions</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="../../../System/ValueType.html" TARGET="contents">ValueType</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../System/Enum.html" TARGET="contents">Enum</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodImplOptions<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Defines the details of how a method is implemented.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This enumeration is used by <A HREF="MethodImplAttribute.html" TARGET="contents">MethodImplAttribute</A>.
   <P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

MethodImplOptions Fields<P>

<A HREF="#MethodImplOptions.ForwardRef Field" TARGET="contents">MethodImplOptions.ForwardRef Field</A><BR>
<A HREF="#MethodImplOptions.InternalCall Field" TARGET="contents">MethodImplOptions.InternalCall Field</A><BR>
<A HREF="#MethodImplOptions.NoInlining Field" TARGET="contents">MethodImplOptions.NoInlining Field</A><BR>
<A HREF="#MethodImplOptions.Synchronized Field" TARGET="contents">MethodImplOptions.Synchronized Field</A><BR>
<A HREF="#MethodImplOptions.Unmanaged Field" TARGET="contents">MethodImplOptions.Unmanaged Field</A><BR>
<A HREF="#MethodImplOptions.value__ Field" TARGET="contents">MethodImplOptions.value__ Field</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="MethodImplOptions.ForwardRef Field"><H3>MethodImplOptions.ForwardRef Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>ForwardRef = 16;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Specifies that the method is declared, but its implementation is
      provided elsewhere. <P>

[<I>Note</I>: For most languages, it is recommended 
      that the notion of &quot;forward&quot; be attached to methods using language syntax
      instead of custom attributes. ]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodImplOptions.InternalCall Field"><H3>MethodImplOptions.InternalCall Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>InternalCall = 4096;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Specifies an internal call.<P>

[<I>Note</I>: An internal call
      is a call to a method implemented within the system itself, providing
      additional functionality that regular managed code cannot provide. System.Object.MemberwiseClone
      is an example of an internally called method.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodImplOptions.NoInlining Field"><H3>MethodImplOptions.NoInlining Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>NoInlining = 8;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Specifies that the method is not permitted to be inlined.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodImplOptions.Synchronized Field"><H3>MethodImplOptions.Synchronized Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>Synchronized = 32;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Specifies the method can be executed by only one thread at a time.<P>

This option specifies that before a thread can execute the target method, the
      thread is required to acquire a lock on either the current
      instance or the <A HREF="../../../System/Type.html" TARGET="contents">Type</A>
      object for the method&apos;s class. If the target method is an instance method, the
      lock is on the current instance. If the target is a static method, the lock is
      on the <A HREF="../../../System/Type.html" TARGET="contents">Type</A> object. Specifying this option causes the target method to behave as though its
      statements are enclosed by System.Threading.Monitor.Enter(System.Object) and System.Threading.Monitor.Exit(System.Object)
      statements locking the previous described object. This option and the <A HREF="../../../System/Threading/Monitor.html" TARGET="contents">Monitor</A> methods are functionally equivalent, and both
      are functionally equivalent to enclosing the target method&apos;s code in a C# lock
      (this)
      statement. <P>

[<I>Note</I>: Because this option holds the lock for
         the duration of the target method, it should be used only when the entire method
         must be single threaded. Use the <A HREF="../../../System/Threading/Monitor.html" TARGET="contents">Monitor</A> methods (or the C#
         lock statement) if the object lock can be taken after the method begins, or
         released before the method ends. Any mechanism that uses locks can cause an
         application to experience deadlocks and performance degradation; for these
         reasons, use this option with care.<P>

 For most languages, it is recommended that the notion of
         &quot;synchronized&quot; be attached to methods using language syntax instead of custom
         attributes.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodImplOptions.Unmanaged Field"><H3>MethodImplOptions.Unmanaged Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>Unmanaged = 4;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Specifies that the method is implemented in unmanaged code.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodImplOptions.value__ Field"><H3>MethodImplOptions.value__ Field</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>value__;</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodImplOptions.html" TARGET="contents">System.Runtime.CompilerServices.MethodImplOptions Enum</A>, <A HREF="CompilerServices.html" TARGET="members">System.Runtime.CompilerServices Namespace</A>
</BLOCKQUOTE>

</A></BODY>
</HTML>
