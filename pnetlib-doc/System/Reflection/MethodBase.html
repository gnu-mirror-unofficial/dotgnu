<HTML>
<HEAD>
<TITLE>System.Reflection.MethodBase Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Reflection.MethodBase Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract class MethodBase : MemberInfo</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="MemberInfo.html" TARGET="contents">MemberInfo</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;MethodBase<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Provides information about methods and constructors.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: <CODE>MethodBase </CODE>
is used 
      to represent method types.<P>

The Base Class Library includes the following derived 
      types:<P>

<UL>
<LI><A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A></LI>
<LI><A HREF="ConstructorInfo.html" TARGET="contents">ConstructorInfo</A></LI>
</UL>
]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

MethodBase Constructors<P>

<A HREF="#MethodBase%20Constructor" TARGET="contents">MethodBase Constructor</A><BR>
<P>

MethodBase Methods<P>

<A HREF="#MethodBase.GetGenericArguments%20Method" TARGET="contents">MethodBase.GetGenericArguments Method</A><BR>
<A HREF="#MethodBase.GetMethodFromHandle%20Method" TARGET="contents">MethodBase.GetMethodFromHandle Method</A><BR>
<A HREF="#MethodBase.GetParameters%20Method" TARGET="contents">MethodBase.GetParameters Method</A><BR>
<A HREF="#MethodBase.Invoke%28System.Object%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method" TARGET="contents">MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method</A><BR>
<A HREF="#MethodBase.Invoke%28System.Object%2C%20System.Object%5B%5D%29%20Method" TARGET="contents">MethodBase.Invoke(System.Object, System.Object[]) Method</A><BR>
<P>

MethodBase Properties<P>

<A HREF="#MethodBase.Attributes%20Property" TARGET="contents">MethodBase.Attributes Property</A><BR>
<A HREF="#MethodBase.ContainsGenericParameters%20Property" TARGET="contents">MethodBase.ContainsGenericParameters Property</A><BR>
<A HREF="#MethodBase.IsGenericMethod%20Property" TARGET="contents">MethodBase.IsGenericMethod Property</A><BR>
<A HREF="#MethodBase.IsGenericMethodDefinition%20Property" TARGET="contents">MethodBase.IsGenericMethodDefinition Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase%20Constructor"><H3>MethodBase Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected MethodBase();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Constructs a new instance of the <A HREF="MethodBase.html" TARGET="contents">MethodBase</A>
class.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.GetGenericArguments%20Method"><H3>MethodBase.GetGenericArguments Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual Type[] GetGenericArguments()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../../System/Type.html" TARGET="contents">Type</A> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../../System/Type.html" TARGET="contents">Type</A> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/NotSupportedException.html" TARGET="contents">NotSupportedException</A></TD><TD>Default behavior when not overridden in a derived class.<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default behavior, when not overridden in a derived class, is to throw <A HREF="../../System/NotSupportedException.html" TARGET="contents">NotSupportedException</A>. In other words, derived classes do not support generics by default.<P>

The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.<P>

<UL>
<LI>If the current method is a closed constructed method (that is, the System.Reflection.MethodBase.ContainsGenericParameters property returns <CODE>false</CODE>
), the array returned by the System.Reflection.MethodBase.GetGenericArguments method contains the types that have been assigned to the generic type parameters of the generic method definition.<P>

</LI>
<LI>If the current method is a generic method definition, the array contains the type parameters. <P>

</LI>
<LI>If the current method is an open constructed method (that is, the System.Reflection.MethodBase.ContainsGenericParameters property returns <CODE>true</CODE>
) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters. Use the System.Type.IsGenericParameter property to tell them apart.<P>

</LI>
</UL>
For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.GetMethodFromHandle%20Method"><H3>MethodBase.GetMethodFromHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets method information by using the method&apos;s internal
      metadata representation (handle).<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>handle</DT>
<DD>The method&apos;s <A HREF="../../System/RuntimeMethodHandle.html" TARGET="contents">RuntimeMethodHandle</A> handle.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodBase.html" TARGET="contents">MethodBase</A> object containing information about the method.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handles are valid only in the application domain in which they were obtained.<P>

</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
RuntimeInfrastructure
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.GetParameters%20Method"><H3>MethodBase.GetParameters Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract ParameterInfo[] GetParameters();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the parameters of the method or
      constructor reflected by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 An array of <A HREF="ParameterInfo.html" TARGET="contents">ParameterInfo</A> objects that
   contain information that matches the signature of the method or constructor
   reflected by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.Invoke%28System.Object%2C%20System.Reflection.BindingFlags%2C%20System.Reflection.Binder%2C%20System.Object%5B%5D%2C%20System.Globalization.CultureInfo%29%20Method"><H3>MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the method or constructor reflected by the current instance as
      determined by the specified arguments.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>obj</DT>
<DD>An instance of the type that contains the method reflected by the current instance. If the method is static, <I>obj</I> is ignored. For non-static methods, <I>obj</I> is an instance of a class that inherits or declares the method. </DD>
<DT> invokeAttr</DT>
<DD>A <A HREF="BindingFlags.html" TARGET="contents">BindingFlags</A> value that controls the binding process.</DD>
<DT> binder</DT>
<DD>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <CODE>MemberInfo</CODE>
 objects via reflection. If <I>binder</I> is <CODE>null</CODE>
 , the default binder is used.</DD>
<DT> parameters</DT>
<DD>An array of objects that match the number, order and type of the parameters for the constructor or method reflected by the current instance. If the member reflected by the current instance takes no parameters, specify either an array with zero elements or <CODE>null</CODE>
 . [<I>Note</I>: Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <CODE>null</CODE>
. For value-type elements, this value is 0, 0.0, or <CODE>false</CODE>
, depending on the specific element type. If the method or constructor reflected by the current instance is <CODE>static</CODE>
 , this parameter is ignored.]<P>

<P>

</DD>
<DT> culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../System/Object.html" TARGET="contents">Object</A> that
   contains the return value of the invoked method, or a re-initialized object if a
   constructor was invoked.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The types of the elements of <I>parameters</I> do not match the types of the parameters accepted by the constructor or method reflected by the current instance, under the constraints of the default binder.</TD></TR>
<TR><TD><A HREF="TargetException.html" TARGET="contents">TargetException</A></TD><TD>The constructor or method reflected by the current instance is non-static, and <I>obj</I> is <CODE>null</CODE>
 or is of a type that does not implement the member reflected by the current instance.</TD></TR>
<TR><TD><A HREF="TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The method reflected by the current instance threw an exception.</TD></TR>
<TR><TD><A HREF="TargetParameterCountException.html" TARGET="contents">TargetParameterCountException</A></TD><TD><I>parameters</I>.Length does not equal the number of parameters required by the contract of the constructor or method reflected by the current instance.</TD></TR>
<TR><TD><A HREF="../../System/MemberAccessException.html" TARGET="contents">MemberAccessException</A></TD><TD>The caller does not have permission to execute the method or constructor.</TD></TR>
<TR><TD><A HREF="../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The type that declares the method is an open generic type. That is, System.Type.ContainsGenericParameters returns <CODE>true</CODE>
 for the declaring type.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Optional parameters can not be omitted in calls to
   System.Reflection.MethodBase.Invoke(System.Object,System.Object[])
   .<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.Invoke%28System.Object%2C%20System.Object%5B%5D%29%20Method"><H3>MethodBase.Invoke(System.Object, System.Object[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public object Invoke(object obj, object[] parameters);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Invokes the method or constructor reflected by the current instance
      on the specified object and using the specified arguments.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>obj</DT>
<DD>An instance of a type that contains the constructor or method reflected by the current instance. If the member is static, <I>obj</I> is ignored. For non-static methods, <I>obj</I> is an instance of a class that inherits or declares the method.</DD>
<DT> parameters</DT>
<DD>An array objects that match the number, order and type of the parameters for the constructor or method reflected by the current instance. If the member reflected by the current instance takes no parameters, specify either an array with zero elements or <CODE>null</CODE>
 . [<I>Note</I>: Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <CODE>null</CODE>
. For value-type elements, this value is 0, 0.0, or <CODE>false</CODE>
, depending on the specific element type. If the method or constructor reflected by the current instance is <CODE>static</CODE>
 , this parameter is ignored.]<P>

<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../System/Object.html" TARGET="contents">Object</A> that contains the return
   value of the invoked method, or a re-initialized object if a constructor was invoked.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The types of the elements of <I>parameters</I> do not match the types of the parameters accepted by the constructor or method reflected by the current instance, under the constraints of  the default binder.</TD></TR>
<TR><TD><A HREF="TargetException.html" TARGET="contents">TargetException</A></TD><TD>The constructor or method reflected by the current instance is non-static and <I>obj</I> is <CODE>null</CODE>
, or is of a type that does not implement the member reflected by the current instance.</TD></TR>
<TR><TD><A HREF="TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The constructor or method reflected by the current instance threw an exception.</TD></TR>
<TR><TD><A HREF="TargetParameterCountException.html" TARGET="contents">TargetParameterCountException</A></TD><TD><I>parameters</I>.Length does not equal the number of parameters required by the contract of the member reflected by the current instance.</TD></TR>
<TR><TD><A HREF="../../System/MemberAccessException.html" TARGET="contents">MemberAccessException</A></TD><TD>The caller does not have permission to execute the method or constructor.</TD></TR>
<TR><TD><A HREF="../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The type that declares the method is an open generic type. That is, System.Type.ContainsGenericParameters returns <CODE>true</CODE>
 for the declaring type.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Reflection.MethodBase.Invoke(System.Object,System.Object[]) is equivalent to System.Reflection.MethodBase.Invoke(System.Object,System.Object[])(<I>obj</I>,
   (<CODE>BindingFlags</CODE>
)0, <CODE>null</CODE>
, <I>parameters</I>,
<CODE>null</CODE>
).<P>

Optional parameters cannot be omitted in calls to System.Reflection.MethodBase.Invoke(System.Object,System.Object[]) .<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.Attributes%20Property"><H3>MethodBase.Attributes Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MethodAttributes Attributes { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the attributes of the method reflected by the
      current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodAttributes.html" TARGET="contents">MethodAttributes</A> value that signifies the attributes of
   the method reflected by the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is read-only.<P>

This property
         gets a <A HREF="MethodAttributes.html" TARGET="contents">MethodAttributes</A> value that
         indicates the attributes set in the metadata of the method reflected by the
         current instance.<P>

]<P>

[<I>Usage</I>: Use this property
      to determine the accessibility, layout, and semantics of the constructor
      or method reflected by the current instance. Also use this property to
      determine if the member reflected by the current instance is implemented in
      native code or has a special name.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 The following example demonstrates using this property to
      obtain the attributes of three methods.<P>

<PRE>using System;
using System.Reflection;

abstract class MyBaseClass
{

   abstract public void MyPublicInstanceMethod();

}

class MyDerivedClass : MyBaseClass
{

   public override void MyPublicInstanceMethod() {}
   private static void MyPrivateStaticMethod() {}

}

class MethodAttributesExample
{

   static void PrintMethodAttributes(Type t)
   {

      string str;
      MethodInfo[] miAry = t.GetMethods( BindingFlags.Static |
         BindingFlags.Instance | BindingFlags.Public |
         BindingFlags.NonPublic | BindingFlags.DeclaredOnly );
      foreach (MethodInfo mi in miAry)
      {

         Console.WriteLine(&quot;Method {0} is: &quot;, mi.Name);
         str = ((mi.Attributes &amp; MethodAttributes.Static) != 0) ?
            &quot;Static&quot; : &quot;Instance&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.Public) != 0) ?
            &quot;Public&quot; : &quot;Not-Public&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.HideBySig) != 0) ?
            &quot;HideBySig&quot; : &quot;Hide-by-name&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.Abstract) != 0) ?
            &quot;Abstract&quot; : String.Empty;
         Console.WriteLine(str);

      }

   }

   public static void Main()
   {

      PrintMethodAttributes(typeof(MyBaseClass));
      PrintMethodAttributes(typeof(MyDerivedClass));

   }

}
      </PRE>
The output is<P>

<CODE>Method MyPublicInstanceMethod is:<P>

Instance Public HideBySig Abstract<P>

Method MyPublicInstanceMethod is:<P>

Instance Public HideBySig<P>

Method MyPrivateStaticMethod is:<P>

Static Not-Public HideBySig<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.ContainsGenericParameters%20Property"><H3>MethodBase.ContainsGenericParameters Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool ContainsGenericParameters { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether a generic method contains unassigned generic type parameters.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current method  contains unassigned generic type parameters; otherwise <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default behavior, when not overridden in a derived class, is to return <CODE>false</CODE>
. In other words, by default, derived classes do not support generics.<P>

In order to invoke a generic method, there must be no generic type definitions or open constructed types in the type arguments of the method itself, or in any enclosing types. If the System.Reflection.MethodBase.ContainsGenericParameters  property returns <CODE>true</CODE>
, the method cannot be invoked.<P>

The System.Reflection.MethodBase.ContainsGenericParameters property searches recursively for type parameters. For example, it returns <CODE>true</CODE>
 for any method in an open type <CODE>A&lt;T&gt;</CODE>
, even though the method itself is not generic. Contrast this with the behavior of the System.Reflection.MethodBase.IsGenericMethod property, which returns <CODE>false</CODE>
 for such a method.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.IsGenericMethod%20Property"><H3>MethodBase.IsGenericMethod Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsGenericMethod { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current object is a generic method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current object is a generic method; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default behavior, when not overridden in a derived class, is to return <CODE>false</CODE>
. In other words, by default, derived classes do not support generics.<P>

Use this property to determine whether the current  <A HREF="MethodBase.html" TARGET="contents">MethodBase</A> object represents a generic method. Use the System.Reflection.MethodBase.ContainsGenericParameters property to determine whether the current <A HREF="MethodBase.html" TARGET="contents">MethodBase</A> object represents an open constructed method or a closed constructed method.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase.IsGenericMethodDefinition%20Property"><H3>MethodBase.IsGenericMethodDefinition Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public virtual bool IsGenericMethodDefinition { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current System.Reflection.MethodBase represents a definition of a generic method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current <A HREF="MethodBase.html" TARGET="contents">MethodBase</A>  object represents the definition of a generic method; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The default behavior, when not overridden in a derived class, is to return <CODE>false</CODE>
. In other words, by default, derived classes do not support generics.<P>

If the current <A HREF="MethodBase.html" TARGET="contents">MethodBase</A> represents a generic method definition, then:<P>

<UL>
<LI>System.Reflection.MethodBase.IsGenericMethodDefinition returns <CODE>true</CODE>
.<P>

</LI>
<LI>For each <A HREF="../../System/Type.html" TARGET="contents">Type</A> object in the array returned by the System.Reflection.MethodBase.GetGenericArguments method: The System.Type.IsGenericParameter property returns <CODE>true</CODE>
; the System.Type.DeclaringMethod returns the current instance; and the System.Type.GenericParameterPosition property is the same as the position of the <A HREF="../../System/Type.html" TARGET="contents">Type</A> object in the array.<P>

</LI>
</UL>
For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</BODY>
</HTML>
