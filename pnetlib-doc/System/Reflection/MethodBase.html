<HTML>
<HEAD>
<TITLE>System.Reflection.MethodBase Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Reflection.MethodBase Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public abstract class MethodBase : MemberInfo</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="MemberInfo.html" TARGET="contents">MemberInfo</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;MethodBase<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Provides access to method and constructor metadata.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Note</I>: <CODE>MethodBase </CODE>
is used 
      to represent method types.<P>

The Base Class Library includes the following derived 
      types:<P>

<UL>
<LI><A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A></LI>
<LI><A HREF="ConstructorInfo.html" TARGET="contents">ConstructorInfo</A></LI>
</UL>
]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

MethodBase Constructors<P>

<A HREF="#MethodBase Constructor" TARGET="contents">MethodBase Constructor</A><BR>
<P>

MethodBase Methods<P>

<A HREF="#MethodBase.GetMethodFromHandle Method" TARGET="contents">MethodBase.GetMethodFromHandle Method</A><BR>
<A HREF="#MethodBase.GetParameters Method" TARGET="contents">MethodBase.GetParameters Method</A><BR>
<A HREF="#MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method" TARGET="contents">MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method</A><BR>
<A HREF="#MethodBase.Invoke(System.Object, System.Object[]) Method" TARGET="contents">MethodBase.Invoke(System.Object, System.Object[]) Method</A><BR>
<P>

MethodBase Properties<P>

<A HREF="#MethodBase.Attributes Property" TARGET="contents">MethodBase.Attributes Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="MethodBase Constructor"><H3>MethodBase Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>protected MethodBase();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Constructs a new instance of the <A HREF="MethodBase.html" TARGET="contents">MethodBase</A>
class.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodBase.GetMethodFromHandle Method"><H3>MethodBase.GetMethodFromHandle Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets method information by using the method&apos;s internal
      metadata representation (handle).<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>handle</DT>
<DD>The method&apos;s <A HREF="../../System/RuntimeMethodHandle.html" TARGET="contents">RuntimeMethodHandle</A> handle.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodBase.html" TARGET="contents">MethodBase</A> object containing information about the method.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The handles are valid only in the application domain in which they were obtained.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodBase.GetParameters Method"><H3>MethodBase.GetParameters Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public abstract ParameterInfo[] GetParameters();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns the parameters of the method or
      constructor reflected by the current instance.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 An array of <A HREF="ParameterInfo.html" TARGET="contents">ParameterInfo</A> objects that
   contain information that matches the signature of the method or constructor
   reflected by the current
   instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: As described above.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method"><H3>MethodBase.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public abstract object Invoke(object obj, BindingFlags invokeAttr, Binder binder, object[] parameters, CultureInfo culture);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Invokes the method or constructor reflected by the current instance as
      determined by the specified arguments.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>obj</DT>
<DD>An instance of the type that contains the method reflected by the current instance. If the method is static, <I>obj</I> is ignored. For non-static methods, <I>obj</I> is an instance of a class that inherits or declares the method. </DD>
<DT> invokeAttr</DT>
<DD>A <A HREF="BindingFlags.html" TARGET="contents">BindingFlags</A> value that controls the binding process.</DD>
<DT> binder</DT>
<DD>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <CODE>MemberInfo</CODE>
 objects via reflection. If <I>binder</I> is <CODE>null</CODE>
 , the default binder is used.</DD>
<DT> parameters</DT>
<DD>An array of objects that match the number, order and type of the parameters for the constructor or method reflected by the current instance. If the member reflected by the current instance takes no parameters, specify either an array with zero elements or <CODE>null</CODE>
 . [<I>Note</I>: Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <CODE>null</CODE>
. For value-type elements, this value is 0, 0.0, or <CODE>false</CODE>
, depending on the specific element type. If the method or constructor reflected by the current instance is <CODE>static</CODE>
 , this parameter is ignored.]<P>

<P>

</DD>
<DT> culture</DT>
<DD>The only defined value for this parameter is <CODE>null</CODE>
 .<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="../../System/Object.html" TARGET="contents">Object</A> that
   contains the return value of the invoked method, or a re-initialized object if a
   constructor was invoked.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The types of the elements of <I>parameters</I> do not match the types of the parameters accepted by the constructor or method reflected by the current instance, under the constraints of <I>binder</I> . </TD></TR>
<TR><TD><A HREF="TargetException.html" TARGET="contents">TargetException</A></TD><TD>The constructor or method reflected by the current instance is non-static, and <I>obj</I> is <CODE>null</CODE>
 or is of a type that does not implement the member reflected by the current instance.</TD></TR>
<TR><TD><A HREF="TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The method reflected by the current instance threw an exception.</TD></TR>
<TR><TD><A HREF="TargetParameterCountException.html" TARGET="contents">TargetParameterCountException</A></TD><TD><I>parameters</I>.Length does not equal the number of parameters required by the contract of the constructor or method reflected by the current instance.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Optional parameters can not be omitted in calls to
   System.Reflection.MethodBase.Invoke(System.Object,System.Object[])
   .<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodBase.Invoke(System.Object, System.Object[]) Method"><H3>MethodBase.Invoke(System.Object, System.Object[]) Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public object Invoke(object obj, object[] parameters);</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Invokes the method or constructor reflected by the current instance
      on the specified object and using the specified arguments.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>obj</DT>
<DD>An instance of a type that contains the constructor or method reflected by the current instance. If the member is static, <I>obj</I> is ignored. For non-static methods, <I>obj</I> is an instance of a class that inherits or declares the method.</DD>
<DT> parameters</DT>
<DD>An array objects that match the number, order and type of the parameters for the constructor or method reflected by the current instance. If the member reflected by the current instance takes no parameters, specify either an array with zero elements or <CODE>null</CODE>
 . [<I>Note</I>: Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <CODE>null</CODE>
. For value-type elements, this value is 0, 0.0, or <CODE>false</CODE>
, depending on the specific element type. If the method or constructor reflected by the current instance is <CODE>static</CODE>
 , this parameter is ignored.]<P>

<P>

</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
 A <A HREF="../../System/Object.html" TARGET="contents">Object</A> that contains the return
   value of the invoked method, or a re-initialized object if a constructor was invoked.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#CCCCFF"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The types of the elements of <I>parameters</I> do not match the types of the parameters accepted by the constructor or method reflected by the current instance, under the constraints of <I>binder</I> .</TD></TR>
<TR><TD><A HREF="TargetException.html" TARGET="contents">TargetException</A></TD><TD>The constructor or method reflected by the current instance is non-static, and <I>obj</I> is <CODE>null</CODE>
 or is of a type that does not implement the member reflected by the current instance.</TD></TR>
<TR><TD><A HREF="TargetInvocationException.html" TARGET="contents">TargetInvocationException</A></TD><TD>The constructor or method reflected by the current instance threw an exception.</TD></TR>
<TR><TD><A HREF="TargetParameterCountException.html" TARGET="contents">TargetParameterCountException</A></TD><TD><I>parameters</I>.Length does not equal the number of parameters required by the contract of the member reflected by the current instance.</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
This version of System.Reflection.MethodBase.Invoke(System.Object,System.Object[]) is equivalent to System.Reflection.MethodBase.Invoke(System.Object,System.Object[])(<I>obj</I>,
   (<CODE>BindingFlags</CODE>
)0, <CODE>null</CODE>
, <I>parameters</I>,
<CODE>null</CODE>
).<P>

Optional parameters can not be omitted in calls to System.Reflection.MethodBase.Invoke(System.Object,System.Object[]) .<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A><HR>

<A NAME="MethodBase.Attributes Property"><H3>MethodBase.Attributes Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#EEEEFF"><PRE>public abstract MethodAttributes Attributes { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the attributes of the method reflected by the
      current instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodAttributes.html" TARGET="contents">MethodAttributes</A> value that signifies the attributes of
   the method reflected by the current instance.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is read-only.<P>

This property
         gets a <A HREF="MethodAttributes.html" TARGET="contents">MethodAttributes</A> value that
         indicates the attributes set in the metadata of the method reflected by the
         current instance.<P>

]<P>

[<I>Usage</I>: Use this property
      to determine the accessibility, layout, and semantics of the constructor
      or method reflected by the current instance. Also use this property to
      determine if the member reflected by the current instance is implemented in
      native code or has a special name.]<P>

<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
 The following example demonstrates using this property to
      obtain the attributes of three methods.<P>

<PRE>using System;
using System.Reflection;

abstract class MyBaseClass
{

   abstract public void MyPublicInstanceMethod();

}

class MyDerivedClass : MyBaseClass
{

   public override void MyPublicInstanceMethod() {}
   private static void MyPrivateStaticMethod() {}

}

class MethodAttributesExample
{

   static void PrintMethodAttributes(Type t)
   {

      string str;
      MethodInfo[] miAry = t.GetMethods( BindingFlags.Static |
         BindingFlags.Instance | BindingFlags.Public |
         BindingFlags.NonPublic | BindingFlags.DeclaredOnly );
      foreach (MethodInfo mi in miAry)
      {

         Console.WriteLine(&quot;Method {0} is: &quot;, mi.Name);
         str = ((mi.Attributes &amp; MethodAttributes.Static) != 0) ?
            &quot;Static&quot; : &quot;Instance&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.Public) != 0) ?
            &quot;Public&quot; : &quot;Not-Public&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.HideBySig) != 0) ?
            &quot;HideBySig&quot; : &quot;Hide-by-name&quot;;
         Console.Write(str + &quot; &quot;);
         str = ((mi.Attributes &amp; MethodAttributes.Abstract) != 0) ?
            &quot;Abstract&quot; : String.Empty;
         Console.WriteLine(str);

      }

   }

   public static void Main()
   {

      PrintMethodAttributes(typeof(MyBaseClass));
      PrintMethodAttributes(typeof(MyDerivedClass));

   }

}
      </PRE>
The output is<P>

<CODE>Method MyPublicInstanceMethod is:<P>

Instance Public HideBySig Abstract<P>

Method MyPublicInstanceMethod is:<P>

Instance Public HideBySig<P>

Method MyPrivateStaticMethod is:<P>

Static Not-Public HideBySig<P>

</CODE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodBase.html" TARGET="contents">System.Reflection.MethodBase Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</A></BODY>
</HTML>
