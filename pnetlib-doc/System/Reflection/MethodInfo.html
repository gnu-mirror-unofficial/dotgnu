<HTML>
<HEAD>
<TITLE>System.Reflection.MethodInfo Class</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<H3>System.Reflection.MethodInfo Class</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract class MethodInfo : MethodBase</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Base Types</H4>

<BLOCKQUOTE>
<A HREF="../../System/Object.html" TARGET="contents">Object</A><BR>
&nbsp;&nbsp;<A HREF="MemberInfo.html" TARGET="contents">MemberInfo</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="MethodBase.html" TARGET="contents">MethodBase</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MethodInfo<P>

</BLOCKQUOTE>

<H4>Assembly</H4>

<BLOCKQUOTE>
mscorlib
</BLOCKQUOTE>

<H4>Library</H4>

<BLOCKQUOTE>
Reflection
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Discovers the attributes of a method and provides access to method metadata.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Instances of <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> are obtained by calling the System.Type.GetMethods or System.Type.GetMethod method of a <A HREF="../../System/Type.html" TARGET="contents">Type</A> object or of an object that derives from System.Type, or by calling the System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 method of a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that represents a generic method definition.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Note</I>: When operating on the given kinds of methods, the following properties return the result as shown:<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Property</TH><TH>Non-Generic</TH></TR>
<TR><TD><CODE>IsGenericMethodDefinition</CODE>
</TD><TD>False</TD></TR>
<TR><TD><CODE>ContainsGenericParameters</CODE>
</TD><TD>False</TD></TR>
<TR><TD><CODE>IsGenericMethod</CODE>
</TD><TD>False</TD></TR>
</TABLE>
]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<H4>Members</H4>

<BLOCKQUOTE>
<P>

MethodInfo Constructors<P>

<A HREF="#MethodInfo%20Constructor" TARGET="contents">MethodInfo Constructor</A><BR>
<P>

MethodInfo Methods<P>

<A HREF="#MethodInfo.GetBaseDefinition%20Method" TARGET="contents">MethodInfo.GetBaseDefinition Method</A><BR>
<A HREF="#MethodInfo.GetGenericArguments%20Method" TARGET="contents">MethodInfo.GetGenericArguments Method</A><BR>
<A HREF="#MethodInfo.GetGenericMethodDefinition%20Method" TARGET="contents">MethodInfo.GetGenericMethodDefinition Method</A><BR>
<A HREF="#MethodInfo.MakeGenericMethod%20Method" TARGET="contents">MethodInfo.MakeGenericMethod Method</A><BR>
<P>

MethodInfo Properties<P>

<A HREF="#MethodInfo.ContainsGenericParameters%20Property" TARGET="contents">MethodInfo.ContainsGenericParameters Property</A><BR>
<A HREF="#MethodInfo.IsGenericMethod%20Property" TARGET="contents">MethodInfo.IsGenericMethod Property</A><BR>
<A HREF="#MethodInfo.IsGenericMethodDefinition%20Property" TARGET="contents">MethodInfo.IsGenericMethodDefinition Property</A><BR>
<A HREF="#MethodInfo.ReturnType%20Property" TARGET="contents">MethodInfo.ReturnType Property</A><BR>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo%20Constructor"><H3>MethodInfo Constructor</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>protected MethodInfo();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Constructs a new instance of the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> class.<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.GetBaseDefinition%20Method"><H3>MethodInfo.GetBaseDefinition Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract MethodInfo GetBaseDefinition();</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
 Returns a new <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> instance that reflects the first definition
   of the method reflected by the current instance in
   the inheritance hierarchy of that method. <P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A new <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> instance that reflects the first definition
   of the method reflected by the
   current instance in the inheritance hierarchy of that method. <P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: System.Reflection.MethodInfo.GetBaseDefinition proceeds along the inheritance
      hierarchy of the method reflected by the current instance, returning a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>
      instance that reflects the first definition in the hierarchy of that
      method.<P>

The method declaration to be reflected by the
      new <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>
      instance
      is determined as follows:<P>

<UL>
<LI>
         
         If the method reflected by the current instance
         overrides a virtual definition in the base class, the virtual definition is
         reflected.</LI>
<LI>
         
         If the method reflected
         
         by the current instance is specified with the <CODE>new</CODE>
 keyword, the
         current instance is returned.</LI>
<LI>
         
         If the method reflected by the current instance is
         not defined in the type of the object on which System.Reflection.MethodInfo.GetBaseDefinition is called, the method definition of the furthest ancestor in
         the class hierarchy is reflected.</LI>
</UL>
]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.GetGenericArguments%20Method"><H3>MethodInfo.GetGenericArguments Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override Type[] GetGenericArguments()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns an array of <A HREF="../../System/Type.html" TARGET="contents">Type</A> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
An array of <A HREF="../../System/Type.html" TARGET="contents">Type</A> objects that represent the type arguments  of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.<P>

If the current method is a closed constructed method (that is, the System.Reflection.MethodInfo.ContainsGenericParameters property returns <CODE>false</CODE>
), the array returned by the System.Reflection.MethodInfo.GetGenericArguments method contains the types that have been assigned to the generic type parameters of the generic method definition. <P>

If the current method is a generic method definition, the array contains the type parameters. <P>

If the current method is an open constructed method (that is, the System.Reflection.MethodInfo.ContainsGenericParameters property returns <CODE>true</CODE>
) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters. Use the System.Type.IsGenericParameter property to tell them apart.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following code shows how to get the type arguments of a generic method and display them. (It is part of a larger example for the method  System.Reflection.MethodInfo.MakeGenericMethod.)<P>

<PRE>// If this is a generic method, display its type arguments.
//
if (mi.IsGenericMethod)
{
        Type[] typeArguments = mi.GetGenericArguments();

        Console.WriteLine(&quot;\tList type arguments ({0}):&quot;, 
                typeArguments.Length);

        foreach (Type tParam in typeArguments)
        {
                // IsGenericParameter is true only for generic type
                // parameters.
                //
                if (tParam.IsGenericParameter)
                {
                    Console.WriteLine(&quot;\t\t{0}  (unbound - parameter position {1})&quot;,
                        tParam,
                        tParam.GenericParameterPosition);
                }
                else
                {
                    Console.WriteLine(&quot;\t\t{0}&quot;, tParam);
                }
            }
        }
        else
        {
            Console.WriteLine(&quot;\tThis is not a generic method.&quot;);
        }
}</PRE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.GetGenericMethodDefinition%20Method"><H3>MethodInfo.GetGenericMethodDefinition Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override MethodInfo GetGenericMethodDefinition()</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object that represents a generic method definition from which the current method can be constructed.<P>

</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object representing a generic method definition from which the current method can be constructed.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current method is not a generic method. That is, System.Reflection.MethodInfo.IsGenericMethod returns <CODE>false</CODE>
. </TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If you call System.Reflection.MethodInfo.GetGenericMethodDefinition on a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that already represents a generic method definition, it returns the current <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>.<P>

If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.<P>

A generic method definition is a template from which methods can be constructed. For example, from the generic method definition <CODE>T M&lt;T&gt;(T t)</CODE>
 you can construct and invoke the method <CODE>int M&lt;int&gt;(int t)</CODE>
. Given a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object representing this constructed method, the System.Reflection.MethodInfo.GetGenericMethodDefinition method returns the generic method definition.<P>

If two constructed methods are created from the same generic method definition, the System.Reflection.MethodInfo.GetGenericMethodDefinition method returns the same <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object for both methods.<P>

If you call System.Reflection.MethodInfo.GetGenericMethodDefinition on a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that already represents a generic method definition, it returns the current <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>.<P>

If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type. For example, consider the following C# code:<P>

<CODE>class B&lt;U,V&gt; {}</CODE>
<P>

<CODE>class C&lt;T&gt; { B&lt;T,S&gt; M&lt;S&gt;() {}}</CODE>
<P>

In the constructed type <CODE>C&lt;int&gt;</CODE>
, the generic method <CODE>M</CODE>
 returns <CODE>B&lt;int, S&gt;</CODE>
. In the open type <CODE> C&lt;T&gt;</CODE>
, <CODE>M</CODE>
 returns <CODE>B&lt;T, S&gt;</CODE>
. In both cases, the System.Reflection.MethodInfo.IsGenericMethodDefinition property returns true for the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that represents <CODE>M</CODE>
, soSystem.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 can be called on both <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> objects. In the case of the constructed type, the result of calling System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 is a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that can be invoked. In the case of the open type, the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> returned by System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 cannot be invoked.  <P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following code shows a class with a generic method and the code required to obtain a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>  for the method, bind the method to type arguments, and get the original generic type definition back from the bound method. (It is part of a larger example for the method System.Reflection.MethodInfo.MakeGenericMethod.)<P>

<PRE>// Define a class with a generic method.
public class Example
{
    public static void Generic&lt;T&gt;(T toDisplay)
    {
        Console.WriteLine(&quot;\nHere it is: {0}&quot;, toDisplay);
    }
}

// ...
// Create a Type object representing class Example, and
// get a MethodInfo representing the generic method.
//
Type ex = Type.GetType(&quot;Example&quot;);
MethodInfo mi = ex.GetMethod(&quot;Generic&quot;);

DisplayGenericMethodInfo(mi);

// Bind the type parameter of the Example method to 
// type int.
//
Type[] arguments = {typeof(int)};
MethodInfo miBound = mi.MakeGenericMethod(arguments);

DisplayGenericMethodInfo(miBound);


// ...
// Get the generic type definition from the closed method,
// and show it&apos;s the same as the original definition.
//
MethodInfo miDef = miBound.GetGenericMethodDefinition();
Console.WriteLine(&quot;\nThe definition is the same: {0}&quot;,
       miDef == mi);
</PRE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.MakeGenericMethod%20Method"><H3>MethodInfo.MakeGenericMethod Method</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override MethodInfo MakeGenericMethod(params System.Type[] typeArguments)</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object representing the resulting constructed method.<P>

</BLOCKQUOTE>

<H4>Parameters</H4>

<BLOCKQUOTE>
<DL>
<DT>typeArguments</DT>
<DD>An array of types to be substituted for the type parameters of the current generic method.</DD>
</DL>
</BLOCKQUOTE>

<H4>Return Value</H4>

<BLOCKQUOTE>
A <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>  object that represents the constructed method formed by substituting the elements of <I>typeArguments</I> for the type parameters of the current generic method definition.<P>

</BLOCKQUOTE>

<H4>Exceptions</H4>

<BLOCKQUOTE>
<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Exception Type</TH><TH>Condition</TH></TR>
<TR><TD><A HREF="../../System/ArgumentException.html" TARGET="contents">ArgumentException</A></TD><TD>The number of elements in <I>typeArguments</I> is not the same as the number of type parameters of the current generic method definition.<P>

-or-<P>

An element of <I>typeArguments</I> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.<P>

</TD></TR>
<TR><TD><A HREF="../../System/ArgumentNullException.html" TARGET="contents">ArgumentNullException</A></TD><TD><I>typeArguments</I> is <CODE>null</CODE>
. <P>

-or-<P>

Any element of <I>typeArguments</I> is <CODE>null</CODE>
. <P>

</TD></TR>
<TR><TD><A HREF="../../System/InvalidOperationException.html" TARGET="contents">InvalidOperationException</A></TD><TD>The current <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> does not represent the definition of a generic method. (That is, System.Reflection.MethodInfo.IsGenericMethodDefinition  returns <CODE>false</CODE>
).<P>

</TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
The System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object that represents a particular constructed method. If the System.Reflection.MethodInfo.ContainsGenericParameters property of this <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object returns <CODE>true</CODE>
, you can use it to invoke the method or to create a delegate to invoke the method.<P>

Methods constructed with the System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 method can be open; that is, some of their type arguments can be type parameters of enclosing generic types. You might use such open constructed methods when you generate dynamic assemblies. For example, consider the following C# code:<P>

<PRE>class C
{
  T N&lt;T,U&gt;(T t, U u) {...}
  public V M&lt;V&gt;(V v)
  {
    return N&lt;V,int&gt;(v, 42);
  }
}</PRE>
<P>

The method body of M<CODE>M</CODE>
 contains a call to method <CODE>N</CODE>
, specifying the type parameter of <CODE>M</CODE>
 and the type <A HREF="../../System/Int32.html" TARGET="contents">Int32</A>. The System.Reflection.MethodInfo.IsGenericMethodDefinition  property returns <CODE>false</CODE>
 for method <CODE>N&lt;V,int&gt;</CODE>
. The System.Reflection.MethodInfo.ContainsGenericParameters property returns <CODE>true</CODE>
, so method <CODE>N&lt;V,int&gt;</CODE>
 cannot be invoked.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

</BLOCKQUOTE>

<H4>Example</H4>

<BLOCKQUOTE>
The following code demonstrates the properties and methods of System.Reflection.MethodInfo that support the examination of generic methods. The example does the following:<P>

<OL>
<LI>Defines a class that has a generic method.</LI>
<LI>Creates a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that represents the generic method.</LI>
<LI>Displays properties of the generic method definition.</LI>
<LI>Binds the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> to a type, and invokes it.</LI>
<LI>Displays properties of the bound generic method.</LI>
<LI>Retrieves the generic method definition from the bound method.</LI>
</OL>
<PRE>using System;
using System.Reflection;

// Define a class with a generic method.
public class Example
{
    public static void Generic&lt;T&gt;(T toDisplay)
    {
        Console.WriteLine(&quot;\nHere it is: {0}&quot;, toDisplay);
    }
}

public class Test
{
    public static void Main()
    {
        Console.WriteLine(&quot;\n--- Examine a generic method.&quot;);

        // Create a Type object representing class Example, and
        // get a MethodInfo representing the generic method.
        //
        Type ex = Type.GetType(&quot;Example&quot;);
        MethodInfo mi = ex.GetMethod(&quot;Generic&quot;);

        DisplayGenericMethodInfo(mi);

        // Bind the type parameter of the Example method to 
        // type int.
        //
        Type[] arguments = {typeof(int)};
        MethodInfo miBound = mi.MakeGenericMethod(arguments);

        DisplayGenericMethodInfo(miBound);

        // Invoke the method.
        object[] args = {42};
        miBound.Invoke(null, args);

        // Invoke the method normally.
        Example.Generic&lt;int&gt;(42);

        // Get the generic type definition from the closed method,
        // and show it&apos;s the same as the original definition.
        //
        MethodInfo miDef = miBound.GetGenericMethodDefinition();
        Console.WriteLine(&quot;\nThe definition is the same: {0}&quot;,
            miDef == mi);
    }
        
    private static void DisplayGenericMethodInfo(MethodInfo mi)
    {
        Console.WriteLine(&quot;\n{0}&quot;, mi);

        Console.WriteLine(&quot;\tIs this a generic method definition? {0}&quot;, 
            mi.IsGenericMethodDefinition);

        Console.WriteLine(&quot;\tDoes it have generic arguments? {0}&quot;, 
            mi.IsGenericMethod);

        Console.WriteLine(&quot;\tDoes it have unbound generic parameters? {0}&quot;, 
            mi.ContainsGenericParameters);

        // If this is a generic method, display its type arguments.
        //
        if (mi.IsGenericMethod)
        {
            Type[] typeArguments = mi.GetGenericArguments();

            Console.WriteLine(&quot;\tList type arguments ({0}):&quot;, 
                typeArguments.Length);

            foreach (Type tParam in typeArguments)
            {
                // IsGenericParameter is true only for generic type
                // parameters.
                //
                if (tParam.IsGenericParameter)
                {
                    Console.WriteLine(&quot;\t\t{0}  (unbound - parameter position {1})&quot;,
                        tParam,
                        tParam.GenericParameterPosition);
                }
                else
                {
                    Console.WriteLine(&quot;\t\t{0}&quot;, tParam);
                }
            }
        }
        else
        {
            Console.WriteLine(&quot;\tThis is not a generic method.&quot;);
        }
    }
}

/* This example produces the following output:

--- Examine a generic method.

Void Generic[T](T)
        Is this a generic method definition? True
        Does it have generic arguments? True
        Does it have unbound generic parameters? True
        List type arguments (1):
                T  (unbound - parameter position 0)

Void Generic[Int32](Int32)
        Is this a generic method definition? False
        Does it have generic arguments? True
        Does it have unbound generic parameters? False
        List type arguments (1):
                System.Int32

Here it is: 42

Here it is: 42

The definition is the same: True

 */
</PRE>
</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.ContainsGenericParameters%20Property"><H3>MethodInfo.ContainsGenericParameters Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override bool ContainsGenericParameters { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether a generic method contains unassigned generic type parameters.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>  contains unassigned generic type parameters; otherwise <CODE>false</CODE>
.<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
In order to invoke a generic method, there must be no generic type definitions or open constructed types in the type arguments of the method itself, or in any enclosing types. If the System.Reflection.MethodInfo.ContainsGenericParameters property returns <CODE>true</CODE>
, the method cannot be invoked.<P>

The System.Reflection.MethodInfo.ContainsGenericParameters property searches recursively for type parameters. For example, it returns true for any method in an open type <CODE>A&lt;T&gt;</CODE>
, even though the method itself is not generic. Contrast this with the behavior of the System.Reflection.MethodInfo.IsGenericMethod property, which returns false for such a method.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.IsGenericMethod%20Property"><H3>MethodInfo.IsGenericMethod Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override bool IsGenericMethod { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Returns a value that indicates whether the current method is a generic method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the current method is a generic method; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
Use the System.Reflection.MethodInfo.IsGenericMethod property to determine whether a System.Reflection.MethodInfo object represents a generic method. Use the System.Reflection.MethodInfo.ContainsGenericParameters property to determine whether a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object represents an open constructed method or a closed constructed method.<P>

The following table summarizes the invariant conditions for terms specific to generic methods. For other terms used in generic reflection, such as generic type parameter and generic type, see the System.Type.IsGenericType property.<P>

<TABLE BORDER="1" COLS="2" WIDTH="100%">
<TR BGCOLOR="#C0C0C0"><TH>Term</TH><TH>Invariant</TH></TR>
<TR><TD>generic method definition</TD><TD>The System.Reflection.MethodInfo.IsGenericMethodDefinition property is <CODE>true</CODE>
.<P>

Defines a generic method. A constructed method is created by calling the System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 method on a <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> object that represents a generic method definition, and specifying an array of type arguments.<P>

System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
 can be called only on generic method definitions. <P>

Any generic method definition is a generic method, but the converse is not true.<P>

</TD></TR>
<TR><TD>generic method</TD><TD>The System.Reflection.MethodInfo.IsGenericMethod property is <CODE>true</CODE>
.<P>

Can be a generic method definition, an open constructed method, or a closed constructed method. <P>

</TD></TR>
<TR><TD>open constructed method</TD><TD>The System.Reflection.MethodInfo.ContainsGenericParameters property is <CODE>true</CODE>
.<P>

It is not possible to invoke an open constructed method.<P>

</TD></TR>
<TR><TD>closed constructed method</TD><TD>The System.Reflection.MethodInfo.ContainsGenericParameters property is <CODE>false</CODE>
.<P>

When examined recursively, the method has no unassigned generic parameters. The containing type has no generic type parameters, and none of the type arguments have generic type parameters.<P>

</TD></TR>
</TABLE>
<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.IsGenericMethodDefinition%20Property"><H3>MethodInfo.IsGenericMethodDefinition Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public override bool IsGenericMethodDefinition { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets a value that indicates whether the current System.Reflection.MethodInfo represents the definition of a generic method.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
<CODE>true</CODE>
 if the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>  object represents the definition of a generic method; otherwise <CODE>false</CODE>
.
</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
If the current System.Reflection.MethodInfo represents a generic method definition, then:<P>

<UL>
<LI>System.Reflection.MethodInfo.IsGenericMethodDefinition returns <CODE>true</CODE>
.</LI>
<LI>For each <A HREF="../../System/Type.html" TARGET="contents">Type</A> object in the array returned by the System.Reflection.MethodInfo.GetGenericArguments method: The System.Type.IsGenericParameter property returns <CODE>true</CODE>
; the System.Type.DeclaringMethod returns the current <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A>; the System.Type.GenericParameterPosition property is the same as the position of the <A HREF="../../System/Type.html" TARGET="contents">Type</A> object in the array.</LI>
</UL>
Use the System.Reflection.MethodInfo.IsGenericMethodDefinition property to determine whether type arguments have been assigned to the type parameters of a generic method. If type arguments have been assigned, the System.Reflection.MethodInfo.IsGenericMethodDefinition property returns <CODE>false</CODE>
 even if some of the type arguments are <A HREF="../../System/Type.html" TARGET="contents">Type</A> objects that represent type parameters of enclosing types. For example, consider the following C# code:<P>

<PRE>class C
{
  T N&lt;T,U&gt;(T t, U u) {...}
  public V M&lt;V&gt;(V v)
  {
    return N&lt;V,int&gt;(v, 42);
  }
}</PRE>
The method body of <CODE>M</CODE>
 contains a call to method <CODE>N</CODE>
, specifying the type parameter of <CODE>M</CODE>
 and the type <A HREF="../../System/Int32.html" TARGET="contents">Int32</A>. The System.Reflection.MethodInfo.IsGenericMethodDefinition property returns <CODE>false</CODE>
 for method <CODE>N&lt;V,int&gt;</CODE>
.<P>

[<I>Note</I>: Although the open constructed method <CODE>N&lt;V,int&gt;</CODE>
 is not encountered when reflecting over class <CODE>C</CODE>
, it must be generated using System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])<CODE>(System.Type[])</CODE>
.<P>

]<P>

If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type. For example, consider the following C# code:<P>

<PRE>class B&lt;U,V&gt; {}
class C&lt;T&gt; { B&lt;T,S&gt; M&lt;S&gt;() {}}</PRE>
In the constructed type <CODE>C&lt;int&gt;</CODE>
, the generic method <CODE>M</CODE>
 returns <CODE>B&lt;int, S&gt;</CODE>
. In the open type <CODE>C&lt;T&gt;</CODE>
, <CODE>M</CODE>
 returns <CODE>B&lt;T, S&gt;</CODE>
. In both cases, the System.Reflection.MethodInfo.IsGenericMethodDefinition property returns <CODE>true</CODE>
 for the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> that represents <CODE>M</CODE>
.<P>

For a list of the invariant conditions for terms specific to generic methods, see the System.Reflection.MethodInfo.IsGenericMethod  property. For a list of the invariant conditions for other terms used in generic reflection, see the System.Type.IsGenericType property.<P>

[<I>Note</I>: See the <A HREF="MethodInfo.html" TARGET="contents">MethodInfo</A> type for an example of the use of this property.<P>

]<P>

[<I>Behaviors</I>: This property is read-only.<P>

]<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

<HR>

<A NAME="MethodInfo.ReturnType%20Property"><H3>MethodInfo.ReturnType Property</H3>

<BLOCKQUOTE>
<TABLE COLS="1" ROWS="1" WIDTH="100%">
<TR><TD BGCOLOR="#C0C0C0"><PRE>public abstract Type ReturnType { get; }</PRE></TD></TR>
</TABLE>
</BLOCKQUOTE>

<H4>Summary</H4>

<BLOCKQUOTE>
Gets the type of the return value of the method reflected by the current
      instance.<P>

</BLOCKQUOTE>

<H4>Property Value</H4>

<BLOCKQUOTE>
 The <A HREF="../../System/Type.html" TARGET="contents">Type</A> of the return
   value of the method reflected by the current instance. This property is equal to
   the <A HREF="../../System/Type.html" TARGET="contents">Type</A>
   object representing
<A HREF="../../System/Void.html" TARGET="contents">Void</A> if the 
   return value of the method is <CODE>void</CODE>

   .<P>

</BLOCKQUOTE>

<H4>Description</H4>

<BLOCKQUOTE>
[<I>Behaviors</I>: This property is
      read-only.]<P>

<P>

</BLOCKQUOTE>

<H4>See Also</H4>

<BLOCKQUOTE>
<A HREF="MethodInfo.html" TARGET="contents">System.Reflection.MethodInfo Class</A>, <A HREF="Reflection.html" TARGET="members">System.Reflection Namespace</A>
</BLOCKQUOTE>

</BODY>
</HTML>
