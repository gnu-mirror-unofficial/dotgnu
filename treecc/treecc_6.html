<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on January, 18 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>Tree Compiler-Compiler: 6. API's available in the generated output</title>

<meta name="description" content="Tree Compiler-Compiler: 6. API's available in the generated output">
<meta name="keywords" content="Tree Compiler-Compiler: 6. API's available in the generated output">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Output-APIs"></a>
<a name="SEC18"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC19" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 6. API's available in the generated output </h1>

<p>The source code that is generated by treecc exports a number of
application programmer interfaces (API's) to the programmer.  These
can be used elsewhere in the compiler implementation to manipulate
abstract syntax trees.  The following sections describe the API's
for each of the output languages.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC19">6.1 C Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC20">6.2 C++ Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC21">6.3 Java Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC22">6.4 C# Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC23">6.5 Ruby Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC24">6.6 Python Language APIs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>


<hr size="6">
<a name="C-Language"></a>
<a name="SEC19"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC18" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC20" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.1 C Language APIs </h2>

<p>In the C output language, each node type is converted into a &lsquo;<samp>typedef</samp>&rsquo;
that contains the node's fields, and the fields of its ancestor node
types.  The following example demonstrates how treecc node declarations
are converted into C source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression *expr1;
    expression *expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct expression__ expression;
typedef struct binary__ binary;
typedef struct plus__ plus;

struct expression__ {
    const struct expression_vtable__ *vtable__;
    int kind__;
    char *filename__;
    long linenum__;
    type_code type;
};
struct binary__ {
    const struct binary_vtable__ *vtable__;
    int kind__;
    char *filename__;
    long linenum__;
    type_code type;
    expression * expr1;
    expression * expr2;
};
struct plus__ {
    const struct plus_vtable__ *vtable__;
    int kind__;
    char *filename__;
    long linenum__;
    type_code type;
    expression * expr1;
    expression * expr2;
};
</pre></td></tr></table>

<p>Programmers should avoid using any identifiers that end in
&lsquo;<samp>__</samp>&rsquo;.  Such identifiers are reserved for internal use by treecc
and its support routines.
</p>
<p>For each non-abstract node type called &lsquo;<samp>NAME</samp>&rsquo;, treecc generates a
function called &lsquo;<samp>NAME_create</samp>&rsquo; that creates nodes of that type.
The general form of the function's prototype is as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">TYPE *NAME_create([YYNODESTATE *state,] PARAMS)
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>TYPE</samp>&rsquo;</dt>
<dd><p>The return node type, which is the nearest ancestor that has the
&lsquo;<samp>%typedef</samp>&rsquo; flag.
</p>
</dd>
<dt> &lsquo;<samp>NAME</samp>&rsquo;</dt>
<dd><p>The name of the node type that is being created.
</p>
</dd>
<dt> &lsquo;<samp>state</samp>&rsquo;</dt>
<dd><p>The system state, if reentrant code is being generated.
</p>
</dd>
<dt> &lsquo;<samp>PARAMS</samp>&rsquo;</dt>
<dd><p>The create parameters, consisting of every field that does not
have the &lsquo;<samp>%nocreate</samp>&rsquo; flag.  The parameters appear in the
same order as the fields in the node types, from the top-most
ancestor down to the node type itself.  For example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">expression *plus_create(expression * expr1, expression * expr2);
</pre></td></tr></table>
</dd>
</dl>

<p>Enumerated types are converted into a C &lsquo;<samp>typedef</samp>&rsquo; with the
same name and values:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef enum
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF

} JavaType;
</pre></td></tr></table>

<p>Virtual operations are converted into C macros that invoke the
correct vtable entry on a node type:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation %virtual void infer_type(expression *e)
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">#define infer_type(this__) \
    ((*(((struct expression_vtable__ *) \
        ((this__)-&gt;vtable__))-&gt;infer_type_v__)) \
            ((expression *)(this__)))
</pre></td></tr></table>

<p>Calls to &lsquo;<samp>infer_type</samp>&rsquo; can then be made with &lsquo;<samp>infer_type(node)</samp>&rsquo;.
</p>
<p>Non-virtual operations are converted into C functions:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation void infer_type(expression *e)
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">extern void infer_type(expression *e);
</pre></td></tr></table>

<p>Because virtual and non-virtual operations use a similar call syntax,
it is very easy to convert a virtual operation into a non-virtual
operation when the output language is C.  This isn't possible with
the other output languages.
</p>
<p>Other house-keeping tasks are performed by the following functions
and macros.  Some of these must be supplied by the programmer.
The &lsquo;<samp>state</samp>&rsquo; parameter is required only if a reentrant compiler is
being built.
</p>
<dl compact="compact">
<dt> <code>int yykind(ANY *node)</code></dt>
<dd><a name="IDX53"></a>
<p>Gets the numeric kind value associated with a particular node.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME_kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>const char *yykindname(ANY *node)</code></dt>
<dd><a name="IDX54"></a>
<p>Gets the name of the node kind associated with a particular node.
This may be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>int yyisa(ANY *node, type)</code></dt>
<dd><a name="IDX55"></a>
<p>Determines if &lsquo;<samp>node</samp>&rsquo; is an instance of the node type &lsquo;<samp>type</samp>&rsquo;.
</p>
</dd>
<dt> <code>char *yygetfilename(ANY *node)</code></dt>
<dd><a name="IDX56"></a>
<p>Gets the filename corresponding to where &lsquo;<samp>node</samp>&rsquo; was created
during parsing.  This macro is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>long yygetlinenum(ANY *node)</code></dt>
<dd><a name="IDX57"></a>
<p>Gets the line number corresponding to where &lsquo;<samp>node</samp>&rsquo; was created
during parsing.  This macro is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>void yysetfilename(ANY *node, char *value)</code></dt>
<dd><a name="IDX58"></a>
<p>Sets the filename associated with &lsquo;<samp>node</samp>&rsquo; to &lsquo;<samp>value</samp>&rsquo;.  The
string is not copied, so &lsquo;<samp>value</samp>&rsquo; must persist for the lifetime
of the node.  This macro will rarely be required, unless a node
corresponds to a different line than the current parse line.  This
macro is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>void yysetlinenum(ANY *node, long value)</code></dt>
<dd><a name="IDX59"></a>
<p>Sets the line number associated with &lsquo;<samp>node</samp>&rsquo; to &lsquo;<samp>value</samp>&rsquo;.
This macro will rarely be required, unless a node corresponds to a
different line than the current parse line.  This macro is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>char *yycurrfilename([YYNODESTATE *state])</code></dt>
<dd><a name="IDX60"></a>
<p>Get the name of the current input file from the parser.  The pointer
that is returned from this function is stored as-is: the string is
not copied.  Therefore, the value must persist for at least as long
as the node will persist.  This function must be supplied by the programmer
if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>long yycurrlinenum([YYNODESTATE *state])</code></dt>
<dd><a name="IDX61"></a>
<p>Get the number of the current input line from the parser.  This
function must be supplied by the programmer if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>void yynodeinit([YYNODESTATE *state])</code></dt>
<dd><a name="IDX62"></a>
<p>Initializes the node memory manager.  If the system is reentrant, then
the node memory manager is &lsquo;<samp>state</samp>&rsquo;.  Otherwise a global node
memory manager is used.
</p>
</dd>
<dt> <code>void *yynodealloc([YYNODESTATE *state,] unsigned int size)</code></dt>
<dd><a name="IDX63"></a>
<p>Allocates a block of memory of &lsquo;<samp>size</samp>&rsquo; bytes in size from the
node memory manager.  This function is called automatically from
the node-specific &lsquo;<samp>*_create</samp>&rsquo; functions.  The programmer will
not normally need to call this function.
</p>
<p>This function will return <code>NULL</code> if the system is out of
memory, or if &lsquo;<samp>size</samp>&rsquo; is too large to be allocated within
the node memory manager.  If the system is out of memory, then
&lsquo;<samp>yynodealloc</samp>&rsquo; will call &lsquo;<samp>yynodefailed</samp>&rsquo; prior to
returning <code>NULL</code>.
</p>
</dd>
<dt> <code>int yynodepush([YYNODESTATE *state])</code></dt>
<dd><a name="IDX64"></a>
<p>Pushes the current node memory manager position.  The next time
<code>yynodepop</code> is called, the node memory manager will reset to
the pushed position.  This function returns zero if the system
is out of memory.
</p>
</dd>
<dt> <code>void yynodepop([YYNODESTATE *state])</code></dt>
<dd><a name="IDX65"></a>
<p>Pops the current node memory manager position.  This function has
no effect if <code>yynodepush</code> was not called previously.
</p>
<p>The <code>yynodepush</code> and <code>yynodepop</code> functions can be used
to perform a simple kind of garbage collection on nodes.  When
the parser enters a scope, it pushes the node memory manager
position.  After all definitions in the scope have been dealt
with, the parser pops the node memory manager to reclaim all
of the memory used.
</p>
</dd>
<dt> <code>void yynodeclear([YYNODESTATE *state])</code></dt>
<dd><a name="IDX66"></a>
<p>Clears the entire node memory manager and returns it to the
state it had after calling <code>yynodeinit</code>.  This is typically
used upon program shutdown to free all remaining node memory.
</p>
</dd>
<dt> <code>void yynodefailed([YYNODESTATE *state])</code></dt>
<dd><a name="IDX67"></a>
<p>Called when <code>yynodealloc</code> or <code>yynodepush</code> detects that
the system is out of memory.  This function must be supplied by
the programmer.  The programmer may choose to exit to program
when the system is out of memory; in which case <code>yynodealloc</code>
will never return <code>NULL</code>.
</p></dd>
</dl>


<hr size="6">
<a name="C_002b_002b-Language"></a>
<a name="SEC20"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC19" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC21" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.2 C++ Language APIs </h2>

<p>In the C++ output language, each node type is converted into a &lsquo;<samp>class</samp>&rsquo;
that contains the node's fields, virtual operations, and other house-keeping
definitions.  The following example demonstrates how treecc node declarations
are converted into C++ source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression *expr1;
    expression *expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class expression
{
protected:

    int kind__;
    char *filename__;
    long linenum__;

public:

    int getKind() const { return kind__; }
    const char *getFilename() const { return filename__; }
    int getLinenum() const { return linenum__; }
    void setFilename(char *filename) { filename__ = filename; }
    void setLinenum(long linenum) { linenum__ = linenum; }

    void *operator new(size_t);
    void operator delete(void *, size_t);

protected:

    expression();

public:

    type_code type;

    virtual int isA(int kind) const;
    virtual const char *getKindName() const;

protected:

    virtual ~expression();

};

class binary : public expression
{
protected:

    binary(expression * expr1, expression * expr2);

public:

    expression * expr1;
    expression * expr2;

    virtual int isA(int kind) const;
    virtual const char *getKindName() const;

protected:

    virtual ~binary();

};

class plus : public binary
{
public:

    plus(expression * expr1, expression * expr2);

public:

    virtual int isA(int kind) const;
    virtual const char *getKindName() const;

protected:

    virtual ~plus();

};
</pre></td></tr></table>

<p>The following standard methods are available on every node type:
</p>
<dl compact="compact">
<dt> <code>int getKind()</code></dt>
<dd><a name="IDX68"></a>
<p>Gets the numeric kind value associated with a particular node.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME_kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>virtual const char *getKindName()</code></dt>
<dd><a name="IDX69"></a>
<p>Gets the name of the node kind associated with a particular node.
This may be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>virtual int isA(int kind)</code></dt>
<dd><a name="IDX70"></a>
<p>Determines if the node is a member of the node type that corresponds
to the numeric kind value &lsquo;<samp>kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>const char *getFilename()</code></dt>
<dd><a name="IDX71"></a>
<p>Gets the filename corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>long getLinenum()</code></dt>
<dd><a name="IDX72"></a>
<p>Gets the line number corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>void setFilename(char *value)</code></dt>
<dd><a name="IDX73"></a>
<p>Sets the filename associated with the node to &lsquo;<samp>value</samp>&rsquo;.  The
string is not copied, so &lsquo;<samp>value</samp>&rsquo; must persist for the lifetime
of the node.  This method will rarely be required, unless a node
corresponds to a different line than the current parse line.  This
method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>void setLinenum(long value)</code></dt>
<dd><a name="IDX74"></a>
<p>Sets the line number associated with the node to &lsquo;<samp>value</samp>&rsquo;.
This method will rarely be required, unless a node corresponds to a
different line than the current parse line.  This method is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>If the generated code is non-reentrant, then the constructor for the
class can be used to construct nodes of the specified node type.  The
constructor parameters are the same as the fields within the node type's
definition, except for &lsquo;<samp>%nocreate</samp>&rsquo; fields.
</p>
<p>If the generated code is reentrant, then nodes cannot be constructed
using the C++ &lsquo;<samp>new</samp>&rsquo; operator.  The &lsquo;<samp>*Create</samp>&rsquo; methods
on the &lsquo;<samp>YYNODESTATE</samp>&rsquo; factory class must be used instead.
</p>
<p>The &lsquo;<samp>YYNODESTATE</samp>&rsquo; class contains a number of house-keeping methods
that are used to manage nodes:
</p>
<dl compact="compact">
<dt> <code>static YYNODESTATE *getState()</code></dt>
<dd><a name="IDX75"></a>
<p>Gets the global &lsquo;<samp>YYNODESTATE</samp>&rsquo; instance that is being used by
non-reentrant code.  If an instance has not yet been created,
this method will create one.
</p>
<p>When using non-reentrant code, the programmer will normally subclass
&lsquo;<samp>YYNODESTATE</samp>&rsquo;, override some of the methods below, and then
construct an instance of the subclass.  This constructed instance
will then be returned by future calls to &lsquo;<samp>getState</samp>&rsquo;.
</p>
</dd>
<dt> <code>void *alloc(size_t size)</code></dt>
<dd><a name="IDX76"></a>
<p>Allocates a block of memory of &lsquo;<samp>size</samp>&rsquo; bytes in size from the
node memory manager.  This function is called automatically from
the node-specific constructors and &lsquo;<samp>*Create</samp>&rsquo; methods.  The programmer
will not normally need to call this function.
</p>
<p>This function will return <code>NULL</code> if the system is out of
memory, or if &lsquo;<samp>size</samp>&rsquo; is too large to be allocated within
the node memory manager.  If the system is out of memory, then
&lsquo;<samp>alloc</samp>&rsquo; will call &lsquo;<samp>failed</samp>&rsquo; prior to returning <code>NULL</code>.
</p>
</dd>
<dt> <code>int push()</code></dt>
<dd><a name="IDX77"></a>
<p>Pushes the current node memory manager position.  The next time
<code>pop</code> is called, the node memory manager will reset to
the pushed position.  This function returns zero if the system
is out of memory.
</p>
</dd>
<dt> <code>void pop()</code></dt>
<dd><a name="IDX78"></a>
<p>Pops the current node memory manager position.  This function has
no effect if <code>push</code> was not called previously.
</p>
<p>The <code>push</code> and <code>pop</code> methods can be used
to perform a simple kind of garbage collection on nodes.  When
the parser enters a scope, it pushes the node memory manager
position.  After all definitions in the scope have been dealt
with, the parser pops the node memory manager to reclaim all
of the memory used.
</p>
</dd>
<dt> <code>void clear()</code></dt>
<dd><a name="IDX79"></a>
<p>Clears the entire node memory manager and returns it to the
state it had after construction.
</p>
</dd>
<dt> <code>virtual void failed()</code></dt>
<dd><a name="IDX80"></a>
<p>Called when <code>alloc</code> or <code>push</code> detects that
the system is out of memory.  This method is typically
overridden by the programmer in subclasses.  The programmer may
choose to exit to program when the system is out of memory; in
which case <code>alloc</code> will never return <code>NULL</code>.
</p>
</dd>
<dt> <code>virtual char *currFilename()</code></dt>
<dd><a name="IDX81"></a>
<p>Get the name of the current input file from the parser.  The pointer
that is returned from this function is stored as-is: the string is
not copied.  Therefore, the value must persist for at least as long
as the node will persist.  This method is usually overrriden by
the programmer in subclasses if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>virtual long currLinenum()</code></dt>
<dd><a name="IDX82"></a>
<p>Get the number of the current input line from the parser.  This
method is usually overridden by the programmer in subclasses
if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>The programmer will typically subclass &lsquo;<samp>YYNODESTATE</samp>&rsquo; to provide
additional functionality, and then create an instance of this class
to act as the node memory manager and node creation factory.
</p>

<hr size="6">
<a name="Java-Language"></a>
<a name="SEC21"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC20" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC22" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.3 Java Language APIs </h2>

<p>In the Java output language, each node type is converted into a &lsquo;<samp>class</samp>&rsquo;
that contains the node's fields, virtual operations, and other house-keeping
definitions.  The following example demonstrates how treecc node declarations
are converted into Java source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression expr1;
    expression expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class expression
{
    protected int kind__;
    protected String filename__;
    protected long linenum__;

    public int getKind() { return kind__; }
    public String getFilename() { return filename__; }
    public long getLinenum() const { return linenum__; }
    public void setFilename(String filename) { filename__ = filename; }
    public void setLinenum(long linenum) { linenum__ = linenum; }

    public static final int KIND = 1;

    public type_code type;

    protected expression()
    {
        this.kind__ = KIND;
        this.filename__ = YYNODESTATE.getState().currFilename();
        this.linenum__ = YYNODESTATE.getState().currLinenum();
    }

    public int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return 0;
    }

    public String getKindName()
    {
        return &quot;expression&quot;;
    }
}

public class binary extends expression
{
    public static final int KIND = 2;

    public expression expr1;
    public expression expr2;

    protected binary(expression expr1, expression expr2)
    {
        super();
        this.kind__ = KIND;
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    public int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return super.isA(kind);
    }

    public String getKindName()
    {
        return &quot;binary&quot;;
    }
}

public class plus extends binary
{
    public static final int KIND = 3;

    public plus(expression expr1, expression expr2)
    {
        super(expr1, expr2);
        this.kind__ = KIND;
    }

    public int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return super.isA(kind);
    }

    public String getKindName()
    {
        return &quot;plus&quot;;
    }
}
</pre></td></tr></table>

<p>The following standard members are available on every node type:
</p>
<dl compact="compact">
<dt> <code>int KIND</code></dt>
<dd><a name="IDX83"></a>
<p>The kind value for the node type corresponding to this class.
</p>
</dd>
<dt> <code>int getKind()</code></dt>
<dd><a name="IDX84"></a>
<p>Gets the numeric kind value associated with a particular node.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME.KIND</samp>&rsquo;.
</p>
</dd>
<dt> <code>String getKindName()</code></dt>
<dd><a name="IDX85"></a>
<p>Gets the name of the node kind associated with a particular node.
This may be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>int isA(int kind)</code></dt>
<dd><a name="IDX86"></a>
<p>Determines if the node is a member of the node type that corresponds
to the numeric kind value &lsquo;<samp>kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>String getFilename()</code></dt>
<dd><a name="IDX87"></a>
<p>Gets the filename corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>long getLinenum()</code></dt>
<dd><a name="IDX88"></a>
<p>Gets the line number corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>void setFilename(String value)</code></dt>
<dd><a name="IDX89"></a>
<p>Sets the filename associated with the node to &lsquo;<samp>value</samp>&rsquo;.
This method will rarely be required, unless a node corresponds to
a different line than the current parse line.  This method is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>void setLinenum(long value)</code></dt>
<dd><a name="IDX90"></a>
<p>Sets the line number associated with the node to &lsquo;<samp>value</samp>&rsquo;.
This method will rarely be required, unless a node corresponds to a
different line than the current parse line.  This method is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>If the generated code is non-reentrant, then the constructor for the
class can be used to construct nodes of the specified node type.  The
constructor parameters are the same as the fields within the node type's
definition, except for &lsquo;<samp>%nocreate</samp>&rsquo; fields.
</p>
<p>If the generated code is reentrant, then nodes cannot be constructed
using the Java &lsquo;<samp>new</samp>&rsquo; operator.  The &lsquo;<samp>*Create</samp>&rsquo; methods
on the &lsquo;<samp>YYNODESTATE</samp>&rsquo; factory class must be used instead.
</p>
<p>Enumerated types are converted into a Java &lsquo;<samp>class</samp>&rsquo;:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class JavaType
{
    public static final int JT_BYTE = 0;
    public static final int JT_SHORT = 1;
    public static final int JT_CHAR = 2;
    public static final int JT_INT = 3;
    public static final int JT_LONG = 4;
    public static final int JT_FLOAT = 5;
    public static final int JT_DOUBLE = 6;
    public static final int JT_OBJECT_REF = 7;
}
</pre></td></tr></table>

<p>References to enumerated types in fields and operation parameters
are replaced with the type &lsquo;<samp>int</samp>&rsquo;.
</p>
<p>Virtual operations are converted into public methods on the Java
node classes.
</p>
<p>Non-virtual operations are converted into a static method within
a class named for the operation.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation void InferType::infer_type(expression e)
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class InferType
{
    public static void infer_type(expression e)
    {
        ...
    }
}
</pre></td></tr></table>

<p>If the class name (&lsquo;<samp>InferType</samp>&rsquo; in the above example) is omitted,
then the name of the operation is used as both the class name and the
the method name.
</p>
<p>The &lsquo;<samp>YYNODESTATE</samp>&rsquo; class contains a number of house-keeping methods
that are used to manage nodes:
</p>
<dl compact="compact">
<dt> <code>static YYNODESTATE getState()</code></dt>
<dd><a name="IDX91"></a>
<p>Gets the global &lsquo;<samp>YYNODESTATE</samp>&rsquo; instance that is being used by
non-reentrant code.  If an instance has not yet been created,
this method will create one.
</p>
<p>When using non-reentrant code, the programmer will normally subclass
&lsquo;<samp>YYNODESTATE</samp>&rsquo;, override some of the methods below, and then
construct an instance of the subclass.  This constructed instance
will then be returned by future calls to &lsquo;<samp>getState</samp>&rsquo;.
</p>
<p>This method will not be present if a reentrant system is being
generated.
</p>
</dd>
<dt> <code>String currFilename()</code></dt>
<dd><a name="IDX92"></a>
<p>Get the name of the current input file from the parser.  This method
is usually overrriden by the programmer in subclasses if
&lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>long currLinenum()</code></dt>
<dd><a name="IDX93"></a>
<p>Get the number of the current input line from the parser.  This
method is usually overridden by the programmer in subclasses
if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>The programmer will typically subclass &lsquo;<samp>YYNODESTATE</samp>&rsquo; to provide
additional functionality, and then create an instance of this class
to act as the global state and node creation factory.
</p>

<hr size="6">
<a name="C_0023-Language"></a>
<a name="SEC22"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC21" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC23" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.4 C# Language APIs </h2>

<p>In the C# output language, each node type is converted into a &lsquo;<samp>class</samp>&rsquo;
that contains the node's fields, virtual operations, and other house-keeping
definitions.  The following example demonstrates how treecc node declarations
are converted into C# source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression expr1;
    expression expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class expression
{
    protected int kind__;
    protected String filename__;
    protected long linenum__;

    public int getKind() { return kind__; }
    public String getFilename() { return filename__; }
    public long getLinenum() const { return linenum__; }
    public void setFilename(String filename) { filename__ = filename; }
    public void setLinenum(long linenum) { linenum__ = linenum; }

    public const int KIND = 1;

    public type_code type;

    protected expression()
    {
        this.kind__ = KIND;
        this.filename__ = YYNODESTATE.getState().currFilename();
        this.linenum__ = YYNODESTATE.getState().currLinenum();
    }

    public virtual int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return 0;
    }

    public virtual String getKindName()
    {
        return &quot;expression&quot;;
    }
}

public class binary : expression
{
    public const int KIND = 2;

    public expression expr1;
    public expression expr2;

    protected binary(expression expr1, expression expr2)
        : expression()
    {
        this.kind__ = KIND;
        this.expr1 = expr1;
        this.expr2 = expr2;
    }

    public override int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return base.isA(kind);
    }

    public override String getKindName()
    {
        return &quot;binary&quot;;
    }
}

public class plus : binary
{
    public const int KIND = 5;

    public plus(expression expr1, expression expr2)
        : binary(expr1, expr2)
    {
        this.kind__ = KIND;
    }

    public override int isA(int kind)
    {
        if(kind == KIND)
            return 1;
        else
            return base.isA(kind);
    }

    public override String getKindName()
    {
        return &quot;plus&quot;;
    }
}
</pre></td></tr></table>

<p>The following standard members are available on every node type:
</p>
<dl compact="compact">
<dt> <code>const int KIND</code></dt>
<dd><a name="IDX94"></a>
<p>The kind value for the node type corresponding to this class.
</p>
</dd>
<dt> <code>int getKind()</code></dt>
<dd><a name="IDX95"></a>
<p>Gets the numeric kind value associated with a particular node.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME.KIND</samp>&rsquo;.
</p>
</dd>
<dt> <code>virtual String getKindName()</code></dt>
<dd><a name="IDX96"></a>
<p>Gets the name of the node kind associated with a particular node.
This may be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>virtual int isA(int kind)</code></dt>
<dd><a name="IDX97"></a>
<p>Determines if the node is a member of the node type that corresponds
to the numeric kind value &lsquo;<samp>kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>String getFilename()</code></dt>
<dd><a name="IDX98"></a>
<p>Gets the filename corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>long getLinenum()</code></dt>
<dd><a name="IDX99"></a>
<p>Gets the line number corresponding to where the node was created
during parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
<dt> <code>void setFilename(String value)</code></dt>
<dd><a name="IDX100"></a>
<p>Sets the filename associated with the node to &lsquo;<samp>value</samp>&rsquo;.
This method will rarely be required, unless a node corresponds to
a different line than the current parse line.  This method is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>void setLinenum(long value)</code></dt>
<dd><a name="IDX101"></a>
<p>Sets the line number associated with the node to &lsquo;<samp>value</samp>&rsquo;.
This method will rarely be required, unless a node corresponds to a
different line than the current parse line.  This method is only
generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>If the generated code is non-reentrant, then the constructor for the
class can be used to construct nodes of the specified node type.  The
constructor parameters are the same as the fields within the node type's
definition, except for &lsquo;<samp>%nocreate</samp>&rsquo; fields.
</p>
<p>If the generated code is reentrant, then nodes cannot be constructed
using the C# &lsquo;<samp>new</samp>&rsquo; operator.  The &lsquo;<samp>*Create</samp>&rsquo; methods
on the &lsquo;<samp>YYNODESTATE</samp>&rsquo; factory class must be used instead.
</p>
<p>Enumerated types are converted into a C# &lsquo;<samp>enum</samp>&rsquo; definition:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public enum JavaType
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF,
}
</pre></td></tr></table>

<p>Virtual operations are converted into public virtual methods on the C#
node classes.
</p>
<p>Non-virtual operations are converted into a static method within
a class named for the operation.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation void InferType::infer_type(expression e)
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">public class InferType
{
    public static void infer_type(expression e)
    {
        ...
    }
}
</pre></td></tr></table>

<p>If the class name (&lsquo;<samp>InferType</samp>&rsquo; in the above example) is omitted,
then the name of the operation is used as both the class name and the
the method name.
</p>
<p>The &lsquo;<samp>YYNODESTATE</samp>&rsquo; class contains a number of house-keeping methods
that are used to manage nodes:
</p>
<dl compact="compact">
<dt> <code>static YYNODESTATE getState()</code></dt>
<dd><a name="IDX102"></a>
<p>Gets the global &lsquo;<samp>YYNODESTATE</samp>&rsquo; instance that is being used by
non-reentrant code.  If an instance has not yet been created,
this method will create one.
</p>
<p>When using non-reentrant code, the programmer will normally subclass
&lsquo;<samp>YYNODESTATE</samp>&rsquo;, override some of the methods below, and then
construct an instance of the subclass.  This constructed instance
will then be returned by future calls to &lsquo;<samp>getState</samp>&rsquo;.
</p>
<p>This method will not be present if a reentrant system is being
generated.
</p>
</dd>
<dt> <code>virtual String currFilename()</code></dt>
<dd><a name="IDX103"></a>
<p>Get the name of the current input file from the parser.  This method
is usually overrriden by the programmer in subclasses if
&lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>virtual long currLinenum()</code></dt>
<dd><a name="IDX104"></a>
<p>Get the number of the current input line from the parser.  This
method is usually overridden by the programmer in subclasses
if &lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>The programmer will typically subclass &lsquo;<samp>YYNODESTATE</samp>&rsquo; to provide
additional functionality, and then create an instance of this class
to act as the global state and node creation factory.
</p>

<hr size="6">
<a name="Ruby-Language"></a>
<a name="SEC23"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC22" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC24" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.5 Ruby Language APIs </h2>

<p>In the Ruby output language, each node type is converted into a
&lsquo;<samp>class</samp>&rsquo; that contains the node's fields, operations, and other
house-keeping definitions.  The following example demonstrates how
treecc node declarations are converted into Ruby source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression expr1;
    expression expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class YYNODESTATE

  @@state = nil

  def YYNODESTATE.state
    return @@state unless @@state.nil?
    @@state = YYNODESTATE.new()
    return @@state
  end

  def intialize 
     @@state = self 
   end

  def currFilename 
     return nil
  end

  def currLinenum 
     return 0 
  end
end

class Expression
  protected
  attr_reader :kind
  public 

  attr_accessor :Linenum, :Filename

  attr_accessor :type

  KIND = 1

  def initialize()
    @kind = KIND
    @Filename = YYNODESTATE.state.currFilename()
    @Linenum = YYNODESTATE.state.currLinenum()
  end

  def isA(kind)
    if(@kind == KIND) then
      return true
    else
      return 0
    end
  end

  def KindName
    return &quot;Expression&quot;
  end

end

class Binary &lt; Expression

  attr_accessor :expr1
  attr_accessor :expr2

  KIND = 2

  def initialize(expr1, expr2)
  super(expr1, expr2)
    @kind = KIND
    self.expr1 = expr1
    self.expr2 = expr2
  end

  def isA(kind)
    if(@kind == Kind) then
      return true
    else
      return super(kind)
    end
  end

  def KindName
    return &quot;Binary&quot;
  end

end

class Plus &lt; Binary

  KIND = 3

  def initialize(expr1, expr2)
  super(expr1, expr2expr1, expr2)
    @kind = KIND
  end

  def isA(kind)
    if(@kind == KIND) then
      return true
    else
      return super(kind)
    end
  end

  def KindName
    return &quot;Plus&quot;
  end

end
</pre></td></tr></table>

<p>The following standard members are available on every node type:
</p>
<dl compact="compact">
<dt> <code>KIND</code></dt>
<dd><a name="IDX105"></a>
<p>The kind value for the node type corresponding to this class.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME::KIND</samp>&rsquo;.
</p>
</dd>
<dt> <code>KindName</code></dt>
<dd><a name="IDX106"></a>
<p>The name of the node kind associated with a particular node.  This may
be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>isA(int kind)</code></dt>
<dd><a name="IDX107"></a>
<p>Determines if the node is a member of the node type that corresponds
to the numeric kind value &lsquo;<samp>kind</samp>&rsquo;.
</p>
</dd>
<dt> <code>Filename</code></dt>
<dd><a name="IDX108"></a>
<p>The filename corresponding to where the node was created during parsing.
This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo; was
specified.
</p>
</dd>
<dt> <code>Linenum()</code></dt>
<dd><a name="IDX109"></a>
<p>The line number corresponding to where the node was created during
parsing.  This method is only generated if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p>
</dd>
</dl>


<p>Enumerated types are converted into a Ruby &lsquo;<samp>class</samp>&rsquo; definition:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">
class JavaType 
  JT_BYTE = 0
  JT_SHORT = 1
  JT_CHAR = 2
  JT_INT = 3
  JT_LONG = 4
  JT_FLOAT = 5
  JT_DOUBLE = 6
  JT_OBJECT_REF = 7
end

</pre></td></tr></table>

<p>Virtual operations are converted into public methods on the Ruby
node classes.
</p>
<p>Non-virtual operations are converted into a class method within
a class named for the operation.  For example,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation void InferType::infer_type(expression e)
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class InferType
    def InferType.infer_type(expression e)   
        ...
    end
end
</pre></td></tr></table>

<p>If the class name (&lsquo;<samp>InferType</samp>&rsquo; in the above example) is omitted,
then the name of the operation is used as both the class name and the
the method name. You then get a method with a name starting with an
uppercase letter. However, Ruby methods start with lowercase methods.
So never forget the class name.
</p>
<p>The &lsquo;<samp>YYNODESTATE</samp>&rsquo; class contains a number of house-keeping methods
that are used to manage nodes:
</p>
<dl compact="compact">
<dt> <code>YYNODESTATE::state()</code></dt>
<dd><a name="IDX110"></a>
<p>Gets the global &lsquo;<samp>YYNODESTATE</samp>&rsquo; instance that is being used by
non-reentrant code.  If an instance has not yet been created,
this method will create one.
</p>

</dd>
<dt> <code>currFilename</code></dt>
<dd><a name="IDX111"></a>
<p>The name of the current input file from the parser.  This fields
accessor method is usually overrriden by the programmer in subclasses if
&lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p>
</dd>
<dt> <code>currLinenum</code></dt>
<dd><a name="IDX112"></a>
<p>The number of the current input line from the parser.  This fields
accessor method is usually overridden by the programmer in subclasses if
&lsquo;<samp>%option track_lines</samp>&rsquo; was specified.
</p></dd>
</dl>

<p>The programmer will typically subclass &lsquo;<samp>YYNODESTATE</samp>&rsquo; to provide
additional functionality, and then create an instance of this class
to act as the global state and node creation factory.
</p>

<hr size="6">
<a name="Python-Language"></a>
<a name="SEC24"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC23" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC18" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 6.6 Python Language APIs </h2>

<p>In the Python output language, each node type is converted into a
&lsquo;<samp>class</samp>&rsquo; that contains the node's fields, operations, and other
house-keeping definitions.  The following example demonstrates how
treecc node declarations are converted into Python source code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node expression %abstract %typedef =
{
    %nocreate type_code type;
}
%node binary expression %abstract =
{
    expression expr1;
    expression expr2;
}
%node plus binary
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class expression:
    KIND = 1
    def __init__(self):
        self.kind = 1
        self.filename = yycurrfilename()
        self.linenum = yycurrlinenum()

    def getKindName(self):
        return self.__class__.__name__

class binary (expression):
    KIND = 2
    def __init__(self, expr1, expr2):
        expression.__init__(self)
        self.kind = 2
        self.expr1 = expr1
        self.expr2 = expr2

class plus (binary):
    KIND = 3
    def __init__(self, expr1, expr2):
        binary.__init__(self, expr1, expr2)
        self.kind = 3
</pre></td></tr></table>

<p>The following standard members are available on every node type:
</p>
<dl compact="compact">
<dt> <code>KIND</code></dt>
<dd><a name="IDX113"></a>
<p>The kind value for the node type corresponding to this class.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME.KIND</samp>&rsquo;.
</p>
</dd>
<dt> <code>kind</code></dt>
<dd><a name="IDX114"></a>
<p>Gets the numeric kind value associated with a particular node.
The kind value for node type &lsquo;<samp>NAME</samp>&rsquo; is called &lsquo;<samp>NAME.KIND</samp>&rsquo;.
</p>
</dd>
<dt> <code>getKindName()</code></dt>
<dd><a name="IDX115"></a>
<p>The name of the node kind associated with a particular node.  This may
be helpful for debugging and logging code.
</p>
</dd>
<dt> <code>filename</code></dt>
<dd><a name="IDX116"></a>
<p>The filename corresponding to where the node was created during parsing.
This field is only initialized if &lsquo;<samp>%option track_lines</samp>&rsquo; was
specified.
</p>
</dd>
<dt> <code>linenum</code></dt>
<dd><a name="IDX117"></a>
<p>The line number corresponding to where the node was created during
parsing.  This field is only initialized if &lsquo;<samp>%option track_lines</samp>&rsquo;
was specified.
</p></dd>
</dl>

<p>The <code>isA()</code> method from the other output languages is not present
in the Python binding.  Use the standard Python <code>isinstance</code>
function instead.
</p>
<p>Enumerated types are converted into a Python &lsquo;<samp>class</samp>&rsquo; definition:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>becomes:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">class JavaType:
    JT_BYTE = 0
    JT_SHORT = 1
    JT_CHAR = 2
    JT_INT = 3
    JT_LONG = 4
    JT_FLOAT = 5
    JT_DOUBLE = 6
    JT_OBJECT_REF = 7
</pre></td></tr></table>

<p>Virtual operations are converted into public methods on the Python
node classes.  Non-virtual operations are converted into a global
method within the generated Python module.
</p>
<p>If &lsquo;<samp>%option track_lines</samp>&rsquo; is specified, then the generated Python
module is assumed to contain the following global methods to provide line
tracking information:
</p>
<dl compact="compact">
<dt> <code>yycurrfilename()</code></dt>
<dd><a name="IDX118"></a>
<p>The name of the current input file from the parser.
</p>
</dd>
<dt> <code>yycurrlinenum()</code></dt>
<dd><a name="IDX119"></a>
<p>The number of the current input line from the parser.
</p></dd>
</dl>

<p>The programmer will typically provide a literal <code>%end</code> block to
define these methods.
</p>

<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC18" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc_7.html#SEC25" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Klaus Treichel</em> on <em>January, 18 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
