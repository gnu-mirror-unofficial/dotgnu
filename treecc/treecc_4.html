<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on January, 18 2009 by texi2html 1.78 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people.
Send bugs and suggestions to <texi2html-bug@nongnu.org>

-->
<head>
<title>Tree Compiler-Compiler: 4. Syntax of input files</title>

<meta name="description" content="Tree Compiler-Compiler: 4. Syntax of input files">
<meta name="keywords" content="Tree Compiler-Compiler: 4. Syntax of input files">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.78">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.roman {font-family:serif; font-weight:normal;}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Syntax"></a>
<a name="SEC9"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="treecc_3.html#SEC8" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC10" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc_3.html#SEC8" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 4. Syntax of input files </h1>

<p>Treecc input files consist of zero or more declarations that define
nodes, operations, options, etc.  The following sections describe each
of these elements.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC10">4.1 Node declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC11">4.2 Types used in fields and parameters</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC12">4.3 Enumerated type declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC13">4.4 Operation declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC14">4.5 Options that modify treecc's behaviour</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC15">4.6 Literal code declarations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top"><a href="#SEC16">4.7 Changing input and output files</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>


<hr size="6">
<a name="Nodes"></a>
<a name="SEC10"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC9" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC11" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.1 Node declarations </h2>

<p>Node types are defined using the &lsquo;<samp>node</samp>&rsquo; keyword in input files.
The general form of the declaration is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%node NAME [ PNAME ] [ FLAGS ] [ = FIELDS ]
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>NAME</samp>&rsquo;</dt>
<dd><p>An identifier that is used to refer to the node type elsewhere
in the treecc definition.  It is also the name of the type that will be
visible to the programmer in literal code blocks.
</p>
</dd>
<dt> &lsquo;<samp>PNAME</samp>&rsquo;</dt>
<dd><p>An identifier that refers to the parent node type that &lsquo;<samp>NAME</samp>&rsquo; inherits
from.  If &lsquo;<samp>PNAME</samp>&rsquo; is not supplied, then &lsquo;<samp>NAME</samp>&rsquo; is a top-level
declaration.  It is legal to supply a &lsquo;<samp>PNAME</samp>&rsquo; that has not yet
been defined in the input.
</p>
</dd>
<dt> &lsquo;<samp>FLAGS</samp>&rsquo;</dt>
<dd><p>Any combination of &lsquo;<samp>%abstract</samp>&rsquo; and &lsquo;<samp>%typedef</samp>&rsquo;:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%abstract</samp>&rsquo;</dt>
<dd><a name="IDX1"></a>
<p>The node type cannot be constructed by the programmer.  In addition,
the programmer does not need to define operation cases for this node
type if all subtypes have cases associated with them.
</p>
</dd>
<dt> &lsquo;<samp>%typedef</samp>&rsquo;</dt>
<dd><a name="IDX2"></a>
<p>The node type is used as the common return type for node creation
functions.  Top-level declarations must have a &lsquo;<samp>%typedef</samp>&rsquo; keyword.
</p></dd>
</dl>
</dd>
</dl>

<p>The &lsquo;<samp>FIELDS</samp>&rsquo; part of a node declaration defines the fields that
make up the node type.  Each field has the following general form:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">[ %nocreate ] TYPE FNAME [ = VALUE ] ';'
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>%nocreate</samp>&rsquo;</dt>
<dd><a name="IDX3"></a>
<p>The field is not used in the node's constructor.  When the node is
constructed, the value of this field will be undefined unless
&lsquo;<samp>VALUE</samp>&rsquo; is specified.
</p>
</dd>
<dt> &lsquo;<samp>TYPE</samp>&rsquo;</dt>
<dd><p>The type that is associated with the field.  Types can be declared
using a subset of the C declaration syntax, augmented with some C++
and Java features.  See section <a href="#SEC11">Types used in fields and parameters</a>, for more information.
</p>
</dd>
<dt> &lsquo;<samp>FNAME</samp>&rsquo;</dt>
<dd><p>The name to associate with the field.  Treecc verifies that the field
does not currently exist in this node type, or in any of its ancestor
node types.
</p>
</dd>
<dt> &lsquo;<samp>VALUE</samp>&rsquo;</dt>
<dd><p>The default value to assign to the field in the node's constructor.
This can only be used on fields that are declared with &lsquo;<samp>%nocreate</samp>&rsquo;.
The value must be enclosed in braces.  For example &lsquo;<samp>{NULL}</samp>&rsquo; would
be used to initialize a field with &lsquo;<samp>NULL</samp>&rsquo;.
</p>
<p>The braces are required because the default value is expressed in
the underlying source language, and can use any of the usual constant
declaration features present in that language.
</p></dd>
</dl>

<p>When the output language is C, treecc creates a struct-based type
called &lsquo;<samp>NAME</samp>&rsquo; that contains the fields for &lsquo;<samp>NAME</samp>&rsquo; and 
all of its ancestor classes.  The type also contains some house-keeping
fields that are used internally by the generated code.  The following
is an example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">typedef struct binary__ binary;
struct binary__ {
    const struct binary_vtable__ *vtable__;
    int kind__;
    char *filename__;
    long linenum__;
    type_code type;
    expression * expr1;
    expression * expr2;
};
</pre></td></tr></table>

<p>The programmer should avoid using any identifier that
ends with &lsquo;<samp>__</samp>&rsquo;, because it may clash with house-keeping
identifiers that are generated by treecc.
</p>
<p>When the output language is C++, Java, or C#, treecc creates a class
called &lsquo;<samp>NAME</samp>&rsquo;, that inherits from the class &lsquo;<samp>PNAME</samp>&rsquo;.
The field definitions for &lsquo;<samp>NAME</samp>&rsquo; are converted into public members
in the output.
</p>

<hr size="6">
<a name="Types"></a>
<a name="SEC11"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC10" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC12" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.2 Types used in fields and parameters </h2>

<p>Types that are used in field and parameter declarations have a
syntax which is subset of features found in C, C++, and Java:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">TypeAndName ::= Type [ IDENTIFIER ]

Type ::= TypeName
       | Type '*'
       | Type '&amp;'
       | Type '[' ']'

TypeName ::= IDENTIFIER { IDENTIFIER }
</pre></td></tr></table>

<p>Types are usually followed by an identifier that names the field or
parameter.  The name is required for fields and is optional for parameters.
For example &lsquo;<samp>int</samp>&rsquo; is usually equivalent to &lsquo;<samp>int x</samp>&rsquo; in parameter
declarations.
</p>
<p>The following are some examples of using types:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">int
int x
const char *str
expression *expr
Element[][] array
Item&amp;
unsigned int y
const Element
</pre></td></tr></table>

<p>The grammar used by treecc is slightly ambiguous.  The last example above
declares a parameter called &lsquo;<samp>Element</samp>&rsquo;, that has type &lsquo;<samp>const</samp>&rsquo;.
The programmer probably intended to declare an anonymous parameter with type 
&lsquo;<samp>const Element</samp>&rsquo; instead.
</p>
<p>This ambiguity is unavoidable given that treecc is not fully
aware of the underlying language's type system.  When treecc
sees a type that ends in a sequence of identifiers, it will
always interpret the last identifier as the field or parameter
name.  Thus, the programmer must write the following instead:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">const Element e
</pre></td></tr></table>

<p>Treecc cannot declare types using the full power of C's type system.
The most common forms of declarations are supported, and the rest
can usually be obtained by defining a &lsquo;<samp>typedef</samp>&rsquo; within a
literal code block.  See section <a href="#SEC15">Literal code declarations</a>, for more information
on literal code blocks.
</p>
<p>It is the responsibility of the programmer to use type constructs
that are supported by the underlying programming language.  Types such
as &lsquo;<samp>const char *</samp>&rsquo; will give an error when the output is compiled
with a Java compiler, for example.
</p>

<hr size="6">
<a name="Enumerations"></a>
<a name="SEC12"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC11" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC13" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.3 Enumerated type declarations </h2>

<p>Enumerated types are a special kind of node type that can be used
by the programmer for simple values that don't require a full abstract
syntax tree node.  The following is an example of defining a list
of the primitive machine types used in a Java virtual machine:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum JavaType =
{
    JT_BYTE,
    JT_SHORT,
    JT_CHAR,
    JT_INT,
    JT_LONG,
    JT_FLOAT,
    JT_DOUBLE,
    JT_OBJECT_REF
}
</pre></td></tr></table>

<p>Enumerations are useful when writing code generators and type
inferencing routines.  The general form is:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%enum NAME = { VALUES }
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>NAME</samp>&rsquo;</dt>
<dd><p>An identifier to be used to name the enumerated type.  The name must
not have been previously used as a node type, an enumerated type, or
an enumerated value.
</p>
</dd>
<dt> &lsquo;<samp>VALUES</samp>&rsquo;</dt>
<dd><p>A comma-separated list of identifiers that name the values within
the enumeration.  Each of the names must be unique, and must not have
been used previously as a node type, an enumerated type, or an
enumerated value.
</p></dd>
</dl>

<p>Logically, each enumerated value is a special node type that inherits from
a parent node type corresponding to the enumerated type &lsquo;<samp>NAME</samp>&rsquo;.
</p>
<p>When the output language is C or C++, treecc generates an enumerated
typedef for &lsquo;<samp>NAME</samp>&rsquo; that contains the enumerated values in the
same order as was used in the input file.  The typedef name can be
used elsewhere in the code as the type of the enumeration.
</p>
<p>When the output language is Java, treecc generates a class called
&lsquo;<samp>NAME</samp>&rsquo; that contains the enumerated values as integer constants.
Elsewhere in the code, the type &lsquo;<samp>int</samp>&rsquo; must be used to declare
variables of the enumerated type.  Enumerated values are referred
to as &lsquo;<samp>NAME.VALUE</samp>&rsquo;.  If the enumerated type is used as a trigger
parameter, then &lsquo;<samp>NAME</samp>&rsquo; must be used instead of &lsquo;<samp>int</samp>&rsquo;:
treecc will convert the type when the Java code is output.
</p>
<p>When the output language is C#, treecc generates an enumerated value
type called &lsquo;<samp>NAME</samp>&rsquo; that contains the enumerated values as
members.  The C# type &lsquo;<samp>NAME</samp>&rsquo; can be used elsewhere in the code
as the type of the enumeration.  Enumerated values are referred to
as &lsquo;<samp>NAME.VALUE</samp>&rsquo;.
</p>

<hr size="6">
<a name="Operations"></a>
<a name="SEC13"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC12" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC14" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.4 Operation declarations </h2>

<p>Operations are declared in two parts: the declaration, and the
cases.  The declaration part defines the prototype for the
operation and the cases define how to handle specific kinds of
nodes for the operation.
</p>
<p>Operations are defined over one or more trigger parameters.  Each
trigger parameter specifies a node type or an enumerated type that
is selected upon to determine what course of action to take.  The
following are some examples of operation declarations:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation void infer_type(expression *e)
%operation type_code common_type([type_code t1], [type_code t2])
</pre></td></tr></table>

<p>Trigger parameters are specified by enclosing them in square
brackets.  If none of the parameters are enclosed in square
brackets, then treecc assumes that the first parameter is the
trigger.
</p>
<p>The general form of an operation declaration is as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%operation { %virtual | %inline | %split } RTYPE [CLASS::]NAME(PARAMS)
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>%virtual</samp>&rsquo;</dt>
<dd><a name="IDX4"></a>
<p>Specifies that the operation is associated with a node type as
a virtual method.  There must be only one trigger parameter,
and it must be the first parameter.
</p>
<p>Non-virtual operations are written to the output source files
as global functions.
</p>
</dd>
<dt> &lsquo;<samp>%inline</samp>&rsquo;</dt>
<dd><a name="IDX5"></a>
<p>Optimise the generation of the operation code so that all cases
are inline within the code for the function itself.  This can
only be used with non-virtual operations, and may improve
code efficiency if there are lots of operation cases with a
small amount of code in each.
</p>
</dd>
<dt> &lsquo;<samp>%split</samp>&rsquo;</dt>
<dd><a name="IDX6"></a>
<p>Split the generation of the multi-trigger operation code across
multiple functions, to reduce the size of each individual function.
It is sometimes necessary to split large <code>%inline</code> operations
to avoid compiler limits on function size.
</p>
</dd>
<dt> &lsquo;<samp>RTYPE</samp>&rsquo;</dt>
<dd><p>The type of the return value for the operation.  This should be
&lsquo;<samp>void</samp>&rsquo; if the operation does not have a return value.
</p>
</dd>
<dt> &lsquo;<samp>CLASS</samp>&rsquo;</dt>
<dd><p>The name of the class to place the operation's definition within.
This can only be used with non-virtual operations, and is
intended for languages such as Java and C# that cannot declare
methods outside of classes.  The class name will be ignored if
the output language is C.
</p>
<p>If a class name is required, but the programmer did not supply it,
then &lsquo;<samp>NAME</samp>&rsquo; will be used as the default.  The exception to
this is the C# language: &lsquo;<samp>CLASS</samp>&rsquo; must always be supplied and
it must be different from &lsquo;<samp>NAME</samp>&rsquo;.  This is due to a &quot;feature&quot;
in some C# compilers that forbid a method with the same name as
its enclosing class.
</p>
</dd>
<dt> &lsquo;<samp>NAME</samp>&rsquo;</dt>
<dd><p>The name of the operation.
</p>
</dd>
<dt> &lsquo;<samp>PARAMS</samp>&rsquo;</dt>
<dd><p>The parameters to the operation.  Trigger parameters may be
enclosed in square brackets.  Trigger parameters must be
either node types or enumerated types.
</p></dd>
</dl>

<p>Once an operation has been declared, the programmer can specify
its cases anywhere in the input files.  It is not necessary that
the cases appear after the operation, or that they be contiguous
within the input files.  This permits the programmer to place
operation cases where they are logically required for maintainence
reasons.
</p>
<p>There must be sufficient operation cases defined to cover every
possible combination of node types and enumerated values that
inherit from the specified trigger types.  An operation case
has the following general form:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">NAME(TRIGGERS) [, NAME(TRIGGERS2) ...]
{
    CODE
}
</pre></td></tr></table>

<dl compact="compact">
<dt> &lsquo;<samp>NAME</samp>&rsquo;</dt>
<dd><p>The name of the operation for which this case applies.
</p>
</dd>
<dt> &lsquo;<samp>TRIGGERS</samp>&rsquo;</dt>
<dd><p>A comma-separated list of node types or enumerated values that
define the specific case that is handled by the following code.
</p>
</dd>
<dt> &lsquo;<samp>CODE</samp>&rsquo;</dt>
<dd><p>Source code in the output source language that implements the
operation case.
</p></dd>
</dl>

<p>Multiple trigger combinations can be associated with a single
block of code, by listing them all, separated by commas.  For
example:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">common_type(int_type, int_type)
{
    return int_type;
}

common_type(int_type, float_type),
common_type(float_type, int_type),
common_type(float_type, float_type)
{
    return float_type;
}
</pre></td></tr></table>


<hr size="6">
<a name="Options"></a>
<a name="SEC14"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC13" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC15" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.5 Options that modify treecc's behaviour </h2>

<p>&quot;(*)&quot; is used below to indicate an option that is enabled by default.
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%option track_lines</samp>&rsquo;</dt>
<dd><a name="IDX7"></a>
<p>Enable the generation of code that can track the current filename and
line number when nodes are created.  See section <a href="treecc_5.html#SEC17">Tracking line numbers in source files</a>, for more
information. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option no_track_lines</samp>&rsquo;</dt>
<dd><a name="IDX8"></a>
<p>Disable the generation of code that performs line number tracking.
</p>
</dd>
<dt> &lsquo;<samp>%option singletons</samp>&rsquo;</dt>
<dd><a name="IDX9"></a>
<p>Optimise the creation of singleton node types.  These are
node types without any fields.  Treecc can optimise the code
so that only one instance of a singleton node type exists in
the system.  This can speed up the creation of nodes for
constants within compilers. (*)
</p>
<p>Singleton optimisations will have no effect if &lsquo;<samp>track_lines</samp>&rsquo;
is enabled, because line tracking uses special hidden fields in
every node.
</p>
</dd>
<dt> &lsquo;<samp>%option no_singletons</samp>&rsquo;</dt>
<dd><a name="IDX10"></a>
<p>Disable the optimisation of singleton node types.
</p>
</dd>
<dt> &lsquo;<samp>%option reentrant</samp>&rsquo;</dt>
<dd><a name="IDX11"></a>
<p>Enable the generation of reentrant code that does not rely
upon any global variables.  Separate copies of the compiler
state can be used safely in separate threads.  However, the
same copy of the compiler state cannot be used safely in two or
more threads.
</p>
</dd>
<dt> &lsquo;<samp>%option no_reentrant</samp>&rsquo;</dt>
<dd><a name="IDX12"></a>
<p>Disable the generation of reentrant code.  The interface to
node management functions is simpler, but cannot be used
in a threaded environment. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option force</samp>&rsquo;</dt>
<dd><a name="IDX13"></a>
<p>Force output source files to be written, even if they are
unchanged.  This option can also be set using the &lsquo;<samp>-f</samp>&rsquo;
command-line option.
</p>
</dd>
<dt> &lsquo;<samp>%option no_force</samp>&rsquo;</dt>
<dd><a name="IDX14"></a>
<p>Don't force output source files to be written if they are the
same as before. (*)
</p>
<p>This option can help smooth integration of treecc with make.
Only those output files that have changed will be modified.
This reduces the number of files that the underlying source
language compiler must process after treecc is executed.
</p>
</dd>
<dt> &lsquo;<samp>%option virtual_factory</samp>&rsquo;</dt>
<dd><a name="IDX15"></a>
<p>Use virtual methods in the node type factories, so that the
programmer can subclass the factory and provide new
implementations of node creation functions.  This option is
ignored for C, which does not use factories.
</p>
</dd>
<dt> &lsquo;<samp>%option no_virtual_factory</samp>&rsquo;</dt>
<dd><a name="IDX16"></a>
<p>Don't use virtual methods in the node type factories. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option abstract_factory</samp>&rsquo;</dt>
<dd><a name="IDX17"></a>
<p>Use abstract virtual methods in the node type factories.
The programmer is responsible for subclassing the factory
to provide node creation functionality.
</p>
</dd>
<dt> &lsquo;<samp>%option no_abstract_factory</samp>&rsquo;</dt>
<dd><a name="IDX18"></a>
<p>Don't use abstract virtual methods in the node type factories. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option kind_in_node</samp>&rsquo;</dt>
<dd><a name="IDX19"></a>
<p>Put the kind field in the node, for more efficient access at runtime. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option kind_in_vtable</samp>&rsquo;</dt>
<dd><a name="IDX20"></a>
<p>Put the kind field in the vtable, and not the node.  This saves some
memory, at the cost of slower access to the kind value at runtime.
This option only applies when the language is C.  The kind field is
always placed in the node in other languages, because it isn't possible
to modify the vtable.
</p>
</dd>
<dt> &lsquo;<samp>%option prefix = PREFIX</samp>&rsquo;</dt>
<dd><a name="IDX21"></a>
<p>Specify the prefix to be used in output files in place of &quot;yy&quot;.
</p>
</dd>
<dt> &lsquo;<samp>%option state_type = NAME</samp>&rsquo;</dt>
<dd><a name="IDX22"></a>
<p>Specify the name of the state type.  The state type is generated
by treecc to perform centralised memory management and reentrancy
support.  The default value is &lsquo;<samp>YYNODESTATE</samp>&rsquo;.  If the output language
uses factories, then this will also be the name of the factory
base class.
</p>
</dd>
<dt> &lsquo;<samp>%option namespace = NAME</samp>&rsquo;</dt>
<dd><a name="IDX23"></a>
<p>Specify the namespace to write definitions to in the output
source files.  This option is ignored when the output language
is C.
</p>
</dd>
<dt> &lsquo;<samp>%option package = NAME</samp>&rsquo;</dt>
<dd><a name="IDX24"></a>
<p>Same as &lsquo;<samp>%option namespace = NAME</samp>&rsquo;.  Provided because &lsquo;<samp>package</samp>&rsquo;
is more natural for Java programmers.
</p>
</dd>
<dt> &lsquo;<samp>%option base = NUM</samp>&rsquo;</dt>
<dd><a name="IDX25"></a>
<p>Specify the numeric base to use for allocating numeric values to
node types.  By default, node type allocation begins at 1.
</p>
</dd>
<dt> &lsquo;<samp>%option lang = LANGUAGE</samp>&rsquo;</dt>
<dd><a name="IDX26"></a>
<p>Specify the output language.  Must be one of <code>&quot;C&quot;</code>, <code>&quot;C++&quot;</code>,
<code>&quot;Java&quot;</code>, <code>&quot;C#&quot;</code>, <code>&quot;Ruby&quot;</code>, <code>&quot;PHP&quot;</code>, or <code>&quot;Python&quot;</code>.
The default is <code>&quot;C&quot;</code>.
</p>
</dd>
<dt> &lsquo;<samp>%option block_size = NUM</samp>&rsquo;</dt>
<dd><a name="IDX27"></a>
<p>Specify the size of the memory blocks to use in C and C++ node allocators.
</p>
</dd>
<dt> &lsquo;<samp>%option strip_filenames</samp>&rsquo;</dt>
<dd><a name="IDX28"></a>
<p>Strip filenames down to their base name in <code>#line</code> directives.
i.e. strip off the directory component.  This can be helpful in
combination with the <code>%include %readonly</code> command when
treecc input files may processed from different directories,
causing common output files to change unexpectedly.
</p>
</dd>
<dt> &lsquo;<samp>%option no_strip_filenames</samp>&rsquo;</dt>
<dd><a name="IDX29"></a>
<p>Don't strip filenames in <code>#line</code> directives. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option internal_access</samp>&rsquo;</dt>
<dd><a name="IDX30"></a>
<p>Use <code>internal</code> as the access mode for classes in C#, rather than
<code>public</code>.
</p>
</dd>
<dt> &lsquo;<samp>%option public_access</samp>&rsquo;</dt>
<dd><a name="IDX31"></a>
<p>Use <code>public</code> as the access mode for classes in C#, rather than
<code>internal</code>. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option print_lines</samp>&rsquo;</dt>
<dd><a name="IDX32"></a>
<p>Print <code>#line</code> markers in languages that use them. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option no_print_lines</samp>&rsquo;</dt>
<dd><a name="IDX33"></a>
<p>Do not print <code>#line</code> markers, even in languages that normally
use them.
</p>
</dd>
<dt> &lsquo;<samp>%option allocator</samp>&rsquo;</dt>
<dd><a name="IDX34"></a>
<p>Use treecc's standard node allocator for C and C++.  This option has
no effect for other output languages. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option no_allocator</samp>&rsquo;</dt>
<dd><a name="IDX35"></a>
<p>Do not use treecc's standard node allocator for C and C++.  This can be
useful when the programmer wants to redirect node allocation to their
own routines.
</p>
</dd>
<dt> &lsquo;<samp>%option gc_allocator</samp>&rsquo;</dt>
<dd><a name="IDX36"></a>
<p>Use libgc as a garbage-collecting node allocator for C and C++.  This
option has no effect for other output languages.
</p>
</dd>
<dt> &lsquo;<samp>%option no_gc_allocator</samp>&rsquo;</dt>
<dd><a name="IDX37"></a>
<p>Do not use libgc as a garbage-collecting node allocator for C and C++. (*)
</p>
</dd>
<dt> &lsquo;<samp>%option base_type</samp>&rsquo;</dt>
<dd><a name="IDX38"></a>
<p>Specify the base type for the root node of the treecc node heirarchy.
The default is no base type.
</p>
</dd>
</dl>


<hr size="6">
<a name="Literal-Code"></a>
<a name="SEC15"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC14" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC16" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.6 Literal code declarations </h2>

<p>Sometimes it is necessary to embed literal code within output &lsquo;<samp>.h</samp>&rsquo;
and source files.  Usually this is to &lsquo;<samp>#include</samp>&rsquo; definitions
from other files, or to define functions that cannot be easily expressed
as operations.
</p>
<p>A literal code block is specified by enclosing it in &lsquo;<samp>%{</samp>&rsquo; and
&lsquo;<samp>%}</samp>&rsquo;.  The block can also be prefixed with the following flags:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%decls</samp>&rsquo;</dt>
<dd><a name="IDX39"></a>
<p>Write the literal code to the currently active declaration header file,
instead of the source file.
</p>
</dd>
<dt> &lsquo;<samp>%both</samp>&rsquo;</dt>
<dd><a name="IDX40"></a>
<p>Write the literal code to both the currently active declaration header file
and the currently active source file.
</p>
</dd>
<dt> &lsquo;<samp>%end</samp>&rsquo;</dt>
<dd><a name="IDX41"></a>
<p>Write the literal code to the end of the file, instead of the beginning.
</p></dd>
</dl>

<p>Another form of literal code block is one which begins with &lsquo;<samp>%%</samp>&rsquo; and
extends to the end of the current input file.  This form implicitly has
the &lsquo;<samp>%end</samp>&rsquo; flag.
</p>

<hr size="6">
<a name="Changing-Files"></a>
<a name="SEC16"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC15" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC9" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 4.7 Changing input and output files </h2>

<p>Most treecc compiler definitions will be too large to be manageable
in a single input file.  They also will be too large to write to a
single output file, because that may overload the source language
compiler.
</p>
<p>Multiple input files can be specified on the command-line, or
they can be explicitly included by other input files with
the following declarations:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%include [ %readonly ] FILENAME</samp>&rsquo;</dt>
<dd><a name="IDX42"></a>
<a name="IDX43"></a>
<a name="IDX44"></a>
<p>Include the contents of the specified file at the current point
within the current input file.  &lsquo;<samp>FILENAME</samp>&rsquo; is interpreted
relative to the name of the current input file.
</p>
<p>If the &lsquo;<samp>%readonly</samp>&rsquo; keyword is supplied, then any output
files that are generated by the included file must be read-only.
That is, no changes are expected by performing the inclusion.
</p>
<p>The &lsquo;<samp>%readonly</samp>&rsquo; keyword is useful for building compilers
in layers.  The programmer may group a large number of useful
node types and operations together that are independent of the
particulars of a given language.  The programmer then defines
language-specific compilers that &quot;inherit&quot; the common definitions.
</p>
<p>Read-only inclusions ensure that any extensions that are added
by the language-specific parts do not &quot;leak&quot; into the common code.
</p></dd>
</dl>

<p>Output files can be changed using the follow declarations:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%header FILENAME</samp>&rsquo;</dt>
<dd><a name="IDX45"></a>
<a name="IDX46"></a>
<p>Change the currently active declaration header file to &lsquo;<samp>FILENAME</samp>&rsquo;,
which is interpreted relative to the current input file.  This option
has no effect for languages without header files (Java and C#).
</p>
<p>Any node types and operations that are defined after a &lsquo;<samp>%header</samp>&rsquo;
declaration will be declared in &lsquo;<samp>FILENAME</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>%output FILENAME</samp>&rsquo;</dt>
<dd><a name="IDX47"></a>
<a name="IDX48"></a>
<p>Change the currently active source file to &lsquo;<samp>FILENAME</samp>&rsquo;,
which is interpreted relative to the current input file.  This option
has no effect for languages that require a single class per file (Java).
</p>
<p>Any node types and operations that are defined after a &lsquo;<samp>%header</samp>&rsquo;
declaration will have their implementations placed in &lsquo;<samp>FILENAME</samp>&rsquo;.
</p>
</dd>
<dt> &lsquo;<samp>%outdir DIRNAME</samp>&rsquo;</dt>
<dd><a name="IDX49"></a>
<a name="IDX50"></a>
<p>Change the output source directory to &lsquo;<samp>DIRNAME</samp>&rsquo;.  This is only
used for Java, which requires that a single file be used for each class.
All classes are written to the specified directory.  By default,
&lsquo;<samp>DIRNAME</samp>&rsquo; is the current directory where treecc was invoked.
</p></dd>
</dl>

<p>When treecc generates the output source code, it must insert several
common house-keeping functions and classes into the code.  By default,
these are written to the first header and source files.  This can
be changed with the &lsquo;<samp>%common</samp>&rsquo; declaration:
</p>
<dl compact="compact">
<dt> &lsquo;<samp>%common</samp>&rsquo;</dt>
<dd><a name="IDX51"></a>
<a name="IDX52"></a>
<p>Output the common house-keeping code to the currently active
declaration header file and the currently active source file.
This is typically used as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">%header &quot;common.h&quot;
%output &quot;common.c&quot;
%common
</pre></td></tr></table>
</dd>
</dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC9" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="treecc_5.html#SEC17" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="treecc.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="treecc_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="treecc_9.html#SEC27" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="treecc_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Klaus Treichel</em> on <em>January, 18 2009</em> using <a href="http://www.nongnu.org/texi2html/"><em>texi2html 1.78</em></a>.
 </font>
 <br>

</p>
</body>
</html>
