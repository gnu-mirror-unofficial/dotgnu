DotGNU
Resource String Locators

By:

Enzo-Adrian Reyes
Barry Fitzgerald




Introduction:

             The idea behind RLS (Resource String Locators) is the easy identification, and of passing 
information from peer to peer. It can also be used by end users to locate remote services provided by DotGNU.
RLS's can be used to point to any DotGNU, this forces the RLS to be generic in format and also extendable for
the individual service. Hence each service may expect a different RLS input, it is upto the individual 
service to interpret it's RLS tokens and data.


Format:


            The format of an RLS, contains two non-optional fields, these fields are seperated using the ':' 
character. As an extension to these non-optional fields RLS's have two extra fields which are optional. 
The format of an RLS is as follows:


             [Username@]<server>:<DotGNU services>[:Tokens]

The optional fields are in square brakets, while the non-optional fields are in nested in "<>" brackets.


The Fields:


The first non-optional field is the "<server>" field. This field tells a machine the IP/DNS of the server to 
locate the service. The second field is the "<DotGNU Service>" field it contains a string which is passed to 
the server, contained in the server field, to open the named service.

Examples:


(1)dotgnu.org:cvs
(2)dotgnu.org:maillists
(3)gnu.org:tbbs

This opens the dotgnu.org server and aks it's cvs service. The second example also opens the same server and 
ask's to use the mail-list service. The third opens gnu.org and asks for the tbbs service.

In essence it's a DNS address instead of opening a port (format <ip>:<port>) it asks for that servers service 
specified in the second field.


The Optional fields:

The optional fields contain information which is of no use to the main DotGNU server, but rather to the service
it provides.

The first optional field is the username field. Now this field is used for the authentication mechanism in 
DotGNU. 

Example:


(1)myrddian@dotgnu.org:authentication
(2)fitzix@dotgnu.org:authentication
(3)nb@dotgnu.org:auth
(4)myrddian@dotgnu.org:cvs

So here in these examples all use the authentication service (different names can be user but convention should
be followed). So it tells us, that user myrddian is seeking authentication from server dotgnu.org. Another less
obvious example is that of self authentication. In number four, user myrdddian wants to use the CVS service but
CVS may ask for authentication, however the authentication data is on the local server, so it' will 
self verify.


     The second optional field is the tokens field, now tokens can contain any data, be it a poitner back to 
another object, a string. The format of  tokens on how their data is represented is not enforced, tha main 
DotGNU server will not enforce token data.

      The only exception to this rule is seperation of Token data, and or nesting of token data. These are the 
only two rules enforce by the primary DotGNU server, everything else and the data the tokens contains has to 
be enforced by the individual service.


      Tokens are seperated using the ',' character, so <token 1>,<token2> can be recognised seperatly. If a 
string contains  the comma seperator it is recommended that it be nested withing " " as this prevents 
premature seperation.

Example:

             (1) dotgnu.org:spell:"I wnt to chke my, speeling"
             (2) dotgnu.org:cvs: checkout, checkin

In the first a string is passed and contains the comma character but it's nested inside quotes hence it's 
ignored. The second example two cvs commands are passed via the tokens and are seperated using the 
comma character.

This also applies to strings containing the ':' character, they must be contained within quotes.

Nested tokens, nested tokens have two ways to seperate the data, one way is to have the entire nested data 
within square brackets, the other is to have an identifier before the square brackets. 

Now the first format might be useful to encase other RLS on to the same string, an example of this the first 
would contain the where the service the second where authentication can be found for the user requesting the 
service.

Tokens with an identifier may contain other data other than nested RLS's.

Example :
(1)dotgnu.org:cvs:[myrddian@someisp.com:authentication]
(2)dotgnu.org:im:msg["hey","what"]
(3)dotgnu.org:cvs:[myrddian@someisp.com:auth],cmd[checkout[.], checkin]

Number 1 uses another RLS to check authentication for the CVS service.
Number 2, uses a named nested token and it has two extra fields inside.
Number 3, has both seperation and nesting examples.


Conclusion

     With the optional nesting fields, RLS's can point to any data. Their simplification has lead to better 
vercitility.  Because the tokens can point to any data, the data pointed to can be encrypted. While the RLS 
string it self may be transported over a secure encrypted protocol to provide better security. 
Tokens can also contain nested encryption keys, thus allowing even better security.
